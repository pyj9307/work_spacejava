[자바 해바라기 정리] 
0 들어가며
자바가 나온지 약 25년 , 안드로이드를 사용하는 핸드폰의
애플리케이션 에서부터 전자정부 웹 즉 엔터프라이즈 까지
대부분의 IT 분야에서 사용되고 전 세계에서 가장 활용도 높은
프로그래밍 언어로 주목 받고 있다.

자바의 기본 문법 많이 쉬운 편이다. 객체지향적인 개념 중요.
객체지향이란 실생활을 프로그래밍에 반영하면서 시작.
기초 문법, 객체지향 개념을 최대한 실생활과 연결하여 쉽게 접근.

프로그래밍 공부 쉽게 접근 방법.
수다 떨기. -> 많이 타이핑 해보기
문법 오류 겁내지 말고 차분히 보기, 단, 영어이지만,
조금만 노력하면 쉽게 이해 가능.

어떻게 공부?
2-5장은 변수 , 연산자 , 제어문 , 배열
: 젓가락질하는 방법 배우기 정도. 완벽 이해.

6장 7장 객체 , 클래스 , 추상화 , 데이터 은닉과 
보호, 상속, 다형성 등 객체지향 의 핵심적인 내용
: 밥 수준. -> 반복 정독

8장 - 10장, 클래스 이외에 자바 애플리케이션 구성요소나
예외처리, 내부 클래스, 람다표현식 등 
:빠져서 안되는 필수 프로그래밍 기법 김치 정도

나머지 부분은 자바에서 제공하는 API를 배우는 부분 
: 양념정도, 

11장 lang 패키지, 12장 유용한 클래스들과 
13장 컬렉션 프레임워크 는 소금 레벨의 양념.

대부분 메서드 사용법이기 때문에 외우려고 하기보다
이런 것이 있구나. 정도로 기억하고 있다가
필요한 상황에서 찾아 볼수 있게,

14장 스레드 15장 I-O, 16장 스트림
매번 쓰는 양념은 아니다. 
이 부분은 어렵기도 하고, 자주 사용되지도 않는다.
(상황에 따라 다름.)
해당 기능이 필요할 때 그때그때 공부하고 사용하기.
웹 프로그래밍 -> 스레드나 I-O 를 접할 기회가 거의 없다.
그러나, 안드로이드 에서는 스레드가 필수적.

저자 카페: 조용준님.
https://cafe.naver.com/lifecoding 
모르면 저자에게 질문.

===================================
[자바 해바라기 정리][1 자바 첫걸음]
1.자바 언어 소개

1.1 자바란?

오라클(Oracle : 과거 Sun Microsystems)에서 
개발한 객체지향 프로그래밍 언어.  1996년 발표.
1990년대 말 인터넷 활성화 시점과 맞물려 웹 환경에 
가장 적합한 언어로 인식. 많은 인기 .
웹, 데스크톱 애플리케이션, 안드로이드 모바일 애플리케이션
거의 모든 프로그래밍 분야에 사용 

웹 사이트 검색 빈도수 로 순위 채점 http://www.tiobe.com 발표 
웹 분야에서 대체할 만한 다른 언어가 없어서 꾸준히 인기 유지 할 듯. 

처음 자바 발표 당시, 테스트 개발자는 30명쯤. 
현재, 전 세계 9백만명 이상의 개발자 있고, 
엔터프라이즈 애플리케이션 시장의 97% 이상 차지.

계속 업그레이드 중, 성능 개선 및 기능 추가.
2018년 3월 자바 10 버전 까지 발표 
1.5 버전 부터 -> 자바5 처럼 부름. 

자바 버전별 주요 특징 
내부 버전 : 호칭 : 발표 연도 : 특징 
1.0 : 자바 1.0 : 1996 : 애플릿 기반 
1.1 : 자바 1.1 : 1997 : 내부 클래스, RMI, JDBC, Java Beans
1.2 : 자바 2 : 1998 : Swing, 컬렉션 프레임워크
1.3 : 자바 2 버전 1.4 : 2000 : JVM 개선, JNDI 
1.4 : 자바 2 버전 1.4 : 2002 : assertion, 정규표현식, 자바 웹 스타트 
1.5 : 자바 5.0 : 2004 : 제너릭, for-each 반복문 , 가변인수, 오토박싱,
enum, annotation
1.6 : 자바 6 : 2006 : 컬렉션 프레임워크 개선 
1.7 : 자바 7 : 2011 : <> 연산자, try - with - resources, switch 개선 
1.8 : 자바 8 : 2013 : Lambda, 날짜-시간 관리 강화, 스트림 API
1.9 : 자바 9 : 2017 : jigsaw 프레임워크, JShell, 
컴파일러 개선, 스트림 API 강화
1.10 : 자바 10 : 2018 : 로컬변수에 대한 타입 추정, 내부적인 성능 개선 

특히, 버전 중 1.1 , 1.2 , 1.5 , 1.8 의 업데이트 자바 
프로그래밍 방식에 많은 변화를 준 메이저 업데이트로 평가 . 

새버전이 나왔다고 그 버전을 바로 학습해서 사용하는 건 비추.
실무에서는 새 버전 사용이 보수적이다. 혹시, 모를 오류 및 버그 부담.

plumbr.io 의 발표에 따르면 자바 8은 2013 발표 되어도, 
2016년까지 가장 많이 사용된 버전은 자바 7,
2017 년 들어서야 비로소 8이 주버전으로 사용. 
실제, 현업에서는 프로젝트에 사용되는 자바의 버전이 낮아서 
최신의 라이브러리를 사용하는데 어려움을 겪음.

8부터 10까지의 공통된 내용을 기준으로 설명할 계획. 

9와 10은 부록. 필요할 때 찾아 보기.
----------------------------------------------------

1.2 자바 언어의 특징

운영체제 독립적인 언어이다.
자바의 특징을 나타내는 문장 " Write Once, Run Anywhere".
즉, 프로그램은 한번만 작성하고 어디서나 동작 시킨다.
이를 위해 JVM 가상 머신 개념 도입.
OS와 통신하지 않고, OS위에 설치된 JVM과 통신. 독립적.

객체지향 언어이다. 
현실 세계를 모델링해서 프로그래밍하는 언어로 다른 언어에
비해 개발자가 상대적으로 이해하기 쉽다. 
OOP is A P I E !
Object Oriented Programming.
Abstraction (추상화)
Polymorphism (다형성)
Inheritance (상속)
Encapsulation (캡슐화)

상대적으로 배우기 쉬운 언어이다.
C 언어가 자바보다 오래되고, 아직도 활발히 개발이 되고 있다. 
C 언어의 어려운 단원 포인터, 메모리 관리.
자바에서는 GC(Garbage Collector)이라는 개념을 이용 
메모리 관리 자동으로 처리. 포인터를 이용한 연산은 지원 안함.

매우 다양한 API 제공된다.
프로그래밍이란 필요한 기능을 컴퓨터를 통해서 구현하는 일.
이 과정에서 도움을 주는 다양한 도구가 있다면 편할 것이다. 
밀가루 와 레시피(recipe)를 제공한다면 훨씬 쉽다.
이것을 프로그래밍에서 API(Application Programming Interface)
라 한다. 
API 에 대한 사용법을 잘 익히는 것이 중요.
기본 시스템 라이브러리 뿐 아니라, 다양한 오픈소스 라이브러리가
API로 제공된다. 참조해서 개발 기간을 단축하고, 
신뢰성 있는 프로그래밍 가능. 
문제는 너무 많다는 점. 
많은 API에 대한 해답은 구글링. 

람다를 이용한 함수형 프로그래밍 지원,
손쉬운 멀티스레드 프로그래밍 지원,
객체의 동적 로딩,
네트워크 및 원활한 분산 처리 지원등. 

(1) JVM (Java Virtual Machine)
자바가 운영체제 독립적으로 동작 할수 있는 이유.
C 언어의 예 
C 언어는 텍스트로 소스 코드를 작성하고 컴파일러를 이용해서 
컴파일(compile)과 링킹(linking) 과정을 거친다.
그 결과물은 바이너리로 흔히 실행 파일이라 한다. 
이 바이너리 실행하면 OS(Operating System)
운영체제, 플랫폼) 가 기계어로 번역해서 
CPU (Central Processing Unit : 중앙 처리장치)
에 전달한다. 
문제는 OS 마다 이 바이너리 를 해석하는 방식이 다르다는 점. 
맥에서 컴파일된 결과는 맥에서 만 유효하고,
윈도우에서는 유효하지 않다. 
이것을 플랫폼 종속적이라 한다. 
반면, 자바는 OS에서 JVM이라는 가상 머신이 설치 되어야 한다. 
C 언어와 마찬가지로 자바 역시 텍스트로 만든 소스 코드를
javac 명령을 이용해 컴파일하면 확장자가 class 인 byte 코드가 생성. 
이 byte 코드를 실행하기 위해서 java 명령을 사용. 
java 명령은 인터프리터로서 byte 코드를 한 줄 씩 해석해서 
JVM 내에서 실행 한다. 
OS 와 통신하지 않기 때문에 기본적으로 플랫폼에 독립적이다. 
JVM 이 있기 때문에, "Write Once, Run Anywhere" 가능. 

(2) 가비지 컬렉터 (Garbage Collector: GC) 
쓰레기를 모아 주는 것. 
쓰레기: 프로그램에서 사용하고 난 메모리 공간.
프로그램들은 OS로 부터 일부 메모리를 할당받아서 사용.
이 메모리 공간에 어떤 값을 저장해 사용하고, 더는 필요 없어지면
해당 메모리 공간을 비워서 다른 데이터를 저장 할 수 있게 해야 한다. 
이 과정이 없다면 점차 메모리 부족 오류가 발생하고, 프로그램은 비정상적
으로 종료 된다. 따라서, 메모리 관리가 아주 중요한 부분이고,
초보 개발자가 놓치기 쉽다. 
그래서, 자바는 가비지 컬렉터가 내장되어 , 사용하지 않는 
메모리 공간을 자동으로 회수함.
프로그래머가 메모리 관리로부터 많이 자유로워진다. 
GC는 시스템이 한가할 때나 메모리가 부족한 위급 상황,
JVM 구현에 따라 알아서 동작.
프로그래머가 임의로 동작 시키지 않는다. 

----------------------------------------------------
2. 개발 환경 구축
자바 프로그램 개발 하기 위해서 JDK(Java Development Kit)
자바 개발 키트가 설치 되어야 한다. 
JDK는 JVM, 개발에 필요한 컴파일러, 개발도구와 
기본 시스템 라이브러리, JRE(Java Runtime Environment)
자바 구동 환경이 포함. 
JRE에는 JVM, 기본 시스템 라이브러리 포함.
개발을 위해서는 JDK가 필요하고,
이미 개발된 프로그램을 단순히 실행만 하려는 경우는 JRE만 있으면 된다. 

2.1 자바 JDK의 종류
자바는 개발 분야에 따라 크게 
Java SE, Java EE, Java Embedded 로 나뉜다. 
Java SE(Standard Edition)
자바 언어의 핵심 기능을 제공한다. 
이 책에서 학습하는 내용도 이것이다. 
Java EE(Enterprise Edition) 
Java SE 플랫폼 위에 구축하고, 기업용 애플리케이션
제작에 필요한 도구, 라이브러리를 제공한다. 
Java Embedded
핸드폰 등 모바일 기기나 다른 임베디드 장치에 사용되는 버전. 
현재, Java SE의 JDK가 필요. 

----------------------------------------------------
2.2 JDK 설치 
JDK는 Oracle 웹사이트 
http://www.oracle.com/technetwork/java/javase/downloads/index.html
에서 다운로드 할수 있다. (주소는 버전 이나 접속 시점에 따라 다르다. )
Java SE 10 버전 다운. -> 변경 
11.0.2 버전으로 다운. 
설치 진행.
가이드 사이트 
https://docs.oracle.com/en/java/javase/11/

설치가 끝나면 JDK 설치된 경로 
C:\Program Files\Java\jdk-11.0.2
여기서 bin 디렉터리 안에 
컴파일러 javac.exe,
인터프리터 java.exe 
자바 도큐멘테이션 만드는 javadoc.exe 
자바 9에서 추가된 jshell.exe 
다양한 개발도구 확인. 


----------------------------------------------------
2.3 자바 도큐멘테이션 확인 

자바 API에 대한 설명서. 
JDK를 다운로드의 웹 페이지에서 아래로 스크롤 하면 
Additional Resources (추가 리소스) 부분이 나온다. 
도큐멘테이션 확인하기 위해서는 
Java SE 
10 버전 확인 하기.
https://docs.oracle.com/javase/10/docs/api/index.html?overview-summary.html
p44 확인 
Package Explorer -> JRE System Library 확장하고 
우클릭 Properties 선택 -> Javadoc Location 
URL path : https://docs.oracle.com/en/java/javase/11/docs/api/
변경

----------------------------------------------------
2.4 환경 변수 설정 
필수 사항은 아니지만, 나중에 라이브러리 관리 시스템 도구인 
MAVEN 등에서 JAVA_HOME 환경변수를 찾는 경우가 있어
미리 설정 진행하는게 좋음. 

제어판 -> 시스템 -> 고급 시스템 설정 
시스템 (변수)속성 창에서 환경변수 버튼 클릭. 
새로 만들기 클릭하여. 설정. 
변수이름 
JAVA_HOME
변수 값 지정. 
C:\Program Files\Java\jdk-11.0.2
!
Path에
C:\Program Files\Java\jdk-11.0.2\bin
추가.

CLASSPATH 
확인.
C:\Program Files\Java\jdk-11.0.2\lib;.; 
뒤에 ";.; "확인. 

----------------------------------------------------
3. 애플리케이션 개발 및 실행 절차

이제 JDK 설치 되어서 자바 애플리케이션 개발이 가능. 
자바 프로그램 소스 파일은 확장자를 *.java 로 한다. 
이를 컴파일러인 javac.exe 로 컴파일하면 확장자를 
*.class 로 결과물 생성. 
*.class  파일을 java.exe 로 실행해서
java.exe 는 인터프리터로써 *.class 파일을 한 줄씩 읽어서 
기계어로 번역 후 JVM에서 실행. 

3.1 메모장을 이용한 프로그램 작성 
메모장에서 

public class Hello {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
System.out.println("안녕 자바!!");
	}

}

오타 주의 !!
주의 사항 
1. public 이 붙은 class는 하나의 소스 파일에 하나만 존재. 
2. public class 가 있다면 소스 파일의 이름은 class 이름과 같아야 한다. 
3. 대/소문자를 구별해서 작성.
4. 문장의 끝은 세미콜론 (;) 으로 끝낸다. 
5. 영역을 표시 할 때는 중괄호 ({ } )를 사용하며 중첩해서 사용 가능. 

작성 후, 파일 - 다른 이름으로 저장 
c:\Temp로 선택하고, Hello.java 라 입력하고 저장. 


----------------------------------------------------
3.2 이클립스 활용 

프로그램 개발 도구를 IDE(Integrated Development Environment)
통합 개발 환경이라 부른다. 
프로그램 개발시 IDE 를 잘 사용할 때와 그렇지 않을 때 생산성의 차이가
매우 크다. 
프로그램 개발을 위한 IDE 중 가장 많이 사용되는 것은 
www.ecilpse.org에서 배포하는 이클립스 (Eclipse).
무료이고 플러그인 방식으로 개발에 필요한 다양한 기능들
(Git, Maven, Code Assist, 등 ) 손쉽게 추가할수 있는 장점.

(1) 이클립스 설치와 실행. 
http://www.eclipse.org/
에서 다운로드
앞으로 웹 분야까지 활용하기 위해서는 
Java SE 와 Java EE 까지 쉽게 접근 할 수 있는 
Eclipse IDE for Java EE Developers 를 사용. 

D 드라이브나 , 사용할 폴더 워크스페이스 공간 지정. 

Workspace 변경 하고 싶다면, 
File - Switch - Workspace - Other 메뉴를 통해서 변경. 

(2) 이클립스의 기본 화면 구성과 배치 
편집기 기본 구조. 
작은 창들이 배치 : 뷰 
Project Explorer : 프로젝트들의 소스, 경로 등 전반적인 사항에 대한 관리 
소스 편집 : 소스 코드를 편집. 
Outline 소스 파일의 구조를 표시 

Console 뷰 : 표준 출력에 자주 사용 
Window - Show View - Console 선택. 

디버깅 정보 보여주는 
Debug, Variables, Breakpoints 등의 뷰가 훨씬 유용하다. 
각 뷰들을 보기가 불편하므로, 
퍼스펙티브(Perspective) 뷰를 그룹화해서 관리. 
Windows - Perspective 메뉴에서 관리 

오른쪽 상단 퍼스펙티브로 원래 자바로 변경 가능. 

(3) 인코딩 설정. 
인코딩 파일을 저장할 때 사용하는 부호화 방식으로 어떤 문자 
코드(Character code )를 사용할 것인지 결정하는 것. 
다른 팀원들과 협업할 때 서로간의 인코딩이 맞지 않은 상태에서 
소스를 열면 글자가 깨지므로, 변경. !!
Windows는 기본 인코딩 MS949 , 
OS에 상관없이 표준적으로 사용할 수 있는 UTF-8 사용. 
!
Window - Preference - type filter text 
-workspace 입력 
Text file encoding 에서 
Other : UTF-8 선택. 
!

(4) 새로운 프로젝트 생성 
File - New - Java Project : 선택 
Project name 에 적당한 이름. :Java-0312
Location 영역은 자동 입력 .
프로젝트 이름은 같은 Workspace 내에서 중복 불가. 

JRE 설정 부분에서 
현재 설치된 JDK 폴더로 지정. 
C:\Program Files\Java\jdk-11.0.2

(5) 소스 파일의 생성과 실행 
프로젝트-src-에서 우클릭 new - class 만들기. 
Names : Hello 
입력 .
public static void main(String[] args) 체크 하기.
만들기 .
stub (대충 만들어 놓은 뼈대 정도)
class 만들 때 main() 메서드 뼈대를 만들어준다. 

내용에 
public class Hello {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
System.out.println("안녕 자바!!");
	}

}
추가  , 파일명 부분에 * 표시 된다. 
ctrl + s 저장 하면 없어짐. 

코드 실행 : F11 , play 버트 클릭. 
Always save resources before launching 항목 체크하기. 
콘솔 뷰에서 확인. 
코드 템플릿을 이용한 코드 자동완성 기능 지원. 
System.out.println(); 자주 나오는 데 
main() 메서드 안에서 
"sysout " ctrl + space 하면 자동 완성. 

(6) 컴파일과 디버깅 
이클립스는 코드를 입력하면 자동으로 바로 컴파일 수행. 
프로젝트 디렉터리 에 src 와 bin 디렉터리가 생성 

소스 코드에서 static 정적 메서드를 만드는 자바 키워드. 
STATIC 으로 변경 해보자.  저장 할 필요 없고, 
오류 코드 생성.  
자바의 키워드가 아니라 오류가 발생하고 소스 코드에 빨간 밑줄이 
생기고, 줄번호 앞에도 에러 기호 표시. 
저장과 상관없이 컴파일 되고 오류를 소스 편집 부분에 바로 표시. 
마우스 커서로 확인 하면 오류의 자세한 내용을 알려준다. 

----------------------------------------------------
3.3 소스 코드 분석 

앞에 작성한 Hello.java 소스 코드 분석. 
이 짧은 코드를 완벽히 이해하기 위해서는 7장까지 학습이 끝나야 한다. 
용어나 설명이 이해 안되는 부분 . 일단 이런 것이 있구나 하고
넘어가기. 

package helloProject;

public class Hello {

	public static void main(String[] args) {

System.out.println("안녕 자바!!");
	}

}

1행 
package는 자바의 예약어로 , 소스 파일을 다양한 
기준으로 분리해서 관리.
3행 
public , class 는 자바 예약어. 
public이 붙은 class의 이름은 반드시 파일 이름과 같아야 함.!!
4행 
여는 중괄호 { , class 영역의 시작을 나타내며 , 짝을 이룬다. }
클래스 영역. 
클래스 영역에 뒤에 배울 ,  멤버 변수, 멤버 메서드 등 선언문 위치.
5행 
main() 메서드에 대한 선언부 
public, static, void  모두 자바 예약어. main은 메서드 이름. 
소괄호 안의 String[ ] args 는 메서드의 파라미터(parameter).
6행 
메인 메서드 내부 중괄호 내부를 메서드 구현부라고 한다. 
어떤 일을 수행하는 실행문이 작성되는 곳. 
대부분 메서드는 필요에 따라 개발자가 만들고 수정 가능. 
main( ) 메서는 아주 특별함. 
이 메서는 자바 애플리케이션의 시작점.
다른 메서드들은 이름 등을 변경 할수 있고,
main( ) 메서드의 선언부는 언제나 위 예제처럼 써야 한다. 
7행 
System.out.println(); 콘솔에 무언가를 출력하기 위해 사용. 
문자열을 표현 할 때에는 큰 따옴표로 묶기. 
System과 out, println( ) 모두 마침표를 이용해서 
연결돼 있는데 
이런 표기법을 dot notation (마침표 표기법)이라고 부른다. 
'XX가 가지고 있는'으로 해석. 
XX.YY는 XX가 가지고 있는 YY이다. 
각각의 항목에는 
소괄호가 있으면 메서드를 실행하는 것이고, 없으면 변수를 나타냄. 
System이 가지고 있는 out, out 이 가지고 있는 println( ) 메서드를
실행하라. 
 
코드 어시스트 (Code assist)
System. 이렇게 하면 코드 어시스트가 나온다. 
코드 입력 시간 줄이고, 오타 발생도 줄이고,
불필요한 디버깅 시간을 줄인다. 
예제 코드 공부하면서 발생하는 오류는 90%가 오류 일것이다. 
 
API 소스와 도큐멘테이션 연결 
System.out.println(); 메서드를 이용하여 파라미터인 문잘열이 콘솔에 출력.
이 메서는는 자바에서 기본적으로 제공되는 시스템 라이브러리에 구현 
되어 있다. 이런 라이브러리의 소스 코드를 확인하거나 도움말 확인이
필요하다. 

도움말은 앞서 보았던 자바 도큐멘테이션이다. 
이클립스에서는 대상 클래스, 메서드, 변수에 마우스 커서를 살 짝 
올리고 있으면 자동으로 팝업으로 나타난다. 

자세히 알아보기 위해 해당 메서드등에 올려 놓고 F1 누르기. 

API 소스 코드를 확인하기 위해서 Ctrl 키를 누른 상태에서 대상을 클릭. 
팝업 메뉴에서 Open Declaration 을 클릭 하면 API 소스코드를 확인
할수 있다. 

주석 
소스 코드에 작성하는 설명문으로 프로그램의 해독력을 향상시키는데 필요. 
소스는 수정 가능하므로 유지 보수를 위해서 주석은 반드시 필요. 
주석문은 컴파일 시에 결과에서 제외되기 때문에 애플리케이션의 크기에는
영향을 미치지 않는다. 하지만, 많은 주석은 가독성을 떨어 뜨림.
(1) 
"// " : 행주석 : 한 줄의 내용을 주석 처리. 
(2)
"/* */" : 블록 주석 : /* 와 */ 사이에 나오는 모든 내용을 주석으로 처리.
여러 라인 주석처리.
(3)
"/**  */" : 도큐먼트 주석 : /** 와 */ 사이에 나오는 모든 내용을 주석.
여러 라인 주석 처리하고, 도큐멘테이션을 생성할 때 사용. 
도큐먼트 주석은 별도의 Javadoc.exe 명령어를 통해서 앞에서 
살펴봤던 도큐멘테이션 같은 형태의 문서를 만들수 있다. 6장에서 !!

ex)
// 행 주석 연습1
/*
 *  블록 주석 연습2
 * 
 * 
 */
/**
 * 도큐먼트 주석 연습3
 */
 
----------------------------------------------------
4. 예제 소스 코드 설치 
이 책에서 사용할 예제를 설치.
예제는 Git (깃) 시스템을 통해서 배포된다. 
Git ? 프로그램 소스 코드 관리를 위한 분산 버전 관리 시스템.
!
File -import -Select -> Git 선택. 
Select Repository Source -> Clone URI 선택. 
URI : https://github.com/itsmeyjc/java-kame.git 
입력. 
URI를 파싱(parsing)해서 Host 와 Repository path 항목이 자동완성.
나머지 항목은 비워두고 Next 버튼 클릭. 
Branch Selection 대화상자에서 master 가 체크되어 있는지 확인하고 
Next 버튼을 클릭. 
Local Destination - Directory : 해당 워크스페이스\java-kame 입력. 

Select a wizard to use for importing projects - Wizard and project import
항목에서 : Import existing Eclipse projects 사 선택 된것을 확인하고 next .

마지막으로 Import Projects 대화상자에서 Search for nested projects 체크하기. 
Finish 
!
=======================================
[자바 해바라기 정리] 2 변수와 자료형  
//실습9개
1. 변수 
1.1 변수란?
변하는 수. 수학 시간 미지수 x ,  변수라 부름. 
x에 값의 타입에 상관없이 뭐든지 할당 가능. 
x=3;
프로그래밍에서의 변수는 그릇의 개념에 가까움. 
그릇의 다양한 크기를 갖는다는 점. 
변하는 값을 저장할 수 있는 메모리 공간을 의미.
음식을 그릇에 담기전에 그릇을 준비하는 것처럼 
값을 저장하기 위해서는 미리 변수 즉, 메모리의 공간을
준비해야 한다. 이것을 변수 선언. 
변수의 크기 값의 타입에 따라 결정. 
큰 메모리 공간에 작은 타입을 저장하면 그 만큼 메모리 낭비가 있다. 
그릇과 달리 변수의 공간이 남는다고 해서 하나의 변수에 여러 개의 
값을 저장 할수는 없다. 
변수는 한번에 하나의 값만 .
그릇은 작은 그릇에 음식을 넘치더라도 담지만, 
프로그래밍에서 기본적으로 작은 메모리에 큰 타입의 값을 
저장 할 수 없다.  값에 따른 변수의 타입 선택이 중요. 

(2) 변수의 선언 
변수 타입과 변수 이름으로 구성. 
예) 
byte  age;
변수 타입 : byte
변수명 : age 
JVM은 위 코드를 읽으면서 byte 타입을 인지하고 
이에 적합한 공간을 메모리에 할당.
뒤에 나오지만, byte 타입은 8bit의 메모리 공간이 필요. 
할당된 메모리는 특정 주소값을 갖는다. 
(정확한 주소는 알기 어렵기 때문에 관습적으로 
0x100 번지 형태로 사용한다. )
하지만, 프로그래밍하면서 주소값을 이용하는 것은 
매우 번거롭기 때문에 이 주소를 나타내는 변수명으로 age 이용.
이 age라는 변수명으로 8bit의 메모리 공간에 접근.

변수 선언하면서 위처럼 타입과 이름만 표시 할수 있고,
리터럴(literal)을 이용해 값을 할당 할 수도 있다. 
변수에 값을 할 당 할 때는 '=' 대입연산자 사용. 
double  height  =  180.5;
변수타입  변수명   <----- 리터럴 
                               할당. 
리터럴이란? 변수에 할당되기 전의 순수한 값을 말한다. 

동일한 타입의 변수를 선언할 때는 다음 처럼 한 번만 명시하고 
뒤에 콤마를 이용해 여러 개의 변수를 선언한다. 

ex)
int   number, count;
char  c1 = 'a' , c2 = 'b';

그러나, 타입이 다를 경우는 한 줄에 여러 개의 변수를 함께 선언 불가. 

실습1
예제 코드 

[ch02.variable.Declaration.java]
package ch02.variable;

public class Declaration {
	public static void main(String[] args) {
		byte age; // 단순 선언
		double height = 180.5; // 선언과 동시에 값의 할당
		int number, count; // 동일한 타입의 변수를 한꺼번에 선언
		char c1 = 'a', c2 = 'b'; // 동일한 타입의 변수에 대한 선언과 할당

		// int price, double weight; // 다른 타입은 같이 선언 불가
	}
}

(3) 변수 명명 규칙 
-대/소문자를 구분하며 길이 제한 없음 
-숫자로 시작 할수 없다 
-특수 문자로는 "_"와 "$"만 허용. 
-예약어는 사용 할 수 없다. 

자바 예약어
자료형 
boolean, byte, char, double, float, int , long, short 
논리값 
false, true 
접근 제한자 
private, protected, public
클래스 구성 
abstract, class, enum, extends, implements, import, interface, package
객체 활용 
instnaceof , new , null, this, super 
메서드 작성 
return, void 
제어문 
break, continue, case, default, do, else, for, if, switch, while 
예외처리
catch, finally, throw, throws, try 
기타 
assert, const, final, goto, native, synchronized, static, transient, volatile

ex)
int 3number; // 숫자로 시작할 수 없음. 
int number@; // _ , $ 이외의 특수문자 사용 불가 
int goto; // 예약어 사용 불가
_, $ 기호는 주로 프레임워크나 라이브러리등 특수한 목적으로 사용되므로 
일반 프로그램에서는 사용 안함. 
한글 이용해서 변수 이름 작성 할 수도 있지만, 
실제로 사용하지는 않는다. 

권장 사항.
-가급적 의미 있는 단어를 사용해서 변수의 용도를 파악 쉽게.
-클래스, 인터페이스, 이넘(Enum), 애노테이션의 이름은 대문자로 시작. 
-변수, 메서드의 이름은 소문자로 시작.
-두 개 이상의 단어를 붙여서 사용할 때는 - 케멀-케이스(Camel Case)
표현법 이용 
-ex) lastChange, isPowerOn, 연결되는 단어의 첫 글자를 대문자로 씀.
-상수는 모두 대문자를 사용하고 , 단어의 연결에는 _ 를 사용. 
ex) PI , MAX_AGE 

잘되는 프로젝트는 전체 팀원들이 처음 받아보는 문서에 
프로젝트 명명 규칙에 대한 기준이 포함된다. 

---------------------------------------
2. 자료형(-데이터 타입)

2.1 기본형과 참조형
정보들을 분류 하면 크게 문자, 숫자, 논리, 어떤 것 
4가지로 구분. 
문자 : 'a' , 'b' , '가', '각' 처럼 하나의 글자를 의미 
숫자 : 1,2,3 정수와, 1.5 , 3.14와 같은 실수로 나뉜다
논리 : '예' , '아니오'
어떤 것 : 앞의 3가지로 표현 못하는 것.
예를 들어 사람, 자동차 등 
한글과 같이 두개 이상의 문자로 이뤄진것 
문자열이라고 하며, 문자와 다른 어떤 것에 포함. 

생활에서의 자료형 : 프로그래밍에서의 자료형 : 예시
문자 : char : char firstAlpha = 'A'; , char gender = '남';
숫자 : 정수형 : byte, short, int, long : int age =20; , 
long earthAge = 4540000000L;
숫자 : 실수형 : float, double : float height = 180.5f;
double weight = 80.5;
논리 : boolean : boolean isPowerOn = true;
어떤 것 : 나머지 모두 : Date today = new Date();
Person person = new Person();
String name ="홍길동";

8개의 타입 기본형(Primitive type)
char, byte, short, int, long, float, double, boolean
어떤 것에 해당하는 것 참조형(Reference type)
기본형은 변수에 직접 값을 저장하고,
참조형은 힙(Heap)이라는 메모리 영역에 실제 데이터인 객체를
저장하고, 변수에는 그 객체를 참조할수 있는 참조값만 저장. 

// 기본형 변수의 선언과 할당 
int sum = 10;
// 참조형 변수의 선언과 할당 
Date birthDate = new Date();
기본형인 sum이 직접 10이라는 값을 갖지만, 
참조형인 birthDate는 실제 값인 Date 타입의 객체를 참조 할수 있는 
0x100 이라는 참조값 가지고 있다. 

(2) 기본형의 크기 
논리형 : boolean : 1 byte
문자형 : char : 2 byte
정수형 : byte 1 byte , short 2 byte , int 4 byte , long 8 byte
실수형 : float 4 byte , double 8 byte
컴퓨터는 모든 자료를 0과 1로만 구분한다. 
1byte 8비트 .

정수형인 byte, short, int, long 의 맨 앞의 bit 를 부호 비트(sign bit)라 하고,
양수, 음수 인지 표시. 
byte 부호 비트를 뺀 나머지 7개의 비트에만 값을 기록.
byte : -2^7 ~ 2^7 - 1
short : -2^15 ~ 2^15 - 1
int : -2^31 ~ 2^31 - 1
long : -2^63 ~ 2^63 - 1

- 2^(n-1) ~ 2^(n-1) -1

ex)
byte b = 129; // 범위를 넘어가는 값은 할당 못함. 

실수형인 float, double 역시 정수형 처럼 부호 비트가 있지만,
나머지 비트를 사용하는 방법은 전혀 다르다. 

구분 : 표현범위 : 비트 구성 
float : +-(m)*10^e  :  s | E(8) | M(23)
double : +-(m)*10^e : s | E(11) | M(52)

+- : 부호 표시 
(m) : 가수 
10^e : 지수 
float : 지수 부분 8bit , 가수 부분 23비트
double : 지수 부분 11bit , 가수 부분 52비트
지수함수 생각해보면 표현 할수 있는 값의 범위가
기존의 정수형에 비해 엄청나게 커진다. 

char : 0 ~ 2^16 - 1 : 16비트 

---------------------------------------
2.2 정수형

byte, short, int, long : 기본형은 int 타입. 
System.out.println(10); // 타입 없이 사용한 정수는 int 의미 
정수를 byte 나 int 등 보다 작은 타입의 변수에 할당 할 경우는 
자동으로 해당 타입으로 변경. 묵시적 형변환.
타입의 범위를 넘어가는 값은 할당 못함. 
ex) 
byte b = 10; // byte 에 할당되면서 int가 byte 로 변경됨.
// byte b2 = 128;
// Type mismatch :cannot convert from int to byte 

(1) 정수 리터럴 
진수 : 접두어: 활용예 : 10진수 환산 
10진수(decimal) : 없음: 10: 10^1 *1 + 10^0 * 0 = 10
2진수(binary):0b : 0b11 : 2^1 * 1 + 2^0 * 1 = 3
8진수(octal) : 0 : 016 : 8^1 * 1 + 8^0 * 6 = 14
16진수(hexadecimal) : 0x : 0x10 : 16^1 * 1 + 16^1*0 = 16

ex)0123 = 8^2 *1 + 8^1 * 2 + 8^0 * 3 = 64 + 16 + 3 = 83

음수의 경우, 
먼저 부호를 뺀 나머지 2진수로 바꾼 후
0 -> 1 , 1-> 0 으로 바꾼 : 1의 보수
더하기 1을 해준다. 
프로그램에서는 간단하게 
Integer.toBinaryString(-100)으로 확인 할수 있다. 
!
ex) 
long long1 = 10;
long long2 = 10000000000; //0 : 10개 The literal 10^10 of
type int is out of range 
long long3 = 10000000000L; 
ex)
int largeLiteral = 100_000_000; // 천 단위에 _를 사용해 가독성을 높이다.

실습2
ex)
package ch02.variable;

public class IntegerTest {

	public static void main(String[] args) {
		byte b1 = -128;
		// byte b2 = 128;
		// Type mismatch: cannot convert from int to byte
		System.out.println(b1);
//	byte b1 = (byte)128;
//	int c1 = 128;
//	System.out.println(c1);
//	System.out.println(b1);
//	System.out.println(Integer.toBinaryString(b1));
//	System.out.println(Integer.toBinaryString(c1));
//	System.out.println(String.format
//	("%032d", Integer.parseInt(Integer.toBinaryString(c1).toString())));
//  System.out.printf("%032d%n",e1);
		
		int i1 = 15;
		int i2 = 0b1111;
		int i3 = 017;
		int i4 = 0xf;
		System.out.println(i1 + ", " + i2 + ", " + i3 + ", " + i4);

		int i5 = 1_000_000_000;
		System.out.println(i5);

		// long l1 = 10000000000;
		// The literal 10000000000 of type int is out of
		// range
		long l2 = 1000000000L;
		System.out.println(l2);
	}
}

(2) 적절한 자료형의 선택 
자료형은 메모리 공간 할당과 밀접하게 연관되므로 사용하는 값의 
범위에 적합한 타입을 선택하는 것이 중요하다. 
다리의 개수 지정하는 변수 legCnt 라는 변수를 선언하다고 하자. 
대부분 byte 범위 내에서 처리 가능. 
int 기본형으로 바뀌니 3byte가 아깝다. 
그런, + , - 와 같은 산술 연산을 하게 되면 이야기가 달라진다. 
정수의 기본 연산 단위가 int 이므로 byte 를 다시 int로 변경해서 연산. 
byte + byte 의 연산을 수행해도, 
(byte -> int 변환) + (byte -> int 변환)의 과정을 거쳐 결과로 
int 로 돌려준다. 
메모리 절약하려다가 오히려 CPU에 더 부담을 주게 된다. 
연산이 일어나지 않으면, 각 타입에 맞게 설정하고,
연산이 일어나면, int를 사용하는게 좋다. 
지금은 메모리가 기가바이트이므로.

----------------------------------------------------
2.3 실수형 

기본형은 double이다.
아무 표현 없이 실수를 사용했다면 double 타입의 자료를 사용한다. 
ex) double weight = 90.5;

(1) 실수형의 리터럴 
float 타입 변수에 실수를 할당할 때에는 실수값 뒤에 별도로 f 또는 F를
추가해야 한다. 
또, 지수를 표현 하기 위해 e 를 사용 할수 있다. 
ex) float height = 180.5f;
double income = 3.0e2; // 3.0 * 100 = 300;

float 과 double 의 차이는 값의 표현 범위도 있지만,
정확도에 있다. 
float 는 소수점 이하 9번째 자리에서 반올림해서 8자리까지 표현.
double 는 소수점 이하 18째 자리에서 반올림해서 17자리까지 표현. 
double 이 float 보다 두 배 정도 더 정밀한 값을 표현 할수있다.

실습3
ex)
package ch02.variable;

public class FloatTest {

	public static void main(String[] args) {
		// float f1 = 3.14;
		// Type mismatch: cannot convert from double to float
		float f2 = 3.14f;

		double d1 = 3.14;
		System.out.println(d1);

		double d2 = 3.14e2;
		System.out.println(d2);
		double d3 = 3.14e-2;
		System.out.println(d3);

		// 출력 결과의 유효숫자 비교
		float f3 = 0.1234567890123456789f;
		double d4 = 0.1234567890123456789;
		System.out.println(f3);
		System.out.println(d4);
	}

}
//
3.14
314.0
0.0314
0.12345679
0.12345678901234568


----------------------------------------------------
2.4 문자형
문자형인 char 는 하나의 문자만을 표현하기 위한 자료형.
일반적으로 문자를 표현 할때 아스키코드 또는 유니코드 사용된다. 
컴퓨터는 bit 즉 숫자 0과 1로만 값을 기억하기 때문에 문자형이 필요없다. 
사람은 bit를 바로바로 해석하면서 프로그래밍 하기 어렵다. 
초기에는 문자를 특정 숫자에 매칭시켜서 아스키코드(ASCII code)라는 것을
만들어 문자를 입력. 
즉 0100 0001 (10진수 65) 는 'A'를 나타내고 
즉 0110 0001 (10진수 97) 는 'a'를 나타낸다.
아스키코드의 구성 표 참고하기.

아스키코드는 미국에서 만들어져서 영문자와 숫자, 일부 특수 문자 등이 포함되고
한글을 포함한 다양한 아시아권의 문자를 표현 못함. 
그래서, 모든 언어를 포함할 수 있도록 아스키코드를 확장해서 유니코드(Unicode)
가 개발됨. 유니코드는 아스키코드를 모두 포함하고, 추가적인 문자들이 매핑.
자바는 유니코드를 지원하기 때문에 한글을 사용하는데 지장 없다. 
(1) 문자형 리터럴 
문자형을 표현할 때는 작은 따옴표로 하나의 문자를 표현 하거나,
문자가 매칭된 유니코드 값을 입력한다. 
유니코드를 입력할때 '\u'와 함께 16진수 값을 입력한다. 
ex) char c1 = 'A';
char c2 = '\u0041';
System.out.println(c1 + "," + c2); // A,A 
유니코드를 다 외우고 다니는 사람은 거의 없으므로, 
직접 문자를 할당한다. 

(2)특수 문자 표현 
아스키코드는 영문, 숫자, 기호뿐 아니라 다양한 특수 문자들도 포함한다. 
특수 문자는 '\'와 함께 사용. 
자주 사용되는 특수 문자.
아스키코드의 특수 문자 
의미 : 표시 
tab : \t 
form feed : \f 
carriage return : \r
작은따옴표 : \'
backspace : \b 
new line : \n 
역슬래시 \\
큰따옴표 \"

(3)문자의 연산 
문자는 사실 정수형 숫자이다. 일반적으로 정수처럼 연산 할수있다
예에서
int i = 'A' + 1;
System.out.println( i+ ":" + (char)i); //66:B 
A 는 65에 매칭되어서, 
66 을 뒤에 배울 형변환 연산자 (char) 통해 문자로 바꿔보면 'B' 출력 


실습4
예) 유니코드를 이용한 표현 
package ch02.variable;

public class CharTest {

	public static void main(String[] args) {
		char c1 = 'A';
		char c2 = '\u0041';
		// \t(탭)와 \n(새줄) 삽입
		System.out.println("문자 출력: " + c1 + '\t' + c2 + '\n');

		int i = c1 + 1;
		System.out.println(i);
		System.out.println((char) i);
	}
}
//
문자 출력: A	A

66
B



----------------------------------------------------
2.5 논리형 
true , false 두개의 값만 사용. 
boolean b1 = true;
boolean b2 = false;

ex) 논리형 주로 제어문에서 상태값에 따라 반복 또는 조건문의 실행 흐름을 
결정할 때 사용된다.

실습5
package ch02.variable;

public class BooleanTest {

	public static void main(String[] args) {
		boolean b1 = true;
		if (b1) {
			System.out.println("참입니다.");
		} else {
			System.out.println("거짓입니다.");
		}
	}

}
//
참입니다.


----------------------------------------------------
2.6 문자열
문자열은 기본 자료형이 아니다. 
자바의 문자열은 String 이라는 클래스 타입으로 참조형이다.
아직 클래스 부분을 다루지 않았지만, 문자열은 계속 사용되므로 
먼저 알아보기 

(1)문자열 리터럴 
문자열 표시할 때는 문자와 달리 큰 따옴표(이중 따옴표)로 문자들을 
묶어 준다. 
ex)
String s1 = "String과 char는 다르다"; //String과 char는 다르다.
String s2 = "Hello\t\'Java\'\tWorld";
// Hello	'Java'	World

(2) 문자열의 덧셈 
문자열은 덧셈 연산이 가능한데 , 어떤 타입의 자료든 문자열과 더하면
기존 문자열과 결합하여 문자열로 변한다. 
그래서 문자열에서 + 연산은 결합 연산이라고 한다. 

예)연산 결과를 살펴보자. 
System.out.println("1" + "1"); //11
System.out.println(1 + "1"); /11
System.out.println(1 + 1 + "1"); /21
System.out.println(1 + "1" + 1); //111
System.out.println('1' + '1'); // 98
문자열이 들어간 덧셈은 숫자의 더하기가 아니라 문자열로 결합한 것.
세번째 내용은 + 연산의 경우 앞에서부터 순차적으로 진행되므로 
산술 연산으로 1 + 1 이 먼저 계산되고,
이어서 2 + "1"  을 문자열의 결합으로 연산하는 것이다. 
다섯번째 연산은 문자열이 아니라 문자!! . 
char '1'은 숫자 49에 매칭. 98.

----------------------------------------------------
2.7 형변환 (Type casting)
형변환이란 값의 형을 다른 형으로 변환하는 것을 말한다. 
일반적으로 형변환은 기본형은 기본형끼리, 참조형은 참조형끼리 가능하다. 
여기서 기본형의 형변환을 보고, 참조형 형변환은 7장에서 보자. 
기본형과 참조형 사이의 형변환은 Wrapper 클래스가 사용되는데,11장에서 

(1)형변환 연산자 
소괄호를 사용하고, 소괄호 내부에 변환하려는 자료형을 입력한다. 
예) 100.5를 갖는 double 형 변수 d를 int 형 변수 result에 할당하기
위해 int로 형변환 하는 방법.
double d = 100.5;
int result = (int)d;

d는 실수형이므로 소숫점과 소숫점 이하의 숫자를 포함하고 있다. 
하지만 int는 정수형이므로 소숫점과 소숫점 이하의 숫자를 표현 못함.
이 때 변수 d를 형변환 연산자 (int)를 이용해 int 타입으로 변경하면 
형변환 연산 과정에서 소숫점 이하가 손실되고 변수 result에 할당된 값은 
100이 된다. 

(2) 형변환의 종류 
묵시적 형변환 : 별도의 형변환 연산자를 사용 안해도 자동으로 이뤄짐. 
명시적 형변환 : 반드시 형변환 연산자를 사용 해야 한다. 
차이점 ? 값의 이동 방향에 따른 표현 가능 범위의 변화에 있다. 
작은 곳에서 넓은 곳은 상관없지만, 
넓은 곳에서 작은 곳으로 가면, 버려야 한다. !!
ex)
byte b = 10;
int i1 = (int)b; //형변환 연산자를 써도 되지만 
int i2 = b; //생략해도 상관없다. 

ex)
int i1 = 266;
byte b1 = i1 ; // Type mismatch: cannot convert from int to byte
byte b2 = (byte)i1;

값의 손실이 발생해서 , 변경됨. 
 
만약, i1의 값이 byte에서 표현할 수 있는 작은 값이었다면
형변환은 필요 없을까?
ex) 
int i1 = 10;
byte b1 = i1; // Type mismatch: cannot convert from int to byte
명시적 형변환이 필요한 기준은 값의 크기가 아니라,
값의 타입에 따르는 것이다. 

정수형 long 형과 실수형 float 형 중 어느 집이 더 클까?
long 64bit , float 겨우 32bit 이다. 
float에서 표현 할수있는 값의 범위는 long 과 비교할 수 없을 만큼 크다. 
자료형이 가지는 메모리상의 크기가 아니라 자료형이 표현할 수 있는 값의 범위에
따라 형변환 연산자의 사용 여부가 결정 된다. 
ex) 
long l1 = 100;
float f1 = l1; // 묵시적 형변환 가능 
long l2 = (long)f1; //명시적 형변환 필요 

화살표 방향으로 묵시적 형변환
byte -> short -> int -> long -> float -> double 
char -> int 

char 묵시적 형변환 고려할 점. 부호. 16bit 의 크기 이지만, 
부호가 없어서 양수만 존재. 따라서 음수의 측면에서는 byte 보다 
표현 할수 있는 범위가 작다. byte, short가 비록 bit 수는 
작거나 같지만 char로 묵시적 형변환 안된다. 
ex)
byte b1 = 10;
char c1 = (char)b1; // 8bit --> 16bit 이지만 부호 처리 문제로 
// 명시적 형변환 필요 

(3) 기본형 사이의 형변환 현상 
변수의 타입별로 형변환시 어떤 현상이 일어나는지

-정수형 간의 형변환
명시적 형변환 필요할 때 자릿수가 줄어들어 값의 손실 발생 여부 주의 

-정수형과 실수형 간의 형변환 
가장 큰 차이 소숫점 유무이다. 
정수에서 실수로의 형변환 묵시적 형변환. 소수점이 추가된다. 
반대로 실수에서 정수로 형변환이 될 때는 반드시 명시적으로 진행되며
실수부가 삭제되고 정수부는 자릿수에 맞게 줄어들수있다. 

-실수형 간의 형변환
double에서 float로 명시적 형변환이 이뤄질때는 유효 자릿수에
대한 문제로 값 손실이 발생할 수 있다.
묵시적 형변환 상관없다.

-문자와 숫자의 형변환
타입의 크기와 상관없이 숫자는 문자로 묵시적 형변이 안된다.
반드시 명시적 형변환이 필요.
숫자가 문자로 형변환 되면 실수부는 없어지고 정수부를 
자릿수에 맞게 줄인 후 유니코드에 매칭되는 문자로 표시.
반면, 문자를 숫자로 변환하면 문자가 매칭된 정수가 앞서 설명한 
규칙대로 형변환.
char -> int : 묵시적 형변환 가능. 

-논리형의 형변환 
다른 어떤 기본형과도 형변환 안됨. 

실습6
ex) 
package ch02.casting;

public class TypeCastingTest {
	public static void main(String[] args) {
		int i1 = 1234;
		long l1 = i1;
		byte b1 = (byte) i1;
		System.out.println(i1 + "\t" + l1 + "\t" + b1);

		double d1 = i1;
		byte b2 = (byte) d1;
		System.out.println(d1 + "\t" + b2);

		double d2 = 0.12345678901234567890;
		float f1 = (float) d2;
		System.out.println(d2 + "\t" + f1);

		byte b3 = 67;
		char c1 = (char) b3;
		float f2 = c1;
		System.out.println(c1 + "\t" + f2);

		boolean b = false;
		// int i2 = (int)b;
		// Cannot cast from boolean to int
	}

}
//
1234	1234	-46
1234.0	-46
0.12345678901234568	0.12345679
C	67.0

----------------------------------------------------
3.자료형에 따른 출력과 입력 
프로그램 입장에서 값을 받아들이는 것을 입력.
값을 내보내는 것을 출력.
본격적인 입력과출력은 15장에서 
여기서는 예제 진행을 위해 간단히 콘솔과 키보드를 이용하는 
입력과 출력에 대해서만 알아봄.
자바에서는 입력과출력을 위해서는 스트림(stream)을 사용.
스트림은 데이터가 흐르는 관이라고 볼 수 있다. 

키보드에서 입력한 값을 프로그램으로 가져오는 스트림 , 입력 스트림
입력 스트림 사용하기 위해서는 System.in 을 사용한다.
프로그램에서 콘솔로 출력하기 위해서는 출력 스트림이 사용된다.
System.out 이 사용.

3.1 포맷 문자열을 이용한 문자열과 기본형 출력 

출력 
System 클래스에 선언된 out 타입은 PrintStream 이므로 
println() 메서드는  PrintStream에 선언된 메서드이다. 
PrintStream 클래스에는 출력과 관련된 여러 메서드가 있다.
그 중에 대표적으로
print(), println(), printf() 이다. 

메서드명 : 선언부와 설명 
print() : public void print(Object obj) : obj 를 콘솔에 출력.
println() : public void println(Object x) : x를 콘솔에 출력하고 줄바꿈 한다. 
printf() : public PrintStream printf(String format, Object .. args) : 
지시자로 구성된 format 에 의거해서 args를 콘솔에 출력한다. 
!
print() 메서드 있는 그대로 파라미터 출력하고 
println() 파라미터 출력 후 줄 바꿈 처리.
그러나, 모든 자료를 있는 그대로의 형태로만 출력하거나 문자열과의 결합 형태로
출력하기 때문에 원하는 형태로의 출력이 없다. 
예)
소숫점 두자리까지만 출력 한다거나,
다양한 진법으로 출력이 필요할 수도 있다. 
이런 출력을 형식화된 출력. 
!
System.out.printf( ) 메서드를 사용. 
f 는 format을 의미.
파라미터로는 포맷을 지정하는 문자열인 format 
출력 할 값인 args로 구성. 
format 지시자 
!
지시자 : 설명 
%b : 논리값 (boolean)
%d : 10진수 정수 (decimal integer)
%o : 8진수 (octal) 
%x, %X : 16진수 (hexadecimal)
%f : 10진수 실수 (decimal float)
%e, %E : 지수형태 표현 (exponent)
%c : 문자(character)
%s : 문자열 (String)
%n : 줄 바꿈 (개행문자) 
!
두번째 파라미터 args 앞에 "..." 기호가 있는데 이것은 0개 이상의
파라미터가 올수 있다는 의미. 이런 형태의 변수를 가변 인수(variabl args) 
메서드 호출 할 때에는 format 문자열에 설정된 지시자 개수만큼
파라미터를 넣어서 메서드를 호출해야한다. 
즉 지시자가 파라미터로 대체되는 형태. 

println( ) 에서는  여러 값을 출력하기위해 계속 +  연산을 사용해서 가독성이 떨어지고,
반면, printf( ) 는 format 문자열 기반으로 훨씬 읽기가 편하다. 
!
ex)
boolean b1 = true; 
int i1 = 65;
double d1 = 3.141592;
System.out.println("b1:" + b1 + ",i1 : " + i1 + "(" + (char)i1 + "), d1:" +d1);
System.out.printf("b1: %b, i1: %d(%c), d1: %f%n", b1, i1, i1, d1);
// 두 출력 결과는 같다.
// 출력 결과 : b1: true, i1 :65(A), d1:3.141592
printf( ) 출력 후 개행 문자 ('\n')를 삽입해주지 않기 때문에 줄 바꿈을 위해서는
포맷문자열에 %n을 추가하는 것이 좋다. 
!
자릿수 표현 방법 
형태 : 	설명 :		사용예
%nd : n 자릿수를 확보하고 오른쪽 정렬 : [%4d] , 10 -> [   10]
%-nd : n 자릿수를 확보하고 왼쪽 정렬 : [%-4d], 10 ->   [10   ]
%0nd : n 자릿수를 확보하고 빈 칸은 0으로 채움 : [%04d], 10 ->[0010]
%m.nf : 전체 m 자릿수로, 소숫점 이하 n 자리까지 표현 
: [%5.2f],  10.1234 -> [10.12]
실수를 출력 할 때 %f 는 기본적으로 소수점 7자리에서 
반올림해 6자리까지 표현한다. 
예)
%10.4f 는 전체 10자리 중 소수점 이하 4자리를 의미. 
소수점도 한자리 차지 !! 정수부는 5자리 사용 가능. 
자릿수가 부족 하더라도 정수부는 언제나 출력. 
[%10.4f] , 10.123456789 -> [   10.1235]

실습7
ex)
package ch02.format;

public class Formatting {

	public static void main(String[] args) {
		boolean b1 = true;
		int i1 = 65;
		double d1 = 3.141592;
		System.out.printf("b1: %b, i1: %d(%c), d1: %f%n", b1, i1, i1, d1);
		System.out.println("b1: " + b1 + ", i1: " + i1 + "(" + (char) i1 + "), d1: " + d1);

		// 자릿수 지정
		System.out.printf("[%4d], [%-4d], [%04d]%n", i1, i1, i1);

		// 소숫점 이하 자리 표현
		System.out.printf("[%010.3f], [%10.8f]%n", d1, d1);

	}

}
//
b1: true, i1: 65(A), d1: 3.141592
b1: true, i1: 65(A), d1: 3.141592
[  65], [65  ], [0065]
[000003.142], [3.14159200]


----------------------------------------------------
3.2 포맷 문자열을 이용한 시간과 날짜 출력 

기본형 출력할 때 % 기호를 이용. 
시간을 출력할 때는 %t 사용. 
!
지시자 :  설명 
%tH : 24시간 체제의 시간 (00 ~ 23)
%tI : 12 시간 체제의 시간 (01 ~ 12)
%tM : 분 (00~59)
%tS: 초(00~60)(참고, 60은 윤초를 표시하기 위해 특별히 사용.
%tp : 오전 오후의 표현(오전/오후)
%tT : %tH : %tM : %tS (11:23:10)
%tR : %tH : %tM (11:23)
%tr : %tI : %tM: %tS %tp : (05:33:41 오후 )
!
%tT , %tR, %tr 각각 다른 지시자들을 조합해 놓은 형태로 예약어 개념. 

포맷 문자를 이용한 날짜 출력 
지시자    :			설명 
%tB : 월 (2월, Feburary)
%tb : 월 (2월, Feb)
%tA : 요일(일요일,  Sunday)
%ta : 요일(일,  Sun)
%tY : 년도(2018)
%ty : 년도(18)
%td : 일 (05)
%te : 일 (5)
%tm : 02 (월)

%tD : "%tm/%td/%ty" (02/25/18)   
%tF : "%tY-%tm-%td" (2018-02-25)
%tc  : "%ta %tb %td %tT %tZ %tY " :  (일 2월 25 17:21:31 KST 2018)
!
%t 대신 %T 를 사용할수 있다. 
영어권에서 출력 내용을 대문자로 할 것인지 소문자 인지 결정. 
예)
%tB : Feburary
%TB : FEBURARY 
!
자바에서 시간에 대한 정보는 일반적으로 하나의 객체가 갖는다. 
지시어마다 동일한 객체를 연결하는 형태가 된다. 
이런 경우 '<' 기호의 사용이 아주 유용하다. 
'<' 는 처음 지시어에서 사용된 파라미터를 두 번째 지서어에서 
재사용 가능 
ex)
System.out.printf("%ta %tb %te %n", currentTime, currentTime, currentTime);
System.out.printf("%ta  %<tb  %<te  %n" , currentTime)

실습8
ex)
package ch02.format;

import java.util.Calendar;

public class DateFormatting {

	public static void main(String[] args) {
		Calendar currentTime = Calendar.getInstance();
	    System.out.printf("%tA %<tB  %<te,  %<tY  %n", currentTime);
	    System.out.printf("%tD %n", currentTime);
	    System.out.printf("%tF %n", currentTime);
	    System.out.printf("%tc %n", currentTime);
	    System.out.printf("오늘은 %tF 이고 지금은 %<tR 입니다.%n", currentTime);
	}

}
//
일요일 3월  17,  2019  
03/17/19 
2019-03-17 
일 3월 17 13:17:35 KST 2019 
오늘은 2019-03-17 이고 지금은 13:17 입니다.


이클립스에서 
println : sysout + ctrl + space : 사용가능. 
미리 등록된 템플릿을 활용하는 것.
!
printf 등록 하기 
Window -> Preferences -> Java -> Editor -> Templates 
미리 등록된 템플릿을 볼수 있다. 
다음 처럼 입력 
예) 뉴 선택 
Name : printf 
Description : 포맷화된 출력 
Pattern : System.out.printf("${cursor}");
이제, 
printf 입력하고 , ctrl + space 누르면 된다. 

----------------------------------------------------
3.3 Scaner를 이용한 입력 

키보드에서 입력되는 데이터를 처리하는 방법. 
값을 입력할 때는 Scanner 라는 클래스를 사용한다.
클래스 전이라 이해가 어렵지만, 데이터를 입력 받는 방법.
클래스는 6장에서 

키보드에서 값을 입력 받을 때 가장 쉬운 방법은 Scanner 클래스 이용.
Scanner 를 사용하기 위해서는 소스에서 Scanner 클래스의 위치를
표시 해야한다.  클래스의 위치를 패키지(package - 폴더와 유사한 개념)
Scanner는 java.util 패키지 속에 있다. 다른 패키지의 클래스를 
사용하기 위해서는 import 키워드를 사용해야 한다. 
ex) import java.util.Scanner;

import 가 됐다면 소스 코드에서 Scanner 클래스를 사용 가능.
new 키워드를 이용해서 Scanner 타입의 객체를 생성한 후 사용.
ex) Scanner myScanner = new Scanner(System.in);

myScanner는 변수명이고, Scanner가 타입 .
마치 int i 와 유사한 형태.
myScanner 는 참조형 변수라고 한다. 
new 는 클래스를 통해 객체를 생성하기 위한 키워드.
Scanner 의 파라미터로 사용된 System.in 은 표준 입력 
스트림으로 키보드 의미.
따라서, 키보드에서 데이터를 읽어 들일수 있는 Scanner 타입 객체를 생성하고 
변수 myScanner에 할당하는 내용. 

Scanner 클래스에 선언된 대표적인 메서드

메서드명: 선언부 : 설명 
-next(): public String next()
:Scanner로부터 문자열을 공백 기준으로 한 단어씩 입력받아 리턴한다.
-nextLine(): public String nextLine()
:Scanner로부터 한 줄 전체를 입력 받아서 리턴한다. 
-nextInt() : public int nextInt()
:Scanner로부터 int 값을 받아 리턴한다.
-nextDouble(): public double nextDouble()
:Scanner로부터 double 값을 받아 리턴한다.
-nextBoolean(): public boolean nextBoolean()
:Scanner로부터 boolean 값을 받아 리턴한다. 
-close(): public void close()
Scanner에 연결된 자원(입력 스트림)을 종료한다. 

이외에도 데이터 타입에 따라 다양한 nextXXX 메서드가 포함 되어 있다. 
이들 메서드를 실행하면 사용자가 값을 입력할 때까지 프로그램은 대기하고 
있다가 값이 입력되고 enter 키를 누르면 비로서 
다음 행으로 실행을 이동한다. 
ex)
String line = scanner.nextLine();
먼저, 등호의 오른쪽을 수행하면서 scanner.nextLine() 메서드
를 동작시키고 사용자의 입력을 기다린다. 
사용자가 특정 문자열을 입력시킨 후 enter 키를 누르면 비로서 
사용자가 입력한 문자열이 변수 line에 할당된다. 

실습9
ex)
package ch02.input;

import java.util.Scanner;

public class ScannerTest {

	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		System.out.println("문자열을 입력하세요.");
		String line = scanner.nextLine();
		System.out.printf("입력한 문자열: %s%n", line);
		System.out.println("정수를 입력하세요.");
		int num1 = scanner.nextInt();
		System.out.printf("입력한 정수: %d%n", num1);
		System.out.println("실수를 입력하세요.");
		double num2 = scanner.nextDouble();
		System.out.printf("입력한 실수: %f%n", num2);
		System.out.println("불리언을 입력하세요.");
		boolean bool = scanner.nextBoolean();
		System.out.printf("입력한 불리언: %b%n", bool);
		scanner.close();
	}
}
//
문자열을 입력하세요.
서준아 안녕
입력한 문자열: 서준아 안녕
정수를 입력하세요.
1
입력한 정수: 1
실수를 입력하세요.
1.0
입력한 실수: 1.000000
불리언을 입력하세요.
true
입력한 불리언: true

===================================
[자바 해바라기 정리] 3 연산자
실습13개
1. 연산자란?
일상생활에서 수행하는 +,-,*,/ 등 계산하는 행위를 연산 
(operation)이라 한다. 
연산 구성요소는 연산자(operator), 피연산자(operand),
연산식(expression)으로 구분한다.

프로그래밍에서 사용되는 연산자는 일상에서 흔히 사용
되는 사칙연산, >>, >>> 와 같이 생소한 것들도 있다. 
피연산자는 당하는 요소로 변수나 리터럴이다.
연산식은 연산자와 피연산자를 이용해서 구성한 식을
말한다.  
ex)
int a = 10;
int b = a + 10;
'=' 로 할당 대입연산자 라 한다. 
피연산자는 10으로 변수 a에 할당. 
두번째 두 개의 연산자가 사용된 연산식이다. 
먼저, '+' 가 동작해서 a 와 10을 더해 20이라는 결과를 
만든 후, '=' 로 변수 b에 할당하는 과정을 거친다. 

----------------------------------------------------
2. 결합 방향과 우선순위
연산자는 종류별로 고유의 결합 방향과 우선순위를 갖는다. 

2.1 결합 방향 
연산자 종류  :  결합방향  : 우선순위
높음
(  ) ,  .  : -> :
증감( ++ , --) , 부호 ( + , -), 비트 (~), 논리(!), 형변환(type) : <--
산술 (*, /, %) : -->
산술(+, -) : -->
시프트(<< ,  >> , >>>) : -->
비교( < , > , <= , >=, instnaceof ) : -->
비교 (==, !=)
논리(&) : -->
논리(^) : -->
논리(|) : --> 
논리(&&) : -->
논리(||) : --> 
삼항 ( ? : ) : -->
대입(=, +=,-+,+=,/=,%=,^=,|=, <<=,>>=,>>>= ) : <--
낮음

연산이 진행되는 방향을 의미,
컴퓨터의 연산에서는 연산자별로 결합 방향이 정해져 있다. 
그 방향으로만 연산이 진행 된다. 
'*' 는 결합 방향이 오른쪽(-->)이어서 언제나
3*4 로 연산 .
ex)
x= y = 3 
'=' 결합 방향은 왼쪽 (<--) 이므로 
y에 먼저 3을 할당하고 다시 x에 y를 할당한다. 
다행히, 증감, 부호, 비트, 논리, 형변환 연산자와 
대입연산자의 결합 방향만 왼쪽이고 
나머지는 오른쪽.

----------------------------------------------------
2.2 우선순위
우선순위는 연산이 진행되는 순서. 
연산자들 모두 각 우선순위가 있다. 
ex) 
수식     :    연산 우선순위 설명 
-x + 3 : 1) -x 부호 연산  2) +3 
x + 3 * y  : 1) 3 * y   2) x + 연산 
x  << 2 + 1 :  1) 2 + 1 2)  x << 
x + 3 > y - 2 :  1) x+3  2) y-2  3) > 연산 
x > 3  &&  x < 5  :  1) x>3 2) x<5  3) &&
x < -1 ||  x>3  && x<5 :  1) x < -1  2) x>3 3) x<5 4) && 5)||
z = x + y * 3  : 1) y*3  2) x+  3) z =
소괄호 우선순위가 가장 높음.

소괄호 사용해서 가독성 높이기 쉽게 코드 분석 할수 있게.
(x + 3) > (y - 2) :  1) x+3  2) y-2  3) > 연산 
(x > 3)  &&  (x < 5)  :  1) x>3 2) x<5  3) &&
(x < -1) ||  (x>3)  && (x<5) :  1) x < -1  2) x>3 3) x<5 4) && 5)||


----------------------------------------------------
3. 연산자의 종류

3.1 산술 연산자
+, -, *, /, % (% : 모듈러스 : Modulus)
결합 방향 --> 
+ , - , * , / 
% : 두 피연산자의 나눗셈에 대한 나머지 
산술연산자는 boolean을 제외한 모든 기본형에서 사용. 
ex)
System.out.println( 10 /3 ); // 3 
System.out.println( 10 % 3 ); // 1

(1)산술 연산 시 형변환 
산술 연산하기 전에 피연산자의 형(타입)을 먼저 일치시키고
연산한다. 
원칙
1. 피연산자의 크기가 4byte 미만, 즉 int 미만인 경우 모두 int로 
자동 형변환 후 연산 진행. 
ex)
byte + byte = (int)byte + (int) byte = int 
ex2)
byte b1 = 10;
byte b2 = 20;
// byte b3 = b1 + b2;
// Type mismatch : cannot convert from int to byte

2. int 이상의 타입이 피연산자로 있을 때 
두 개의 피연산자 중 큰 타입으로 묵시적 형변환이
되고 후 연산이 진행.
ex) int + long = (long) int + long = long 
ex2)
int i1 =100;
long l1 = 200;
// int i2 = i1 + l1 ;
// Type mismatch : cannot convert from int to byte

실습1

package ch03.arithmetic;

public class ArithmeticOperatorTest {

	public static void main(String[] args) {
		// 나누기와 나머지 연산의 차이
		System.out.println(10 / 3); // 3
		System.out.println(10 % 3); // 1

		// 연산시의 형변 환 int 이하의 피연산자 끼리의 연산은 최소 단위가 int
		byte b1 = 10;
		byte b2 = 20;
		// byte b3 = b1 + b1;
		// Type mismatch: cannot convert from int to byte

		// 연산시의 형 변환 - int 이상의 피 연산자 타입으로 형 변환
		int i1 = 100;
		long l1 = 200;
		// int i2 = i1 + l1;
		// Type mismatch: cannot convert from long to int

		System.out.println(10 / 3);
		System.out.println(10 / 3.0);

	}

}
//결과
3
1
3
3.3333333333333335


(2) 변수의 연산과 리터럴 연산의 차이 
int 이하의 리터럴 간의 연산은 별도의 형변환이 일어나지 
않는다. 
리터럴 간의 연산은 컴파일러가 컴파일하기 전에 리터럴 간의
연산을 수행한 이후에 할당한다. 
컴파일 결과가 이미 계산이 끝난 상황이므로 형변환이 
발생하지 않는다. 
연산 결과가 할당받는 변수의 범위를 벗어날 경우는 오류가 발생. 
ex)
byte b3 =10 + 10  // byte  b3 = 20 과 같다. 
System.out.println(b3);
// byte b4 = 100 + 28 ; // Type mismatch : cannot convert from int to byte

(3)정수 연산의 문제점 - 오버플로우( overflow)

자료형의 범위에 따른 오버플로우를 조심. 
int 의 최댓값에 + 1를 더하면 
표현할 수 없는 값이기 때문에 에러 발생이 기대.
실제 연산 해보면, 에러 대신 전혀 몰랐던 
쓰레기 값 표현. 

정수들은 최댓값과 최솟값이 띠처럼 맞닿아 있는 구조.
최대값에 1을 더하면 최솟값이 된다. 
이런 연산 결과를 오버플로우라 한다. 
계수기의 동작을 생각.
-2147483647
-2147483648  // 최솟값 
2147483647  //최댓값 +1   위에 결과.
2147483646
2147483645

2진수 연산을 통해서 확인 
ex) 
 부호 비트 제외하고 31 비트 모두 1
01111111 11111111 11111111 11111111 
+ 1
-------------------------------------------------
10000000 00000000 00000000 00000000

다시, 10진수로 변경 할려면, 
1의 보수를 구하고
01111111 11111111 11111111 11111111 = Integer.MAX_VALUE)
결과에 1을 더한 후 부호를 추가.
-(Integer.MAX_VALUE +1 )
오버플로우 발생. 
에러 상황은 아니다. 결과는 엉뚱해도 프로그램은 잘 돌아감. 
그러나, 쓰레기값이 할당된 상황에서 프로그램이
제대로 동작하기는 어렵다.

실습2
ex)
package ch03.arithmetic;

public class IntegerProblem {

	public static int addNormal(int base, int addThis) {
		return base + addThis;
	}

	public static int addSafety(int base, int addThis) {
		if ((Integer.MAX_VALUE - addThis) > base) {
			return base + addThis;
		} else {
			throw new ArithmeticException("오버플로우 발생");
		}
	}

	public static void main(String[] args) {
		int result = addNormal(Integer.MAX_VALUE, 1);
		System.out.println("일반 덧셈 결과: " + result);

		try {
			result = addSafety(100, 100);
			System.out.println("안전한 덧셈 결과 1: " + result);

			result = addSafety(Integer.MAX_VALUE, 100);
			System.out.println("안전한 덧셈 결과 2: " + result);

		} catch (ArithmeticException e) {
			System.out.println(e.getMessage());
		}
	}

}
//출력 결과 
일반 덧셈 결과: -2147483648
안전한 덧셈 결과 1: 200
오버플로우 발생

더 큰 자료형인 long 타입을 사용하는 것도 좋은 대안. 
그러나, 형변환에 대한 고민 없이 long 타입을 무턱대고 사용한다고
문제가 해결되지 않는다. 
!!오버플로우는 연산하는 과정에서 발생하기 때문에 연산하기 전에 
미리 더 큰 데이터 타입을 준비한 후 연산 해야 한다. !!

실습3
ex2)
package ch03.arithmetic;

public class OverFlowAndCasting {

	public static void main(String[] args) {

		int i1 = Integer.MAX_VALUE;
		int i2 = i1 + 1;
		System.out.println("정수 overflow : " + i2);

		long l1 = i1 + 1;
		System.out.printf("long 타입에 할당: %d%n", l1);

		long l2 = (long) (i1 + 1);
		System.out.printf("캐스팅 된 값 : %d%n", l2);

		long l3 = (long) i1 + 1;
		System.out.printf("형변환 적용 연산 : %d%n", l3);

		int i3 = 1000000 * 1000000 / 100000;
		int i4 = 1000000 / 100000 * 100000;
		System.out.printf("i3 : %d, i4: %d%n", i3, i4);

	}

}
//결과물
정수 overflow : -2147483648
long 타입에 할당: -2147483648
캐스팅 된 값 : -2147483648
형변환 적용 연산 : 2147483648
i3 : -7273, i4: 1000000

(4) 실수형의 문제점은 정확도 
실수형에서의 문제점은 값이 정확하지 않다는 점. 
1 < x < 3 사이에 몇개의 실수가 있는지 알수 없다. 
사용하는 실수형은 근사값을 기초로 계산한다. 
ex) 
2.0 - 1.1 = 0.9 
그러나, 컴퓨터는 그렇게 생각 못한다. 
float 타입의 f1과 f2의 뺄셈 연산 결과를 f3에 저장. 
double 타입의 d1과 d2의 뺄셈 연산 결과는  d3에 저장. 
2개를 비교. 
ex) 
float f1 = 2.0f;
float f2 = 1.1f;
float f3 = f1 - f2;
double d1 = 2.0;
double d2 = 1.1;
double d3 = d1 - d.2;
System.out.println ( "결과 비교 " + (f3 == d3) + ", f3: " + f3 + ", d3: " + d3);
//결과 비교 : false , 
f3 : 0.9 ,
d3 : 0.8999999999999999
float의 연산결과가 더 정확하다는 이야기가 아니다. 
실수형은 연산의 결과가 부정확하다는 이야기이다. 

정확한 연산을 위한 방법?
쉬운 방법 
실수 -> 정수로 변경해서 처리.
d1 과 d2 를 각각 10을 곱하고, 정수로 만들고, 차를 구하고 
10으로 나눈다. 
ex) 
int i1 = (int)(d1 * 10);
int i2 = (int)(d2 * 10);
double result = (i1 - i2 ) / 10.0 ;
System.out.println(" 변환 후 처리 : "  + result ); // 0.9

좀더 세련된 방법으로 BigDecimal 과 같은 미리 제공된 API이용.
ex) 
BigDecimal bd1 = new BigDecimal("2.0");
BigDecimal bd2 = new BigDecimal("1.1");
System.out.println(bd1.subtract(bd2));

(5) Infinity  와 NaN 
/ , % 연산을 하다 보면 주의점
오른쪽의 피연산자가 0이 되는 경우이다. 
이 경우 정수를 0으로 나눌 때, 실수를 0으로 나눌 때 다르다. 

먼저, 정수 이용한 연산. 
ArithmeticException 이라는 예외 발생. 
ex)
int i = 1 / 0; // ArithmeticException 발생 
int j = 1 % 0 ;  // ArithmeticException 발생 
프로그램으로 이런 경우 try ~ catch 라는 예외 처리 구문을 이용해서 
명확히 오류에 대한 대처 구문을 작성 할수 있다. 
자세한 예외 처리는 9장에서 학습 함. 

try {
int i = 1 / 0 ;
// ArithmeticException 발생 
} catch ( ArithmeticException e ) {
System.out.println(" 예외 처리 완료 : 0으로 나눌 수 없습니다. ");
}

그러나 , 실수를 이용한 연산에는 다른 결과가 나온다. 
double d1 = 1 / 0.0 ; //Infinity
double d2 = 1 % 0.0 ; // NaN

실수형에서 0으로 나누면 Infinity( 무한대)가 나오고, 
나머지는 NaN (Not a Number - 숫자가 아님) 나온다. 
Infinity나 NaN 다른 어떤 것과 연산해도 Infinity 나 Nan 값이 나옴. 
ex)
double d3 = d1 + 100 ;  // Infinity
double d4 = d2 + 100 ;  // NaN
중요한 점은 이런 연산 결과 오류가 아니라는 것.
따라서, Infinity 나 NaN 결과를 가지고 계속 연산을 진행 하면 안된다. 

이런 상황을 대비해서 
Double 클래스가 제공하는 isInfinite  와 isNaN 메서드를 이용해 
값의 상태를 확인 하는 방법 제공. 
사용 가능한 double  인지 판단하는 Double의 메서드 

메서드 명  :  선언부와 설명 
isInfinite() : public static boolean isInfinite(double v)
v가 무한대의 값인지 리턴한다
isFinite() : public static boolean isFinite(double d)
d가 계산 가능한 유한의 값인지 리턴한다. 
isNaN() : public static boolean isNaN(double v)
v가 숫자가 아닌지 여부를 리턴한다. 
!

실습4
ex)
package ch03.arithmetic;

public class InfinityNaN {

	public static void main(String[] args) {
		try {
			int i = 1 / 0;
			// ArithmeticException 발생
			// int j = 1 % 0;
			// ArithmeticException 발생
		} catch (ArithmeticException e) {
			System.out.println(e.getMessage());
		}

		double d1 = 1 / 0.0;
		double d2 = 1 % 0.0;
		System.out.printf("d1 : %f, d2: %f%n", d1, d2);

		canUse(d1);
		canUse(d2);
	}

	public static void canUse(double d) {
		if (Double.isInfinite(d) || Double.isNaN(d)) {
			System.out.println("사용 할 수 없는 값입니다.");
		} else {
			System.out.printf("d : %f%n", d);
		}
	}
}
//결과물 
/ by zero
d1 : Infinity, d2: NaN
사용 할 수 없는 값입니다.
사용 할 수 없는 값입니다.

----------------------------------------------------
3.2 대입 연산자 

단순대입연산자 , 복합대입연산자 로 구분.

연산자 :  연산자 기능 : 결합방향 모두 <--
= : = 우측의 피연산자 값을 좌측의 변수에 할당 (예 : a=b)
+= : 두 피연산자의 합을 앞의 피연산자에 할당 
(예 : a = a + b ->  a += b) 
ex)
int i = 10;
i += 1; // i = i + 1 ; 와 같은 내용 

복합대입연산자 는 다양한 연산자와 결합할 수 있다. 
산술연산자 결합 ( -=, *=, /=, %=),
논리연산자 결합 (&= , |= , ^=)
시프트연산자 결합 ( <<= , >>= , >>>=)이 가능하며 
동작은 모두 +=  와 동일 하다. 

실습5
ex)
package ch03.assign;

public class AssignOperator {

	public static void main(String[] args) {
		int i1 = 10;
		i1 += 20; // i1 = i1 + 20;
		System.out.println(i1);
		i1 -= 10; // i1 = i1 - 10;
		System.out.println(i1);
		i1 *= 10; // i1 = i1 * 10;
		System.out.println(i1);
		i1 /= 10; // i1 = i1 / 10;
		System.out.println(i1);
		i1 %= 2; // i1 = i1 % 2;
		System.out.println(i1);
	}

}
//결과물 
30
20
200
20
0
----------------------------------------------------
3.3 비교 연산자
두 피연산자의 대소나 동등 여부를 비교해서 true 또는 false 값을 리턴. 

연산자 : 연산자 기능 : 결합 방향(--->)
< : 앞의피연산자가뒤의피연산자보다 작은가? a<b 
> : 앞의피연산자가뒤의피연산자보다 큰가? a>b 
<= : 앞의피연산자가뒤의피연산자보다 작거나 같은가? a<=b
>= : 앞의피연산자가뒤의피연산자보다 크거나 같은가? a>=b
== : 앞의피연산자가뒤의피연산자 와 같은가 ? a == b 
!= : 앞의피연산자가뒤의피연산자 와 다른가 ? a != b 
!
주로 if  제어문이나 반복문에서 실행 흐름 제어에 사용된다. 
재미있는 점. 비교하는 데이터의타입에 따라 동작 방식이 약간다르다.
!
char 는 비교연산자로 비교할때 일단 유니코드로 변경후 비교한다.
System.out.println('A' > 'B'); // false
System.out.println('A' == '65'); // true

위의 첫 번째에서는 'A'는 65, 'B'는 66에 매핑되는 문자. false
두번째 'A'가 65이므로 true .

산술연산자에 형변환에 대한 규칙도 그대로 적용.
int 이하의 자료들을 비교할 때 먼저 int로 자료형을 맞추거나,
두 개의 피연산자중 큰 데이터 타입으로 형변환 실행. 
ex)
System.out.println( 3 == 3.0) ; // true
3 과 3.0의 동등 비교에서 3.0 이 double로 큰 타입이므로 
앞의 int 인 3을 double의 3.0으로 변환 후 연산한다. 

실수 연산의 부정확이라는 문제도 여전히  존재 
ex)
System.out.println(0.1 + ":" + 0.1f + ":" + (0.1 == 0.1f)); 
// 0.1:0.1:false
double 타입 0.1 과 float 타입 0.1f 를 출력 했을 때 모두 0.1
을 나타낸다. 하지만, 두 수를 동등 비교연산자로 같은지 
확인하면 다르다고 나옴.
이유, float 타입의 0.1 이 double로 변환되는 과정에서 근사값으로
표현돼서 
0.10000000149011612로 평가 되므로,
그래서, 실수를 비교할때는 정수로 변경해서 비교하기.
또는 double를 float로 형변환해서 연산할 수 도 있다. 
ex)
double d1 = 0.1;
float f1 = 0.1f;
System.out.println((int) (d1 * 10) == (int) (f1 * 10));
System.out.println((float) d1 == f1);

실수를 이용한 연산은 가급적 안하기. 

비교연산자 중 부등호가 들어가는 대소 비교연산자(<,>, <=, >=)
는 boolean 타입을 제외한 기본형에만 사용.
boolean 타입이나 참조형 데이터 타입은 비교연산자 중 
== 과 != 만 사용 할수 있다. 

참조형에서 ==과 !=의 사용시 주의.
참조형변수에서 사용되는 == 연산은 내용을 비교하는게 아니다. 
두 개의 참조형 변수가 정확히 같은 객체를 참조하는지 비교.
객체의 내용을 비교하기 위해서는 equals 메서드를 재정의
(override)해서 사용. 이 내용은 7장에서 다룬다. 

실습6
ex)
package ch03.compare;

public class CompareOperator {

	public static void main(String[] args) {
		System.out.println('A' > 'B'); // 65 > 66
		// 비교 연산에서의 형 변환
		System.out.println('A' == 65); // int 이하의 연산 - 일단 int로 변경:65 == 100
		System.out.println(3 == 3.0); // 두 피 연산자 중 큰 타입으로 형 변환: 3.0 ==3.0

		// 주의 사항: 0.1의 표현 문제
		System.out.println(0.1 + " : " + 0.1f + " : " + (0.1 == 0.1f));
		System.out.println(0.5 + " : " + 0.5f + " : " + (0.5 == 0.5f));
		double d1 = 0.1;
		float f1 = 0.1f;
		System.out.println((int) (d1 * 10) == (int) (f1 * 10));
		System.out.println((float) d1 == f1);

		// 문자열에서의 == 과 equals
		String s1 = new String("Hello");
		String s2 = new String("Hello");
		System.out.println((s1 == s2) + " : " + s1.equals(s2));
	}

}
//결과물
false
true
true
0.1 : 0.1 : false
0.5 : 0.5 : true
//0.5 = 2^-1, hence can be represented exactly in binary. 0.1 is not
System.out.println(0.5 + " : " + 0.5f + " : " + (0.5 == 0.5f));
System.out.println(0.25 + " : " + 0.25f + " : " + (0.25 == 0.25f));
true
true
false : true


----------------------------------------------------
3.4 논리 연산자

boolean 타입만 사용할 수 있는 연산자로 연산의 결과도 
true 또는 false 만 리턴.
논리곱(&) , 논리합(|), 부정(!), 배타적 논리합(^)으로 구성 
연산자 : 연산자기능 : 결합방향 (-->)
& : AND 연산자로 두 개의 피연산자가 모두 true 인 경우만 true 
| : OR 연산자로 두 개의 피연산자 중 하나라도 true이면 true
! : NOT 연산자로 단항 연산자이며 피연산자의 값을 반대로 바꿈.
^ : XOR 연산자로 두 피연산자가 서로 다르면 true, 같으면 false

실습7
ex)
package ch03.logical;

public class LogicalOperator {
	public static void main(String[] args) {
		boolean b1 = true;
		boolean b2 = false;
		boolean b3 = false;

		System.out.printf("b1 & b2 : %b%n", b1 & b2); // false
		System.out.printf("b1 | b2 : %b%n", b1 | b2); // true
		System.out.printf("b1 ^ b2 : %b%n", b1 ^ b2); // true
		System.out.printf("b2 ^ b3 : %b%n", b2 ^ b3); // false
		System.out.printf("!b1 : %b%n", !b1); // false

	}
}
//
b1 & b2 : false
b1 | b2 : true
b1 ^ b2 : true
b2 ^ b3 : false
!b1 : false

&&, || 재미있게 사용하는 형태 
숏 서킷(short circuit)연산자라고 함.
사실 연산자의 연산결과는 각각 &와 | 연산자의 연산결과가 동일.
그러나, 결과값을 도출하는 과정에서 큰 차이가 있다. 

& 연산의 경우 하나만 false 가 되어도 결과는 false이다. 
따라서 연산표 두번째 줄의 연산은 처음 피연산자가 false 임을
확인하는 순간 false가 결정되기 때문에 굳이 두 번째 피연산자를
확인할 필요가 없다. && 연산자는 이런 상황에서 두 번째 피연산자의
값을 확인하지 않는다. 
|| 연산도 마찬가지. | 연산의 경우 하나만 true여도 결과는 true.
따라서 오른쪽 표에서 첫번째 줄의 연산을 보면 처음 피연산자가 true
이기 때문에 굳이 두번째 피연산자를 확인할 필요가 없다. 
|| 연산자는 이런 상황에서 두 번째 피연산자의 값을 확인하지않는다.

연산자 : 연산자기능 : 결합방향 (-->)
&& : AND 연산자로 두개의 피연산자가 모두 true 인 경우만 true 
단 앞의 피연산자가 false일 경우 뒤의 피연산자를 검사 생략 
|| : OR 연산자로 두개의 피연산자 중 하나라도 true이면 true
단 앞의 피연산자가 true 일 경우 뒤의 피연산자를 검사생략 

숏 서킷 연산자는 불필요한 연산을 줄여서 프로그램 성능을 좋게 하므로 
복합 비교시 주로 사용된다. 
그러나, 두번째 피연산자에 연산식이 들어온다면 혼란이 올수도있다. 

실습8
ex)
package ch03.logical;

public class ShortCircuit {
	public static void main(String[] args) {
		int a = 10;
		int b = 20;
		System.out.println((a += 10) > 15 | (b -= 10) > 15);
		System.out.println("a = " + a + ", b = " + b);

		a = 10;
		b = 20;
		System.out.println((a += 10) > 15 || (b -= 10) > 15);
		System.out.println("a = " + a + ", b = " + b);

	}
}
//
true
a = 20, b = 10
true
a = 20, b = 20

결론, 논리값을 비교할 때 &나 | 보다는 성능을 위해 숏서킷 연산자인 
&& 나 || 사용. 
그러나, 과정에 연산을 끼워 넣으면 경우에 따라 실행 되지 않을 수 있으니
주의.


----------------------------------------------------
3.5 증감 연산자

++과 --로 각각 1씩 증가시키거나 감소시키는 단항연산자.
연산자 : 연산자기능 : 결합방향 ( -->)
++ : 단항연산자로 피연산자의 값을 1 증가시킴 
-- : 단항연산자로 피연산자의 값을 1 감소시킴 
반복문에서 조건값을 1씩 증가시키거나 감소시키는 목적으로 자주 사용.
ex)
for(int i = 0; i < 10; i++){
// do something..
}

(1)증감연산자의 위치 
전위연산자로 사용될 경우, 후위연산자로 사용될 경우 동작이 다르니 주의 

전위연산자는 ++a ,--a 와 같이 증감연산자가 피연산자 앞에 사용되는 경우
먼저, 변수의 값을 증감해서 메모리에 있는 값을 변경시킨 후 다음 동작 
(출력,대입등)을 진행한다. 

후위연산자는 a++, a-- 와 같이  증감연산자가 피연산자 뒤에 사용되는 경우
먼저, 출력, 대입 등을 처리한 후에 변수의 값을 증감시킨다.

따라서, 변수가 사용되는 시점에 따라 값이 다르게 할당되므로 주의.

실습9
ex)
package ch03.monadic;

public class MonadicOperation {
	public static void main(String[] args) {
		int i = 5;
		i++;
		System.out.println(i);
		++i;
		System.out.println(i);

		int j = ++i;
		System.out.println(j++);
		System.out.println(--j);

	}
}
//
6
7
8
8

(2)증감연산자의 형변환 
산술연산자 부분에서 정수형 연산의 최소 단위는 int 이며 이때 
묵시적형변환이 발생한다 했다.
그러나, 증감연산자가의 경우 타입에 대한 변화가 발생하지 않는다.
이런 현상은 복합대입연산자를 사용할 때도 마찬가지.

예를 통해 1을 증가시키는 3가지 방법과 형변환에 대해 알아보자.

실습10
ex)
package ch03.monadic;

public class MonadicCasting {
	public static void main(String[] args) {
		byte b1 = 10;
		b1 += 1;
		System.out.println(b1);

		byte b2 = ++b1;
		System.out.println(b2);

		byte b3 = (byte) (b2 + 1); //b2의 값이 연산 과정에서 int로 자동형변환 발생.
		//다시 byte로 명시적 형변환 필요.
		System.out.println(b3);
	}
}
//
11
12
13

----------------------------------------------------
3.6 삼항 연산자

연산을 수행할때 연산에 참여하는 항목이 3개인 연산자를 말하며 
조건부 연산자라고 불린다.
연산자 : 연산자기능 : 결합방향(-->)
?:  : 처음 피연산자의 값이 true이면 두번째 피연산자를 
false이면 세번째 피연산자를 수행해서 결과를 리턴한다. 

ex)
평가식 ? <표현식1> : <표현식2>;
평가식은 true와 false를 리턴하는 식 또는 값이 올수있다.

ex)
String result = 10 % 2 == 0 ? "짝수" : "홀수";
System.out.println(result);

삼항연산자는 4장에서 배울 if문에서 판단해야 할조건이 간단할때 사용하면
코드를 간결하게 줄일수있다. 
if 문으로 병경하면 

ex)
String result = null;
if(10%2 ==0){
result = "짝수";
}else{
result = "홀수";
}
System.out.println(result);


----------------------------------------------------
3.7 비트연산자

2진수 형태로 연산을 진행.
2진수로 표현할수있는 정수만이 피연산자가 될수있다.
논리 비트연산자 (&, |, ^, ~) 와 이동 비트연산자
(<< , >> , >>>) 로 구성된다. 

(1)논리 비트연산자
논리연산자와 유사. ! 연산자만 ~ 로 대체.
연산자 : 연산자기능 : 결합방향 (-->)
& : AND 연산자로 두개의 피연산자가 모두 1인 경우만 1
| : OR 연산자로 두개의 피연산자 중 하나라도 1이면 1 
~ : NOT 연산자로 단항연산자이며 피연산자의 값을 반대로 바꿈 : <--
^ : XOR 연산자로 두 피연산자가 서로 다르면 1, 같으면 0

Integer 클래스가 제공하는 toBinaryString() 메서드
사용하면 정수를 2진수 형태의 문자열로 리턴한다

실습11
ex)
package ch03.bit;

public class BitLogical {

	public static void main(String[] args) {
		int i1 = 3;
		System.out.printf("%32s%n", Integer.toBinaryString(i1));
		// %32s 는 포맷 문자에서 총 길이를 32자로 출력한다는 의미.
		int i2 = 5;
		System.out.printf("%32s%n", Integer.toBinaryString(i2));

		System.out.printf("%32s%n", Integer.toBinaryString(i1 & i2)); // 1
		System.out.printf("%32s%n", Integer.toBinaryString(i1 | i2)); // 7
		System.out.printf("%32s%n", Integer.toBinaryString(i1 ^ i2)); // 6
		System.out.printf("%32s%n", Integer.toBinaryString(~i1)); // -4
	}

}
//
                              11
                             101
                               1
                             111
                             110
11111111111111111111111111111100

비트 논리 연산은 주로 비트 마스크라는 기법으로 많이 사용된다. 
만약, true/false 형태로 된 많은 자료를 관리한다고 가정. 
그에 맞는 변수의 개수의 변수를 선언해서 사용.
그러나, 2진수는 이미 true/false로 생각할 수 있는 
1과 0으로 구성된 32개의 값을 가지고 있는 숫자.
1 true , 0 false로 매칭해서 사용 해보면 어떨까?

집에 있는 가전제품 32개의 on/off 여부를 관리해야 한다고 생각.
기본값이 모두 off 상태라면,
int homeElecStatus = 0;

homeElecStatus 00000000 00000000 00000000 00000000

이제 각각의 비트에 특정 전자제품 상태를 연결 가능. 
맨뒤(오른쪽 끝)의 bit 를 TV의 on/off 상태라고 생각하면 
현재 TV는 꺼져 있는 상태이다. 
이제 TV가 켜져 있는지 연산을 통해서 알아보자. 
& 연산은 둘다 1일 때만 1인 특성을 이용해보자. 
ex)
int tvCheck = 0b1;
String result ="";
result = (homeElecStatus & tvCheck) > 0 ? "켜짐" : "꺼짐";
System.out.println("tv 상태 : " + result);
결론, TV는 꺼져 있다. 
&
homeElecStatus 00000000 00000000 00000000 00000000
tvCheck        00000000 00000000 00000000 00000001

이제 TV를 켜보자. 
이때는 | 연산은 둘중 하나만 1이어도 1인 특징을 이용. 
ex)
homeElecStatus |= tvCheck;
result = (homeElecStatus & tvCheck) > 0 ? "켜짐" : "꺼짐";
System.out.println("tv 상태(켜기) : " + result);
|
homeElecStatus 00000000 00000000 00000000 00000000
tvCheck        00000000 00000000 00000000 00000001
TV가 켜져있거나 꺼져 있거나 언제나 homeElecStatus의 마지막 bit
1이 될것이다. 

제품의 on/off 상태를 반전시키려면 ^연산자를 이용.
ex)
homeElecStatus ^= tvCheck;
result = (homeElecStatus & tvCheck) > 0 ? "켜짐" : "꺼짐";
System.out.println("tv 상태(반전) : " + result);
^
homeElecStatus 00000000 00000000 00000000 00000001
tvCheck        00000000 00000000 00000000 00000001
예는 현재 TV가 켜져 있는데, tvCheck와 ^연산을 진행하면 
둘 다 1이므로 결과는 0이 돼서 TV가 꺼진 상태가 된다. 

TV를 꺼보자. tvCheck 변수의 보수를 구한 후 & 연산 수행.
결과는 0이 되어 TV는 꺼지게 된다. 
&
homeElecStatus 00000000 00000000 00000000 00000001
tvCheck        11111111 11111111 11111111 11111110
ex)
homeElecStatus &= ~tvCheck;
result = (homeElecStatus & tvCheck) > 0 ? "켜짐" : "꺼짐";
System.out.println("tv 상태(끄기) : " + result);

이런 연산은 낯설다. 그러나, 컴퓨터에서 가장 빠른 연산은 2진수 연산이다. 
따라서, 임베디드 환경처럼 메모리가 작거나 많은 옵션의 적용이 필요한 안드로이드
개발 분야 등에서는 자주 사용된다. 

실습12
ex)
package ch03.bit;

public class BitMask {

	public static void main(String[] args) {
		int homeElecStatus = 0;
		int tvCheck = 0b1;
		String result = "";
		result = (homeElecStatus & tvCheck) > 0 ? "켜짐" : "꺼짐";
		System.out.println("tv 상태 : " + result);

		// tv 켜기
		homeElecStatus |= tvCheck;
		result = (homeElecStatus & tvCheck) > 0 ? "켜짐" : "꺼짐";
		System.out.println("tv 상태(켜기) : " + result);

		// tv 상태 반전
		homeElecStatus ^= tvCheck;
		result = (homeElecStatus & tvCheck) > 0 ? "켜짐" : "꺼짐";
		System.out.println("tv 상태(반전) : " + result);

		// tv 끄기
		homeElecStatus &= ~tvCheck;
		result = (homeElecStatus & tvCheck) > 0 ? "켜짐" : "꺼짐";
		System.out.println("tv 상태(끄기) : " + result);
	}
}
//
tv 상태 : 꺼짐
tv 상태(켜기) : 켜짐
tv 상태(반전) : 꺼짐
tv 상태(끄기) : 꺼짐

(3)이동 비트연산자
정수 데이터의 비트를 왼쪽 또는 오른쪽으로 이동시키는 연산을 말하며
시프트(Shift)연산이라는 표현을 더 자주 사용한다. 
방향에 따라 우측으로 이동할 때는 라이트(right)시프트 연산,
왼쪽으로 이동할 때는 레프트(left) 시프트 연산.
연산자 : 연산자기능 : 결합방향(-->)
<< : 왼쪽 피연산자의 각비트를 왼쪽으로 오른쪽 피연산자만큼 
이동시키고 빈자리는 0으로 채움 
>> : 왼쪽 피연산자의 각비트를 오른쪽으로 오른쪽 피연산자만큼 
이동시키고 빈자리는 부호 비트로 채움 
>>> : >>와 이동은 동일하나, 빈자리를 0으로 채움.

실생활에서 자주 사용되는 연산자가 아니기 때문에 쉽게 
어떤 역할을 하는지 감이 오지 않는다. 결과를 보자. 
ex)
int a = 0b1010; //십진수 10
a를 왼쪽으로 1만큼 레프트 시프트 연산을 수행하고 값 확인.
이동 후 오른쪽 빈자리는 0으로 채움 
ex)
int b = a<<1; //10100 십진수 20 

결과는 자리수가 한 자리 앞으로 진행되면서 2가 곱해진다.
레프트 시프트 연산 효과는 *2

이번에는 a를 왼쪽으로 2비트 만큼 레프트 시프트 연산. 
ex)
int c = a<<2; //101000 십진수 40 
레프트 시프트 연산 효과는 2*2

이제 a를 오른쪽으로 1만큼 라이트 시프트 연산을 해보자.
이때는 앞자리(왼쪽 비트 위치)가 하나씩 값이 비게 된다. 
부호 비트를 복사해서 값이 비는 비트를 채운다. 
ex)
int d = a>>1; //101 십진수 5 
라이트 시프트 연산 효과는 /2 

이제 a를 오른쪽으로 2만큼 라이트 시프트 연산을 해보자.
int e = a>>2; //10 십진수 2
라이트 시프트 연산 효과는 /(2*2)

비트 이동(시프트)연산은 곱셈과 나눗셈 효과가 있는데 사실 우리가 *2
라는 연산을 요청하면 JVM 은 이것을 다시 비트 연산으로 변환해서
처리한다. 우리는 << 연산이 어렵지만, 컴퓨터는 사실 *2라는 것을 
알지 못하고 *2를 << 1로 변형해서 연산을 처리한다. 
결국, 이동(시프트) 비트연산자는 처리 속도를 향상하는 한가지 방법이 된다.

>>> 연산자는 음수를 오른쪽으로 비트 이동했을 때 >>와 차이점이 있다. 
-100을 >>와 >>> 연산의 예를 보자. 
int f = 0b11111111111111111111111110011100; //-100
int g = f >> 1;
int h = f >>> 1;
ex)
연산 : 2진수 : 10진수 
a     : 11111111111111111111111110011100 :-100
a>>1  : 11111111111111111111111111001110 :-50
a>>>1 : 01111111111111111111111111001110 :2147483598
>> 연산자는 이동한 빈칸을 부호 비트로 채우기 때문에 1로 채웠고,
>>> 는 언제나 0으로만 채운다. 
>> 연산결과는 /2의 결과를 
>>> 연산결과는 일종의 쓰레기값 출력.

실습13
ex)
package ch03.bit;

public class ShiftOperation {

	public static void main(String[] args) {
		byte b1 = 0b1010;
		System.out.println(b1);
		
		int a = 0b1000;
		System.out.printf("%32s, %d%n", Integer.toBinaryString(a), a);
		int b = a << 2;
		System.out.printf("%32s, %d%n", Integer.toBinaryString(b), b);
		int d = a >> 2;
		System.out.printf("%32s, %d%n", Integer.toBinaryString(d), d);
		int e = a >>> 2;
		System.out.printf("%32s, %d%n", Integer.toBinaryString(e), e);

		a = -100;
		System.out.println(Integer.toBinaryString(a));
		int h = a << 1;
		System.out.printf("%32s, %d%n", Integer.toBinaryString(h), h);
		int f = a >> 1;
		System.out.printf("%32s, %d%n", Integer.toBinaryString(f), f);
		int g = a >>> 1;
		System.out.printf("%32s, %d%n", Integer.toBinaryString(g), g);

	}

}
//10
                            1000, 8
                          100000, 32
                              10, 2
                              10, 2
11111111111111111111111110011100
11111111111111111111111100111000, -200
11111111111111111111111111001110, -50
 1111111111111111111111111001110, 2147483598



===================================
[자바 해바라기 정리] 4 제어문 
실습18개
1. 제어문
제어문이란 프로그램의 흐름을 제어하기 위한 문장. 
제어문은 조건문과 반복문으로 나눈다. 
조건문은 참과 거짓의 기준을 가지고 행동 할지 또는 말지 결정.

----------------------------------------------------
2. 조건문

2.1 조건문의 종류와 특징
조건문이란 조건식과 실행 문장을 포함하는 블록으로 구성.
조건식은 true 또는 false를 반한하는 식으로 이 식의 결과가 
true이면 블록을 실행하고 false이면 실행하지 않는다. 
ex)
true // 가장 가단한 형태로 자체가 true로 평가.
2>3 // 부등호 연산의 결과로 false로 평가된다.
a % 2 == 0 //a를 2로 나눈 나머지로 연산 결과와 0을 비교해 true/false 반환.
a>10 && b>20 //최종 연산은 논리연산자인 &&의 실행 결과.

조건문은 크게 if 계열과 switch ~ case 문으로 나눈다. 
if 계열 
if 
if ~ else
if ~ else if ~ else if ~ else 의 형태 
모든 상황에서 사용할 수 있는 기본적인 조건문의 형태.
switch ~ case 문은 주로 경우의 수가 많아지고 값이 
정확히 떨어지는 경우 사용된다. (범위가 아닌 경우)


----------------------------------------------------
2.2 if 계열

(1) if 문 
if 문은 조건이 만족하면 실행하는 가장 단순한 구조.
if 키워드 뒤의 소괄호 안에 조건식을 작성. 
조건식이 true일 경우 뒤에 나오는 중괄호 블로 ( { } )을 실행.
그런데, 실행할 블록이 한 문장으로 구성된 경우 블록 표시인 중괄호를 
생략하고 문장만 작성할 수 있다. 
ex)
if(조건식)
{
//조건식이 true일 경우 실행할 문장 
}
ex2)
if(조건식)
//조건식이 true일 경우 실행할 문장 

ex3)
두 형태로 작성된 if 문장 
int visitCnt = 0;
if (visitCnt <1)  //조건식
{
System.out.println("처음 방문");  //실행블록  (1)
}

System.out.println("날씨 굿"); // 조건문과 무관 (2)

조건식이   참이면 : 진행순서 (1) -> (2)
조건식이 거짓이면 : 진행순서 (2)

실행하는 문장이 한 문장인 경우 중괄호 생략 
int visitCnt = 0;
if (visitCnt <1)  //조건식
System.out.println("처음 방문");  //실행블록  (1)

System.out.println("날씨 굿"); // 조건문과 무관 (2)

가독성을 위채 중괄호 사용하기.!!

주의!
제어문 부터 소괄호 및 중괄호가 많이 나오고, 짝을 못찾아 오류가 
자주 발생. 괄호를 열고 닫고, 안에 코드 작성하기.!!
IDE 대부분은 바로 자동으로 닫아준다. 

(2)if ~ else 
조건식에서 false가 반환되었을 때 실행할 블록을 작성할수 있다. 
구조 
ex)
if(조건식){
// 조건식 true 일 경우 실행할 문장 
} else { 
// 조건식 false 일 경우 실행할 문장 
}
ex2)
int num = 10;
if (num % 2 == 0){
result = "짝수 입니다.";
} else {
result = "홀수 입니다.";
}

삼항 연산자(조건부 연사자)를 이용해서 좀더 간단하게 처리.
ex3)
int num = 10;
result = (num % 2 == 0) ? "짝수입니다." : "홀수 입니다.";

ex4) 
무작위로 정수를 발생시켜 범위를 확인하는 프로그램. 
Random 클래스가 제공하는 nexInt() 메서드 사용하면 
0 부터 경계값(bound) - 1 사이의 무작위 정수를 발생시킴.
메서드명 : 선언부와설명 
nexInt() : public int nexInt(int bound)
0부터 bound - 1사이의 무작위 정수를 리턴한다.

Random 클래스는 java.util 패키지에 있기에, 먼저 import 해야함.
import 관련 내용은 7장에서 다룬다.

예제 무작위로 정수를 생성하고 결과를 num1에 할당하기 때문에 
매번 실행때 마다 다르다.

실습1
ex) 
package ch04.condition;

import java.util.Random;

public class IfElseTest {

	public static void main(String[] args) {
		String result = null;
		Random myRandom = new Random();

		System.out.println("큰수? 작은수?");
		int num1 = myRandom.nextInt(100); // 0 ~ 99 사이의 정수
		if (num1 >= 50) {
			result = "큰 수";
		} else {
			result = "작은 수";
		}
		System.out.printf("%d는 %s이다%n", num1, result);

		System.out.println("짝수일까?");
		int num2 = myRandom.nextInt(10); // 0 ~ 9 사이의 정수

		if (num2 % 2 == 0) {
			result = "짝수";
		} else {
			result = "홀수";
		}
		System.out.printf("%d는 %s입니다.%n", num2, result);

		// 삼항연산자(조건부 연산자)를 이용하는 형태
		result = (num2 % 2 == 0) ? "짝수 입니다." : "홀수 입니다.";
		System.out.printf("%d는 %s%n", num2, result);

	}

}
//
큰수? 작은수?
34는 작은 수이다
짝수일까?
3는 홀수입니다.
3는 홀수 입니다.
!

팁 !
이클립스에서 자동 들여쓰기 단축키 : ctrl + shift + f 
!

(3) if~else if~else
비교해야 할 조건이 많을 경우는 중간에 else if 를 끼워 넣을 수 있다. 
ex)
if(조건식){
// 처음 조건식 true 일 경우 실행할 문장 
} else if(조건식){ 
// 두번째 조건식 true 일 경우 실행할 문장 
}...
else{
// 모든 조건식이 false 일 경우 실행할 문장 
}


ex2) 
int score = 75;
String grade = "";
if (score>=90){
grade = "A" ;
} else if (score >= 80 && score <90) {
grade = "B" ;
} else if (score >= 70 && score <80) {
grade = "C" ;
} else if (score >= 60 && score <70) {
grade = "D" ;
} else {
grade = "E";
} 
System.out.println(score + "는 " + grade + "등급입니다.");

해당하는 조건식에서 true 만나야 빠져 나온다. 

다음은 Scanner 를 이용해 사용자로 부터 32 ~ 126까지의
아스키코드 값을 입력 받은 후 그 값이 어떤 성격의 값인지를 
출력하는 프로그램.
Scanner는 java.util 패키지에 속해 있으므로 
import 해야 한다. 

실습2
ex)
package ch04.condition;

import java.util.Scanner;

public class IfElseIfTest {
	public static void main(String[] args) {
		System.out.println("32 ~ 126 사이의 정수를 입력하세요.");
		Scanner scanner = new Scanner(System.in);
		int scanned = scanner.nextInt();
		String type = null;
		if (scanned >= 48 && scanned < 58) {
			type = "숫자";
		} else if (scanned >= 65 && scanned < 91) {
			type = "대문자";
		} else if (scanned >= 97 && scanned < 123) {
			type = "소문자";
		} else {
			type = "기타 타입";
		}
		System.out.printf("숫자 %d는 문자로 %c이고 %s입니다.", scanned, scanned, type);
		scanner.close();
	}

}
//
32 ~ 126 사이의 정수를 입력하세요.
90
숫자 90는 문자로 Z이고 대문자입니다.

(4) 중첩 if 문 
중첩 if 문은 if 문의 실행 블록 내에 또 다른 if 블록이 오는 형태.
else 블록에도 다른 if 블록이 위치할수 있다. 

ex) 
if(조건식1) {
// do something // 조건식1이 true 일 경우 실행할 문장. 
if(조건식2) {
// 조건식 1과 조건식 2가 모두 true 일 경우 실행 
}else{
// 조건식1은 true , 조건식2는 false 일 경우 실행 
}
}else{
// do something // 조건식1이 false 일 경우 실행할 문장. 
}

ex2)
12세 관람가 영화를 관람할 수 있는지를 판별하는 애플리케이션 예제. 

실습3

package ch04.condition;

import java.util.Scanner;

public class NestedIf {

	public static void main(String[] args) {
		String result = "";
		Scanner scanner = new Scanner(System.in);

		System.out.println("나이를 입력하세요.");
		int age = scanner.nextInt();

		System.out.println("보호자가 동반하나요?");
		boolean withParent = scanner.nextBoolean();

		if (age >= 12) {
			result = "관람가";
		} else {
			if (withParent) {
				result = "나이는 적지만 보호자가 있어서 관람가";
			} else {
				result = "나이가 적고 보호자도 없어서 관람 불가";
			}
		}
		System.out.printf("나이: %d, 보호자 동반: %b, 결과: %s", age, withParent, result);
		scanner.close();
	}
}
//
나이를 입력하세요.
1
보호자가 동반하나요?
true
나이: 1, 보호자 동반: true, 결과: 나이는 적지만 보호자가 있어서 관람가
!


----------------------------------------------------
2.3 switch ~ case 

if 문과 달리 범위를 지정할수 없고 특정한 값과 같은지 여부만 비교 할수있다. 
하지만, 표현식 자체가 명확해서 동등성을 비교하는 경우 자주 사용된다. 

기본구조는 switch 의 파라미터로 조건식을 작성한다. 
이 조건식은 true/false를 반환하지 않고 정수값, 문자열, Enum
상수값을 반환한다. 

case 문에서 조건식의 값과 비교할 값을 쓰고 뒤에 콜론(:)으로 
실행문 또는 블록과 구분한다. 
case 값과 조건식의 값이 같은 경우 콜론 뒤의 문장 또는 블록을 실행.
실행 중간에 break 를 만나면 전체 switch 문을 벗어나고 그렇지 않으면 
다른 case 문을 계속 실행한다. 
만약 어떤 case 값도 조건식과 일치하지 않는다면 if ~ else 의 else에
해당하는 default 의 블록이 실행 된다. 
ex)
switch(조건식){
case 값1:
do something 1.. // 조건식의 결과가 값 1과 같은 경우 실행될 문장 
break; // switch 문을 벗어난다. 
case 값2:
do something 2.. // 조건식의 결과가 값 2과 같은 경우 실행될 문장 
default :
do something 3.. // 조건식의 결과와 일치하는 case 문이 없을 때 
실행될 문장 
}

case 값1 이면 // do something 1.. 실행하고 break 만나 빠져나오고 
case 값2 이면 // do something 2.. 실행하고 , default도 실행. 
case 값3 이면 // do something 3.. 실행하고 종료 


실습4
ex2)
package ch04.condition;

public class SwitchSimple {

	public static void main(String[] args) {
		int level = 0;
		String levelString = "";
		switch (level) {
		case 0:
			levelString = "운영자관리, 회원관리, 글쓰기, 보기";
			break;
		case 1:
			levelString = "회원관리, 글쓰기, 보기";
			break;
		case 2:
			levelString = "글쓰기, 보기";
			break;
		default:
			levelString = "보기";
		}
		System.out.println("당신의 권한은 : " + levelString);
	}
}
//
당신의 권한은 : 운영자관리, 회원관리, 글쓰기, 보기

실습5
ex3) 
package ch04.condition;

public class SwitchString {

	public static void main(String[] args) {
		String levelString = "";
		String level = "관리자";
		switch (level) {
		case "관리자":
			levelString = "운영자관리, 회원관리, 글쓰기, 보기";
			break;
		case "운영자":
			levelString = "회원관리, 글쓰기, 보기";
			break;
		case "회원":
			levelString = "글쓰기, 보기";
			break;
		default:
			levelString = "보기";
		}
		System.out.println("당신의 권한은 : " + levelString);
	}
}
//
당신의 권한은 : 운영자관리, 회원관리, 글쓰기, 보기

실습6
ex4)
package ch04.condition;

public class SwitchNoBreak {

	public static void main(String[] args) {
		String levelString = "";
		String level = "관리자";
		switch (level) {
		case "관리자":
			levelString += "운영자관리";
		case "운영자":
			levelString += "회원관리";
		case "회원":
			levelString += "글쓰기";
		default:
			levelString += "보기";
		}
		System.out.println("당신의 권한은 : " + levelString);
	}
}
//당신의 권한은 : 운영자관리회원관리글쓰기보기

실습7
ex5)
package ch04.condition;

import java.util.Scanner;

public class DayByMonthTest {

	public static void main(String[] args) {
		System.out.println("달을 1 ~ 12까지로 입력하세요.");
		Scanner scanner = new Scanner(System.in);
		int month = scanner.nextInt();
		int days = 0;
		switch (month) {
		case 2:
			days = 29;
			break;
		case 4:
		case 6:
		case 9:
		case 11:
			days = 30;
			break;
		default:
			days = 31;
		}
		System.out.printf("%d월은 %d일까지 있습니다.", month, days);
		scanner.close();
	}
}
//
달을 1 ~ 12까지로 입력하세요.
4
4월은 30일까지 있습니다.


----------------------------------------------------
3. 반복문

3.1 반복문의 특징과 종류 

특정 블록을 일정한 조건 또는 횟수만큼 반복해서 실행하도록 하는 문.
초기화, 조건식, 증감식, 실행 블록 4가지 요소로 구성. 
상황에 따라 불필요한 요소는 생략가능. 

초기화 -> 조건식 -> 실행블록 -> 증감식의 순서로 진행.
초기화 과정은 사용할 조건 값을 초기화한다. 
조건식에서 초기화한 값이 주어진 조건에 맞는지 확인하며 
true/false 의 boolean 값을 반환.
실행블록 조건식에서 true가 반환되면 실행된다. 
만약 반복할 내용이 한 문장일 경우는 조건문의 블록과 같이 
중괄호 생략가능. 그러나, 가독성 이유로 , 그냥 쓰기.
이후, 증감식을 통해 조건을 변경하고 변경된 내용을 다시 평가해서 
false가 나오기 전까지 계속 실행블록 -> 증감식 -> 조건식 반복. 

종류 3가지 
for 문 : 반복해야 하는 횟수가 지정될 경우 유리 
예 : 10번 먹으세요. 
while 문 : 반복회수 보다는 상황에 의한 반복을 정의할 경우 유리 
예 : 다 먹으세요
do ~ while 문 : while 작업 중 최소 한번은 실행해야 할 작업이
있는 경우 유리 
예 : 한번 먹어보고 맛있으면 다 먹으세요. 

----------------------------------------------------
3.2 for 문 
(1)기본 형태의 for문
가장 기본적인 반복문 4가지 구성요소를 작성하는 위치가 명확해서 
초심자들에게 유리.

for 문을 사용할 때는 소괄호 안에 초기화, 조건식, 증감식을 
각각';'으로 구분해서 넣고 중괄호를 이용해 조건식의 평가 값이 
true 일 경우 실행할 블록을 작성. 
ex)
for(초기화; 조건식; 증감식) {
//조건식이 true 일 경우 실행할 문장  //= 3)
}
순서 초기화 -> 조건식 -> 3) -> 증감식 
조건식 -> 3) -> 증감식 
조건식 -> 3) -> 증감식  // 반복. 

실습8
ex2)
package ch04.loop;

import java.util.Scanner;

public class TimesTableFor1 {

	public static void main(String[] args) {
		System.out.println("출력할 단을 입력하세요.");
		Scanner scanner = new Scanner(System.in);
		int dan = scanner.nextInt();

		for (int i = 1; i <= 9; i++) {
			System.out.print(dan + "*" + i + "=" + (dan * i) + "\t");
		}
	}
}
//
출력할 단을 입력하세요.
7
7*1=7	7*2=14	7*3=21	7*4=28	7*5=35	7*6=42	7*7=49	7*8=56	7*9=63	
 
(2) 다양한 형태의 for 문 
기본 for 문은 정확히 구성요소를 넣을 공간이 있어서 사용하기 편하다. 
초기값 i와 j가 선언, 조건식은 i만 평가.
증감식에는 i는 1씩 증가, j는 2씩 증가.
ex)
for( int i=0, j=0; i<10; i++, j +=2){
System.out.println(i+j+"\t");
}
ex2)
초기값 boolean 타입의 flag가 선언되어 있고 조건식은 flag를 사용.
3번째 항목인 증감식 부분은 비어 있는 것을 주의.
이 문장은 조건이 변경되지 않기 때문에 무한으로 반복하게 됨.
for ( boolean flag = true; flag;){
System.out.println("무한 루핑");
}

(3) 중첩 for 문 
반복되는 블록이 또 다른 반복문인 형태.
이중 for 문을 이용해서 직각삼각형의 모양을 출력하는 예.

실습9
ex)
package ch04.loop;

public class NestedForTest {

	public static void main(String[] args) {
		for (int i = 0; i < 10; i++) {
			for (int j = 0; j < 10 && j <= i; j++) {
				System.out.print("*");
			}
			System.out.println();
		}
	}
}
//
*
**
***
****
*****
******
*******
********
*********
**********

실습10
ex2)
package ch04.loop;

public class TimesTableFor2 {

	public static void main(String[] args) {
		for(int i=1; i<=9; i++){
			System.out.print(i+"단: ");
			for(int j=1; j<=9; j++){
				System.out.print(i+"*"+j+"="+(i*j)+"\t");
			}
			System.out.println();
		}
	}
}
//
1단: 1*1=1	1*2=2	1*3=3	1*4=4	1*5=5	1*6=6	1*7=7	1*8=8	1*9=9	
2단: 2*1=2	2*2=4	2*3=6	2*4=8	2*5=10	2*6=12	2*7=14	2*8=16	2*9=18	
3단: 3*1=3	3*2=6	3*3=9	3*4=12	3*5=15	3*6=18	3*7=21	3*8=24	3*9=27	
4단: 4*1=4	4*2=8	4*3=12	4*4=16	4*5=20	4*6=24	4*7=28	4*8=32	4*9=36	
5단: 5*1=5	5*2=10	5*3=15	5*4=20	5*5=25	5*6=30	5*7=35	5*8=40	5*9=45	
6단: 6*1=6	6*2=12	6*3=18	6*4=24	6*5=30	6*6=36	6*7=42	6*8=48	6*9=54	
7단: 7*1=7	7*2=14	7*3=21	7*4=28	7*5=35	7*6=42	7*7=49	7*8=56	7*9=63	
8단: 8*1=8	8*2=16	8*3=24	8*4=32	8*5=40	8*6=48	8*7=56	8*8=64	8*9=72	
9단: 9*1=9	9*2=18	9*3=27	9*4=36	9*5=45	9*6=54	9*7=63	9*8=72	9*9=81	


 ----------------------------------------------------
3.3 while 문 
(1) 기본 형태의 while 문 
for 문과 달리 구성요소를 위한 영역이 표시되지 않으므로 실수로 
구성요소를 빠뜨리지 않도록 주의 해야 한다. 
ex) 
초기화; //(1)
while(조건식) { //(2)
// 조건식이 true일 경우 실행할 문장 //(3)
증감식; //(4)
}
순서 
(1) ->(2)->(3)->(4)->(2)->(3)->(4)->..
반복 .

실습11
ex1)
package ch04.loop;

import java.util.Scanner;

public class TimesTableWhile1 {
	public static void main(String[] args) {
		System.out.println("출력할 단을 입력하세요.");
		Scanner scanner = new Scanner(System.in);
		int dan = scanner.nextInt();

		int i = 1;
		while (i <= 9) {
			System.out.print(dan + "*" +i+ "=" + (dan * i)+"\t");
			i++;
		}
		System.out.println();
	}
}
출력할 단을 입력하세요.
3
3*1=3	3*2=6	3*3=9	3*4=12	3*5=15	3*6=18	3*7=21	3*8=24	3*9=27	

(2) 중첩 while 문 
while 문에서도 실행 블록내에 다른 while 문을 가질수 있다. 

실습12
ex)
package ch04.loop;

public class TimesTableWhile2 {
	public static void main(String[] args) {
		int i = 1;
		while (i <= 9) {
			System.out.print(i + "단: ");
			int j = 1;
			while (j <= 9) {
				System.out.print(i + "*" + j + "=" + (i * j) + "\t");
				j++;
			}
			i++;
			System.out.println();
		}
	}
}
//
1단: 1*1=1	1*2=2	1*3=3	1*4=4	1*5=5	1*6=6	1*7=7	1*8=8	1*9=9	
2단: 2*1=2	2*2=4	2*3=6	2*4=8	2*5=10	2*6=12	2*7=14	2*8=16	2*9=18	
3단: 3*1=3	3*2=6	3*3=9	3*4=12	3*5=15	3*6=18	3*7=21	3*8=24	3*9=27	
4단: 4*1=4	4*2=8	4*3=12	4*4=16	4*5=20	4*6=24	4*7=28	4*8=32	4*9=36	
5단: 5*1=5	5*2=10	5*3=15	5*4=20	5*5=25	5*6=30	5*7=35	5*8=40	5*9=45	
6단: 6*1=6	6*2=12	6*3=18	6*4=24	6*5=30	6*6=36	6*7=42	6*8=48	6*9=54	
7단: 7*1=7	7*2=14	7*3=21	7*4=28	7*5=35	7*6=42	7*7=49	7*8=56	7*9=63	
8단: 8*1=8	8*2=16	8*3=24	8*4=32	8*5=40	8*6=48	8*7=56	8*8=64	8*9=72	
9단: 9*1=9	9*2=18	9*3=27	9*4=36	9*5=45	9*6=54	9*7=63	9*8=72	9*9=81	

----------------------------------------------------
3.4 do ~ while 문 
while 문과 문법이 비슷하다. 차이점은 그대로 일단 한번 실행(do)
하고 나서 반복(while)을 결정한다. 

구조 
초기화 후 실행문과 증감식이 있는 블록을 먼저 수행하고 나서 
조건을 확인하게 되어 있다. 즉 처음 조건에 관한 확인은 이미 실행 
블록을 한 번 수행한 후라는 것이다. 조건식 뒤에 세미콜론(';')을 추가해서 
문장의 마지막임을 표시해야 하는 것도 주의하자. 

ex)
초기화; (1)
do {
// 조건식이 true 일 경우 실행할 문장 (2)
증감식; (3)
} while(조건식);

실습13
ex2)
package ch04.loop;

import java.util.Scanner;

public class DoWhile {

	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		int i = 0;
		do {
			System.out.println("제곱근을 알고 싶은 숫자를 입력하세요.(그만은 0)");
			i = scanner.nextInt();
			System.out.println(i + "의 제곱근은 : " + Math.sqrt(i));
		} while (i > 0); 
		// Math.sqrt(double d) 메서드는 파라미터의 제곱근을 반환.
	}
}
//
제곱근을 알고 싶은 숫자를 입력하세요.(그만은 0)
3
3의 제곱근은 : 1.7320508075688772
제곱근을 알고 싶은 숫자를 입력하세요.(그만은 0)
4
4의 제곱근은 : 2.0
제곱근을 알고 싶은 숫자를 입력하세요.(그만은 0)
0
0의 제곱근은 : 0.0


----------------------------------------------------
3.5 반복문의 제어 

중간에 반복을 멈추거나 동작을 생략할수 있다. 
break 와 continue 문 

(1)break 문 
반복문 중지할 때 사용. 
제곱수가 1000보다 작거나 같은 정수를 1부터 찾아가는 과정. 
즉 제곱수가 1000보다 커지면 반복을 종료한다. 
몇 번을 반복해야 할지 모르는 상황에서 그런 조건의 값을 
만나면 반복을 종료하도록 해야 함.

실습14
ex)
package ch04.loop;

public class BreakTest {

	public static void main(String[] args) {
		System.out.println("제곱수가 1000보다 작은 가장 큰 정수는?");
		int i = 0;
		while (true) {
			if (Math.pow(i, 2) > 1000) {
				break;
			}
			i++;
		}
		System.out.println("제곱 수가 1000보다 작은 가장 큰 정수는 " + (--i));
	}
}
//
제곱수가 1000보다 작은 가장 큰 정수는?
제곱 수가 1000보다 작은 가장 큰 정수는 31

실습15
ex2)
package ch04.loop;

import java.util.Random;
import java.util.Scanner;

public class GuGuQuizTest {

	public static void main(String[] args) {
		System.out.println("구구단 문제를 맞추세요. 그만하려면 0 입력");
		Random random = new Random();
		Scanner scanner = new Scanner(System.in);
		while (true) {
			int num1 = random.nextInt(9) + 1;
			int num2 = random.nextInt(9) + 1;

			System.out.printf("%d * %d = %n", num1, num2);

			int result = scanner.nextInt();
			if (result == 0) {
				break;
			} else {
				if (result == num1 * num2) {
					System.out.println("정답입니다.");
				} else {
					System.out.println("정답은 " + (num1 * num2) + "입니다.");
				}
			}
		}
		scanner.close();
	}

}
//
구구단 문제를 맞추세요. 그만하려면 0 입력
2 * 7 = 
14
정답입니다.
7 * 3 = 
0

실습16
ex3)
반복 벗어나게 
package ch04.loop;

import java.util.Scanner;

public class ProductManagerClient {
	private final String line = "********************************************************************";
	String mainMenu = "현황조회(L)\t상품등록(R)\t상품판매(S)\t종료(X)";
	Scanner scanner = new Scanner(System.in);

	private void displayMainMenu() {
		do {
			System.out.printf("%s%n%s%n%s%n", line, mainMenu, line);
			String input = scanner.nextLine();
			if (input.equalsIgnoreCase("X")) {
				System.out.println("종료합니다.");
				return;
			} else if (input.equalsIgnoreCase("L")) {
				System.out.println("현황을 조회합니다.");
			} else if (input.equalsIgnoreCase("S")) {
				System.out.println("상품을 판매합니다.");
			} else if (input.equalsIgnoreCase("R")) {
				System.out.println("상품을 등록합니다.");
			} else {
				System.out.println("적절한 메뉴가 아닙니다.");
			}
		} while (true);
	}

	public static void main(String[] args) {
		ProductManagerClient pm = new ProductManagerClient();
		pm.displayMainMenu();
	}
}
//
********************************************************************
현황조회(L)	상품등록(R)	상품판매(S)	종료(X)
********************************************************************
L
현황을 조회합니다.
********************************************************************
현황조회(L)	상품등록(R)	상품판매(S)	종료(X)
********************************************************************
R
상품을 등록합니다.
********************************************************************
현황조회(L)	상품등록(R)	상품판매(S)	종료(X)
********************************************************************
S
상품을 판매합니다.
********************************************************************
현황조회(L)	상품등록(R)	상품판매(S)	종료(X)
********************************************************************
X
종료합니다.

메인 메뉴는 언제나 최초1회는 보여야 하기 때문에 do ~ while문을 사용.
String에서 제공하는 equalsIgnoreCase()는 대/소문자에 상관없이
문자열을 비교한다. 

(2)continue
반복문 수행중 continue를 만나면 더이상 아래 실행문을 실행하지 않고 
다음 반복으로 이동한다. 

예제 1 ~ 1000 까지의 정수중 3의 배수를 모두 더하는 프로그램.
3의 배수가 아니면 더하기 동작을 수행 안함. 


실습17
ex)
package ch04.loop;

public class ContinueTest {
	public static void main(String[] args) {
		System.out.println("1~1000까지의 정수 중 3의 배수의 합은?");
		int sum = 0;
		for (int j = 1; j <= 1000; j++) {
			if (j % 3 > 0) {
				continue;
			}
			sum += j;
		}
		System.out.println("1~1000까지의 정수 중 3의 배수의 합은 " + sum);
	}
}
//
1~1000까지의 정수 중 3의 배수의 합은?
1~1000까지의 정수 중 3의 배수의 합은 166833

(3) label의 활용 
중첩 반복문에서 label 활용. 
반복문 앞에 붙이는 일종의 이름이고,
break 와 continue 호출시 label을 지정할 수 있다. 
break 또는 continue를 호출할 때 label을 생략하면 
가장 가까운 반복문에 영향을 준다. 
만약 label이 입력된 경우라면 해당 label이 적용된 
반복문에 영향을 준다. 

이중 for 문을 통해서 구구단 출력.
label 와 continue가 어떻게 동작하는지 보기. 

실습18
ex)
package ch04.loop;

public class LabelTest {

	public static void main(String[] args) {
		outer: for (int i = 1; i < 10; i++) {
			inner: for (int j = 1; j < 10; j++) {
				if (j == 5) {
					break; // 각 단별로 *4까지만 출력
					// break inner; // break와 동일
					// break outer; // 1 * 4까지만 출력
					// continue; // *5는 생략하고 출력
					// continue inner; // continue와 동일
					// continue outer; // *5 부터 빠지고 단 구분이 없음
				}
				System.out.printf("%d*%d=%d\t", i, j, i * j);
			}
			System.out.println();
		}
	}
}
//
1*1=1	1*2=2	1*3=3	1*4=4	
2*1=2	2*2=4	2*3=6	2*4=8	
3*1=3	3*2=6	3*3=9	3*4=12	
4*1=4	4*2=8	4*3=12	4*4=16	
5*1=5	5*2=10	5*3=15	5*4=20	
6*1=6	6*2=12	6*3=18	6*4=24	
7*1=7	7*2=14	7*3=21	7*4=28	
8*1=8	8*2=16	8*3=24	8*4=32	
9*1=9	9*2=18	9*3=27	9*4=36	


===================================
[자바 해바라기 정리] 5 배열 
실습15개
1. 배열의 정의와 활용 

1.1 배열의 정의와 특징 
(1) 일상생활에서의 배열과 정의 
일상생활에서 배열이란 동일한 종류의 물건들을 연속적으로 배치하는 것.
예) 달걀 한판 
배열로 관리하는 이유? 관리의 효율성.
개수가 많아지면 관리가 어려워진다. 
배열 사용. 장점 자료 찾기가 쉬움.
주의 할점.
1) 관리할 수 있는 것의 종류 -> 타조알 예 
2) 한번 정해진 크기는 변경 할수 없다. 
3) 관리되는 대상이 달걀이 아니라 판이라는 점. 배열의 개념. 

(2) 배열의 특징 
1) 같은 타입의 데이터 여러 개를 연속된 테이터 하나로 다루는 것 
예) int로 관리하기로 한 배열이라면 , 묵시적형변환이 가능한 
byte, short , char 등. 이외의 값들은 관리할수 없음. 

연속된 데이터라는 말은 , 관리할수 있는 데이터의 개수로 메모리 공간의
연속성을 나타냄. 
예) int 타입의 데이터 4개를 담는 배열 선언 하면 
128비트 공간을 연속적으로 확보.

메모리에 구성된 배열의 뒤에 새로운 데이터들이 추가 안됨.
배열 뒤에 이미 다른 데이터를 사용중이므로, 공간의
연속성이라는 원칙 위배.
따라서, 배열을 한번 생성하고 나면 배열의 크기는 바꿀수 없다. 

2) 동일한 타입의 데이터를 저장하기에 데이터들이 일정한 간격으로 배치.
따라서 처음 데이터의 위치를 찾게 되면 다음 데이터를 찾아가는데 임의의
위치에 있는 데이터를 찾는 것보다 속도가 매우 빠르다. 

----------------------------------------------------
1.2 배열의 활용
(1) 배열의 선언 
변수 타입과 이름으로 선언. 
배열의 타입은 관리할 데이터의 타입과 함께 대괄호[ ]를 사용.
위치는 변수명 앞이나 뒤에 위치.
가독성을 위해 변수명 앞에 사용.!
ex)
관리할_데이터_타입 [ ] 변수명; //권장
관리할_데이터_타입 변수명 [ ]; 
주의 
배열의 타입과 관리할 데이터 타입은 다르다는 것. 
ex) 
int, String을 관리할 수 있는 배열은 다음처럼 선언.
int [] intArray;
String [] strArray;
위 코드는 
배열 타입 변수에 대한 선언. 
앞에 변수의 선언 타입과 이름으로 구성.
변수이름 : intArray가 되고 
나머지 : int [ ] 은 변수의 타입이 된다. 
절대로 intArray의 타입이 int가 아님을 명심.
int [ ] 은 int 를 관리하는 배열타입이지 int 타입이 아니다. 

배열의 데이터 타입은 참조형 데이터 타입이다. 

(2)배열의 생성과 초기화 
참조형 변수 사용하기 위한 객체 설명 6장에서 자세히.
new 키워드와 어떤 데이터를 몇 개나 저장할지 대한 정보 필요. 
ex)
new 관리하려는_데이터_타입 [데이터의_개수]
int 타입의 데이터 3개를 관리할 배열 points .
int [] points = new int [3]
배열선언 			배열생성 
배열의 크기 : length 속성.
현재 points 배열의 length는 3.
System.out.println(points.length); // 3

배열 생성 코드가 실행되면 메모리에 int 타입의 데이터 3개를 저장할수
있는 공간이 할당되고 points가 그 메모리의 위치를 참조함. 
points (참조변수)	
0x100 ---->  0x100 : int int int 
(객체 생성 6장에서 자세히)

배열의 각각의 공간들은 생성과 동시에 관리되는 데이터 타입에 대한 
기본값으로 초기화된다. 
데이터 타입 : 기본값 : 비고 
boolean : false
char : '\u0000' : 공백문자
byte,short, int : 0
long : 0L
float : 0.0f
double : 0.0
참조형변수 : null :아무것도 참조하지 않음. 
points (참조변수)	
0x100 ---->  0x100 : int int int 
(객체 생성 6장에서 자세히)  0    0   0

(3)배열의 사용과 메모리 
배열이 가지는 각각의 공간은 각 공간의 순서를 나타내는 index 갖음.
index 0부터 시작하며 1씩 증가하는 정수값.
배열의 각 요소에 접근할려면 배열이름[index_번호] 사용. 

실습1
ex) 
package ch05.basic;

public class SimpleArray {
	public static void main(String[] args) {
		int [] points = new int[3];
		System.out.printf("배열의 크기: %d%n", points.length);
		
		points[0] = 1;
		points[1] = 'A';
		//points[2] = 1.5;

		System.out.printf("0 번째 요소: %d%n", points[0]);
		System.out.printf("1 번째 요소: %d%n", points[1]);
		System.out.printf("2 번째 요소: %d%n", points[2]);
	}
}
//
배열의 크기: 3
0 번째 요소: 1
1 번째 요소: 65
2 번째 요소: 0

메모리 동작 
1) 배열 선언 : int [] points
참조형 변수 points 가 선언, 아직 참조하지 않고 null 상태 
2) 배열 생성 : new int [3] 
int 타입 3개 , 32비트 * 3만틈의 메모리에 연속적으로 할당. 
맨 처음 요소의 시작 주소를 0x100 이라고 가정. 
이 값이 배열의 참조값. 
이후 배열 크기 변경 불가. 각 요소 초기값 0으로 초기화 
3) 참조값 할당 : points = new int [3]
'=' 연산이 진행되고, 참조값이(0x100) 이 points에 할당. 
배열명 points을 통해 각 요소에 접근 가능.
4)배열 요소에 값 할당 : points[0] = 1; 
points[1] = 'A'; 

(4) 반복문과 배열 
length와 인덱스를 가지는 특성상 반복문을 이용해서 
배열 요소에 접근하는 경우가 많다. 
배열에 3단을 저장하고, 홀수 번째 요소의 합 구하기.

실습2
ex)
package ch05.basic;

public class TimesTableArrayTest {
	public static void main(String[] args) {
		int[] timesTable = new int[9];
		for(int i=0; i<timesTable.length; i++){
			timesTable[i] = 3 * (i+1);
		}
		System.out.println("배열 생성 완료");
		
		int sum = 0;
		for(int i=0; i<timesTable.length; i++){
			if(i %2==0){
				sum+=timesTable[i];
			}
		}
		System.out.printf("홀수 번째 요소들의 합은: %d%n", sum);
	}
}
//
배열 생성 완료
홀수 번째 요소들의 합은: 75

(5) 배열의 경계 
0 <= 인덱스 < length 
범위를 넘어가면 ArrayIndexOutOfBoundsException 예외 발생. 
비정상적 종료. 

실습3
ex)
package ch05.basic;

public class BoundsTest {

	public static void main(String[] args) {
		char [] charArray = new char [3];
		for(int i=0; i<charArray.length; i++){
			charArray[i] = (char)(i+'A');
		}
		
		for(int i=0; i<4; i++){
			System.out.printf("%d 번째 요소: %c%n",i, charArray[i]);
		}
	}
}
//
0 번째 요소: A
1 번째 요소: B
2 번째 요소: C
Exception in thread 
"main" java.lang.ArrayIndexOutOfBoundsException: 
Index 3 out of bounds for length 3
	at ch05.basic.BoundsTest.main(BoundsTest.java:12)
	
반복문에서 배열을 사용할 때 될수 있으면 length 속성을 통해 접근.!!

(6)배열 생성과 동시에 할당한 값으로 초기화 
중괄호 { } 이용해서 배열의 생성과 동시에 배열 요소에 값을 
지정하는 방식. 
주의 배열의 선언과 생성이 동시에 진행될 때만 사용가능.
ex)
int [] iArray1 = { 100, 200};
int [] iArray2; // 배열선언
//iArray2 = {100,200}; // 문법오류 

선언과 생성을 따로 할 경우,
new 와 중괄호 동시에 사용해서 표현한다
주의. 배열 객체를 생성시 배열의 크기를 지정 안한다.
ex)
int [] iArray3 = new int [] { 100,200};
int [] iArray4;
iArray4 = new int [] {100,200};
이런 형태는 배열 타입 변수를 파라미터로 전달받은 후 
새롭게 초기화해야 하는 경우 유용. 

실습4
ex2)
	package ch05.basic;

public class InitArrayTest {

	public static void main(String[] args) {
		String [] strs1 = new String [3];
		strs1[0] = "Hello";
		strs1[1] = "Java";
		strs1[2] = "World";
		
		String [] strs2 = {"Hello", "Java", "World"};

		if(args.length==0){
			args = new String[]{"Hello", "Java", "World"};
		}
		
		for(int i=0; i<strs1.length; i++){
			System.out.printf("strs1: %s, strs2: %s, args: %s %n", strs1[i], strs2[i], args[i]);
		}
	}
}
//
strs1: Hello, strs2: Hello, args: Hello 
strs1: Java, strs2: Java, args: Java 
strs1: World, strs2: World, args: World 
		
----------------------------------------------------
2. 다차원 배열 

2.1 다차원 배열의 정의 

2차원 배열 대괄호 2개로 구성. 
변수 선언의 
ex)
int a; // a의 타입은 int 
int [] arr; // arr 의 타입은 배열, 관리하는 데이터 int 
int[] [] arr2Dim; // arr2Dim의 타입은 배열, 관리하는 데이터는 int []
int[][] [] arr3Dim; // arr3Dim의 타입은 배열,
관리하는 데이터는 int[][]
int[][]...[] [] arrnDim; //arrnDim의 타입은 배열,
관리하는 데이터는 int[][]...[]
변수 이름을 제외한 나머지는 모두 타입이다. 
특이한 점. arr2Dim 타입 역시 배열이고,
관리하는 데이터가 int가 아니라 int[]인점. !!
다차원 배열이란 단순히 그것보다 한 차원 낮은 배열을 관리하는 
1차원 배열일 뿐
ex) 
int 의 99차원 배열은 단순히 int의 98차원 배열을 관리하는
1차원 배열이다. 

----------------------------------------------------
2.2 2차원 배열의 생성과 사용 

배열 생성시 길이 지정.
여러 개의 대괄호 등장하는데 이 중 맨 앞의 대괄호에 배열의 크기 명시.
생략 불가. 그 뒤에 등장하는 대괄호는 관리하는 배열의 크기 지정.
ex)
arr2Dim은 int[3]인 배열 2개를 관리하는 2차원 배열. 
int [][] arr2Dim = new int [2][3];
[2] : 2차원 배열의 크기 
[3] : 1차원 배열의 크기 
[] [] []
[] [] []

arr2Dim의 length는 2개 
주의 arr2Dim이 관리하는 것은 int가 아니라 int[]라는 점. 
arr2Dim[0]은 타입은 int[]이다. 배열 길이는 3이다. 
arr2Dim[0][0]은 arr2Dim[0]의 0번째 요소가 되고 타입은 int .

실습5
ex2)
package ch05.multi;

public class TimesTable2Dim {

	public static void main(String[] args) {
		// 구구단을 저장할 2차원 배열 선언
		int[][] gugu = new int[9][9];
		System.out.printf("gugu의 길이: %d%n", gugu.length);
		System.out.printf("gugu의 0 번째 요소의 길이: %d%n", gugu[0].length);

		// 배열에 구구단 저장
		for (int i = 0; i < gugu.length; i++) {
			for (int j = 0; j < gugu[i].length; j++) {
				gugu[i][j] = (i + 1) * (j + 1);
			}
		}
		// 배열 내용 출력
		for (int i = 0; i < gugu.length; i++) {
			for (int j = 0; j < gugu[i].length; j++) {
				System.out.printf("%d\t", gugu[i][j]);
			}
			System.out.println();
		}

		char[][] charArr = { { 'H', 'E', 'L', 'L', 'O' }, { 'J', 'A', 'V', 'A' }, { 'W', 'O', 'R', 'L', 'D' } };
	}
}
//
gugu의 길이: 9
gugu의 0 번째 요소의 길이: 9
1	2	3	4	5	6	7	8	9	
2	4	6	8	10	12	14	16	18	
3	6	9	12	15	18	21	24	27	
4	8	12	16	20	24	28	32	36	
5	10	15	20	25	30	35	40	45	
6	12	18	24	30	36	42	48	54	
7	14	21	28	35	42	49	56	63	
8	16	24	32	40	48	56	64	72	
9	18	27	36	45	54	63	72	81	

(1) 2차원 배열의 메모리 
코드가 실행되는 과정을 메모리 할당 측면에서.
ex)
int [][] arr2Dim = new int [2][3];
arr2Dim[1][1]=100;
//
int [][] arr2Dim = new int[2][];
arr2Dim[0] = new int [3]; // 관리할 1차원 배열 생성후 할당.
arr2Dim[1] = new int [3];
arr2Dim[1][1] = 100;

1)배열 선언과 생성 : int [][] arr2Dim = new int[2][];
              0x100
arr2Dim -> [0] null 
0x100      [1] null 

2) int[3]을 생성하고 arr2Dim의 각요소로 할당 
arr2Dim[0] = new int[3]
arr2Dim[1] = new int[3]

              0x100
arr2Dim -> [0] 0x200 -> 0x200[0][1][2]
                              0  0  0
0x100      [1] 0x300 -> 0x300[0][1][2]
                              0  0  0
3)arr2Dim[1][1]에서 100 할당 : arr2Dim[1][1]=100;

              0x100
arr2Dim -> [0] 0x200 -> 0x200[0][1][2]
                              0  0  0
0x100      [1] 0x300 -> 0x300[0][1][2]
                              0 100 0
(2)가변배열 
배열의 한 형식으로 포함된 요소 배열의 length가 다른 배열. 

ex) 
int [][] arr2Dim = new int [3][];

arr2Dim[0] = new int[4];
arr2Dim[1] = new int[3];
arr2Dim[2] = new int[5];

메모리 구조 
              0x100
arr2Dim -> [0] 0x200 -> 0x200[0][1][2][3]
                              0  0  0  0
0x100      [1] 0x300 -> 0x300[0][1][2]
                              0  0  0
           [2] 0x400 -> 0x400[0][1][2][3][4]
		                      0  0  0  0  0
배열의 길이가 가변이라도 length를 이용한 접근이면 된다. 

실습6
ex2)
package ch05.multi;

public class VariableLengthArrayTest {

	public static void main(String[] args) {
		int[][] arr2 = new int[4][];
		arr2[0] = new int[] { 1, 2, 4, 5 };
		arr2[1] = new int[] { 10, 20, 30, 40, 50 };
		arr2[2] = new int[] { 20, 20, 20 };
		arr2[3] = new int[] { 30, 30, 30, 30, 30 };

		int sum = 0;
		int count = 0;

		for (int i = 0; i < arr2.length; i++) {
			for (int j = 0; j < arr2[i].length; j++) {
				sum += arr2[i][j];
				count++;
			}
		}
		System.out.printf("배열의 총 합은: %d, 평균은: %3.1f", sum, (sum * 1.0 / count));
	}
}
//
배열의 총 합은: 372, 평균은: 21.9

(3) 다차원 배열의 초기화 
중괄호를 이용해 선언과 동시에 초기화 진행 가능.
ex)
char [][] charArr2Dim = {
{ 'H', 'E', 'L', 'L', 'O' }, 
{ 'J', 'A', 'V', 'A' }, 
{ 'W', 'O', 'R', 'L', 'D' }
};

실습7
ex2)
package ch05.multi;

public class SimpleInitTest {

	public static void main(String[] args) {
		char[][] charArr2Dim = { 
								{ 'H', 'E', 'L', 'L', 'O' }, 
								{ 'J', 'A', 'V', 'A' }, 
								{ 'W', 'O', 'R', 'L', 'D' } 
								};
		for(int i=0; i<charArr2Dim.length; i++) {
			for(int j=0; j<charArr2Dim[i].length; j++) {
				System.out.print(charArr2Dim[i][j]);
			}
			System.out.println();
		}
	}
}
//
HELLO
JAVA
WORLD


----------------------------------------------------
3. 고급 배열 특성 

3.1 향상된 for 문 : for each 문 

자바 5버전 부터 향상된 for 문 사용.
for each 문으로도 불린다.
배열 또는 java.lang.Iterable 인터페이스를 구현한 컬렉션 프레임워크에서 
사용 가능. 
기존 for 문과 비교해서 초기값과 증감식을 사용안함.
배열이 가지고 있는 요소들을 특정 변수로 바로 할당해서 
사용 가능. 
ex)
for(관리되는_타입변수명 : 배열_이름){
//반복할문장
}
1) 내부적으로 인덱스 0번부터 배열의 길이만큼 복사하면서 
그때그때 요소값을 변수에 할당.
2) 반복문 안에서 해당 변수를 이용가능.
전체적으로 간결.

단점
인덱스를 사용하지 않고, 인덱스를 사용할수 없다. 
반복처리할 범위 지정 할수 없다. 

용도 
인덱스를 사용하거나, 특정 범위의 반복이 필요한 경우 
기본 for 문 사용 
그렇지 않은 경우는 for each문 사용. 

실습8
ex)
package ch05.advanced;

import java.util.Random;

public class IteratorFor {

	public static void main(String[] args) {
		int [] datas= new int[100];
		Random random = new Random();
		for(int i=0; i<datas.length; i++){
			datas[i] = random.nextInt(100);
		}
	
		int evenSum = 0;
		for(int i=0; i<datas.length; i++){
			int data = datas[i];
			if(data%2==0){
				evenSum+=data;
			}
		}
		System.out.printf("짝수들의 합: %d%n", evenSum);
		
		int oddSum = 0;
		
		for(int data: datas){
			if(data%2==1){
				oddSum+=data;
			}
		}		
		System.out.printf("홀수들의 합: %d%n", oddSum);
	}
}
//
짝수들의 합: 2770
홀수들의 합: 2384



----------------------------------------------------
3.2 배열 데이터의 정렬 

배열 같은 자료구조에 대해서는 정렬에 대한 요구사항이 많다. 
정렬을 구현 하기 위한 알고리즘
버블 정렬, 선택 정렬, 삽입 정렬등 여러가지 방식 있다. 

버블 정렬 
인접한 두수를 일정 기준으로 비교해서 큰 수를 뒤로 보내는 정렬.
만약, 오름차순이면 큰 값을 뒤로 이동.
내림차순이면 작은 값 뒤로 이동.

ex)
2와 1의 오름차순 1->2 , 프로그래밍적으로 할려면 
임시 변수를 이용.
2를 임시변수에 넣고, 2의 자리에 1넣고, 1의 자리에
2넣고 두값 자리를 바꾸는 것을 swap이라 함. 

이 작업을
배열의 크기에서 현재까지의 순환횟수를 뺀 만큼 반복한다. 
단 매번 맨 뒤자리가 고정되기 때문에 반복할수록 
비교해야 할 가짓수는 하나씩 줄어든다. 

실습9
ex)
package ch05.advanced;

import java.util.Random;

public class Sorting {

	public static void main(String[] args) {
		Random rand = new Random();
		int temp = 0;
		int[] arr = new int[10];
		for (int i = 0; i < 10; i++) {
			arr[i] = rand.nextInt(100);
		}
		System.out.println("초기 상태");
		for (int i : arr) {
			System.out.printf("%d \t", i);
		}
		// 정렬
		for (int i = 0; i < arr.length - 1; i++) {
			for (int j = 0; j < arr.length - 1 - i; j++) {	// 비교 가지 수 줄이기
				if (arr[j] > arr[j + 1]) {
					temp = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = temp;
				}
			}
		}
		System.out.println("\n정렬 후");
		for (int i : arr) {
			System.out.printf("%d \t", i);
		}
	}
}
//
초기 상태
66 	56 	73 	87 	31 	48 	9 	5 	50 	97 	
정렬 후
5 	9 	31 	48 	50 	56 	66 	73 	87 	97 	

정렬은 배열 등에서 당연히 구현되어야 할 기능. 
이런 기능들은 미리 API(Application Programming Interface)
를 통해 제공. 
Array 클래스에서 제공하는 sort()는 파라미터로 들어오는 배열을 
오름차순으로 정렬.
만약, 문자열을 관리하는 배열이 파라미터로 들어온다면 
대문자 -> 소문자의 사전순으로 정렬.

Arrays 의 sort()메서드 
메서드명 : 선언부와 설명 
sort() : public static void sort(Object[] a)
a 를 오름차순으로 정렬한다. a 의 요소들은 Comparable을 
구현해야 한다. 

실습10
ex)
package ch05.advanced;

import java.util.Arrays;

public class SortingAPI {

	public static void main(String[] args) {
		String [] arr = {"Java", "is", "A", "PIE"};
		Arrays.sort(arr);
		System.out.println("정렬 후");
		for (String i : arr) {
			System.out.printf("%s \t", i);
		}
	}
}
//
정렬 후
A 	Java 	PIE 	is 	

----------------------------------------------------
3.3 배열의 출력 

배열 출력할려고 for 문 이용.
API 이용하면 쉬움.
Arrays 클래스가 제공하는 toString()이용 

Arrays의 toString() 메서드
메서드명 : 선언부와설명
toString() : public static String toString(Object[] a)
a의 요소들을 쉼표를 구분자로 하는 문자열로 리턴한다. 

실습11
ex)
package ch05.advanced;

import java.util.Arrays;

public class PrintArray {

	public static void main(String[] args) {
		String [] strs = {"Hello", "Java", "World"};
		System.out.println(Arrays.toString(strs));

		for(String str: strs){
			System.out.print(str+"\t");
		}
	}
}
//
[Hello, Java, World]
Hello	Java	World	


실습12

ex2)
package ch05.advanced;

import java.util.Arrays;
import java.util.Random;

public class LottoGeneratorByArray {

	public static void main(String[] args) {
		int[] selected = new int[6];
		int[] fullBall = new int[45];

		int cnt = 0;
		Random rand = new Random();
		while (cnt < 6) {
			int num = rand.nextInt(45);
			int ball = fullBall[num];
			if (ball == 0) {
				selected[cnt] = num + 1;
				fullBall[num] = -1;
				cnt++;
			}
		}
		Arrays.sort(selected);
		System.out.println(Arrays.toString(selected));
	}
}
//
매번 다름 
[4, 9, 16, 23, 34, 36]


----------------------------------------------------
3.4 배열의 크기 변경 

배열을 데이터에 적합한 길이로 만들어야 하고,
필요에 따라 늘어날 수 있어야 한다는 점. 
기존 배열의 크기 변경 불가.
좀 더 큰 새로운 배열 만들고 복사해 넣고,
다시 새로운 데이터를 추가. 

System 클래스가 제공하는 arraycopy()를 사용하면 
이 과정을 API 차원에서 지원함.
메서드명 : 선언부와설명
toString():public static void arraycopy(
Object src, int srcPos, Object dest, int destPos, int length);
src의 srcPos부터 length 만큼 복사해서 dest의 destPos에 저장.

실습13
ex)
package ch05.advanced;

import java.util.Arrays;

public class ArrayCopy {
	public static void main(String[] args) {
		int [] source = {1,2,3,4,5};
		int [] target = new int[10];
		for(int i=0; i<source.length; i++){
			target[i] = source[i];
		}
		System.out.println(Arrays.toString(target));
		
		int [] target2 = new int[10];
		System.arraycopy(source, 0, target2, 0, source.length);
		System.out.println(Arrays.toString(target2));
	}
}
//
[1, 2, 3, 4, 5, 0, 0, 0, 0, 0]
[1, 2, 3, 4, 5, 0, 0, 0, 0, 0]


----------------------------------------------------
3.5 main()메서드에서의 배열 

자바 공부 시작하면서 배열을 배우기 전부터 배열을 사용했다.
main()메서드의 파라미터로 전달되는 String[] args.
자바 애플리케이션이 실행될 때 JVM은 String 배열을 만들어서
파라미터로 전달한다. 평상시에는 전달하는 파라미터가 없기 때문에
이 배열의 길이는 0이다. 만약 100,200,300 처럼 값을 
입력하면 ["100", "200","300"] 형태로 된 배열이 전달.

만약, 프로그램 시작 시 입력되는 숫자를 더하는 프로그램을 
만든다면 어떻게 될까?
숫자를 넣어도 문자열로만 처리 되어서 연결만 발생.
100200300 될뿐 600이라는 값을 얻을 수 없다. 

이런 경우 Integer라는 Wrapper 클래스에서 제공하는 
parseInt()사용하면 문자열을 int로 변경 가능. 

Integer의 parseInt()메서드 
메서드명 : 선언부와 설명 
parseInt() : public static int parseInt(String s)
throws NumberFormatException 
:문자열의 형태인 s를 int로 변경해 리턴.

실습14
ex)
package ch05.advanced;

public class MainParam {
	public static void main(String[] args) {
		int sum = 0;
		for (String arg : args) {
			int num = Integer.parseInt(arg);
			sum = sum + num;
		}
		System.out.printf("배열의 길이: %d, 요소의 총합: %d", args.length, sum);
	}
}
//
배열의 길이: 0, 요소의 총합: 0

이클립스에서 프로그램을 실행시 파라미터 전달을 위해서 절차 필요.
패키지 탐색기에서 소스 파일을 
우클릭-> Run As- Run Configurations 선택.
Name:MainParam 확인 
Program arguments 에 (Tab 항목 2번째)
100 200 300 
입력 
Run. 
//
배열의 길이: 3, 요소의 총합: 600

실습15
ex2)
package ch05.advanced;

public class MainParam2 {

	public static void main(String[] args) {

		int num = args.length > 0 ? Integer.parseInt(args[0]) : 5;
		int sum = 0;
		for (int i = 1; i <= 100; i++) {
			if (i % num == 0) {
				sum += i;
			}
		}
		System.out.println("1~100까지 " + num + "의 배수의 합은 : " + sum);
	}
}

//
1~100까지 5의 배수의 합은 : 1050


===================================
[자바 해바라기 정리] 6 클래스와 객체
실습17개

1. 객체지향 프로그래밍

1.1 생활에서의 클래스와 객체 
클래스와 인스턴스(객체) 이야기 
도면 -> 제품 
도면 : 클래스 
제품 : 객체 
즉, 클래스는 객체를 만들어내는 원판이고, 원판을 통해 
만들어진 객체들을 사용한다. 

----------------------------------------------------
1.2 객체지향 프로그래밍(OOP:Object Oriented Programming)

요즘 스크립트 언어, 함수형 언어들이 주목 받고 있지만,
엔터프라이즈 계열의 대형 프로젝트들은 대부분 자바로 구성. 
객체지향 언어로서의 장점이 많이 드러나서.
객체 , 손님 객, 주체가 아닌 것이 객체이다.
객체를 이용하면 편하다. 주체적으로 객체 반대로 하면 힘들다. 
예)꽃배달 
객체지향 프로그래밍이란 프로그램에서 필요한 요소들을 객체로 만들고 
이것들을 이용해 프로그래밍 하는 것.

(1)객체지향과 모듈화 
모듈화 : 예 레고 
비행기의 머리, 몸통 , 날개, 꼬리를 모듈.
모듈은 재사용이 가능하도록 조립된 블록이고 
모듈화란 모듈 형식으로 작업을 진행 하는것.

모듈화된 프로그램 특징 
-추가/수정/삭제가 쉽다
-재사용 가능.
-검증된 모듈 사용은 신뢰도가 좋음.

레고 vs 프라모델 중 
날개를 쉽게 변경할수 있는 작품은?
하늘을 날 수 있게 멋진 것은?
모듈화는 장점들이 많지만 완벽하지는 않다.
특정 프로그래밍 방법이 맞고 나머지는 틀렸다는 개념은 아님.

(2) 좋은 객체와 올바른 사용법 
좋은 객체란 자신이 가진 정보를 활용하는 기능이 
다양한 객체.
예) 홍길동, 임꺽정 말하기 기능의 유무로 뭐가 더 편한가?
정보를 가져오지 말고 정보를 가진 객체에게 일을 
시키는 것이 올바른 객체의 사용법.


----------------------------------------------------
2. 클래스 와 객체

2.1 클래스 와 객체 

객체를 어떻게 만들까?
APIE 특징중 , Abstraction에 대한 부분.
-현실의 객체가 갖는 속성과 기능은 추상화(abstraction)
과정을 거쳐 클래스로 정의된다. 
-클래스는 구체화 과정을 거쳐 프로그램의 객체(object, instance)
가 된다. 

자바에서 이런 틀을 클래스라고 부른다. 
클래스는 하나의 데이터 타입이 되며 제품의 틀로서 동작. 
클래스를 통해서 나온 제품을 객체라고 부르며 
클래스의 정의대로 생성된다. 

(1) 클래스와 객체가 만들어지는 과정
모든 객체를 분석하면 속성과 기능을 찾을수 있다. 
속성은 객체가 가지는 정보, 데이터로 변수(variable)
,상태(status), 필드(field)와 같은 말로 사용.
기능은 메서드(method), 행위(behavior), 
함수(function)로 불리고, 객체가 할수있는 작업.

현실 세계 객체에 대한 분석 결과를 프로그래밍 영역으로 가져오면,
먼저, 추상화라는 과정을 거쳐 클래스를 만드는 과정이다.
추상화 과정에서는 객체 타입을 나타낼 이름을 정하고,
객체의 속성을 변수로, 객체의 기능을 메서드로 하여 
하나의 클래스를 작성. 

클래스를 구성하는 변수와 메서드를 각각 멤버변수와 멤버메서드 라 한다. 
클래스는 설계도 역할만 수행해서, 실제로 우리가 사용할 수는 없다. 
클래스를 바탕으로 활동할 객체가 필요.
객체를 만드는 과정을 구체화 또는 객체화라고 한다. 

구체화는 프로그램의 세계 즉 메모리에 객체(인스턴스, 오브젝트(object))
를 생성하는 과정으로 new 키워드 사용.
이제 클래스를 바탕으로 메모리에 생성된 객체의 멤버 변수에 철수,20,false 
와 같은 실제 값이 할당되고 메서드도 호출 가능. 

정리, 클래스는 객체를 정의해 놓은 것으로 설계도의 역할. 
이 클래스는 직접 사용할수없고 단지 객체를 만들기 위한 틀일뿐.
객체는 클래스를 데이터 타입으로 하여 메모리에 생성되는 것으로 
프로그램에서 사용하는 것이다. 
객체
- 클래스를 구체화 한것 
- 실제로 동작하는 것 
- 메모리에 생성된 데이터 

(2)클래스 생성 
이클립스를 이용해서 클래스 생성 
패키지 탐색기에서 현재 프로젝트 src 항목에서 
마우스 우클릭 -> new -> class 
Package : ch06.person
Name : Person 

이전과 달리 이 클래스는 우리가 사용할 객체를 
생성할 틀로 사용되므로 main 메서드를 작성할 필요는 없음. 

예제처럼 
멤버변수와 멤버메서드를 작성하면 클래스 완성. 
eat(), work() 메서드는 멤버 변수인 isHungry의
값을 변경하는 것에 주목. 
클래스의 속성을 변경하는 것이 아니라,
클래스 바탕으로 생성된 객체의 상태를 변경 하는 것.
클래스는 단지 원판임. 

실습1
ex)
package ch06.person;

public class Person {
//멤버변수
	String name;
	int age;
	boolean isHungry;
	
//멤버메서드
	void eat() {
		System.out.println("냠냠.");
		isHungry = false;
	}

	void work() {
		System.out.println("열심히");
		isHungry = true;
	}
}

(3) 객체의 생성과 활용 
클래스가 준비되면, 이 클래스를 이용해 객체를 만들고 
사용할 주체를 만들어본다. 

객체 생성시 new 키워드 이용해서 생성자라는 것 호출.
생성자는 뒤에서 다루고, 일단 클래스와 이름이 동일하다는 것만.
생성자를 호출하면 메모리에 객체가 생성되고 이것 사용하기 위해서는 
그 객체를 참조할 수 있는 참조값(주소값 비슷한 것)을 
해당 클래스 타입의 변수에 할당. 
ex)
클래스명 변수명 = new 클래스명();
참조형 변수.
실제 데이터는 메모리 어딘가에 있는 객체이고, 
이 객체를 참조하는 변수라는 뜻이다. 

다음 예 Person 타입의 객체 2개를 만들고 사용하는 예 
매번 new 를 할때마다 
새로운 객체가 생성되므로 서로의 멤버 변수의 값 독립적이다. 

실습2
ex) 
package ch06.person;

public class PersonTest {
	public static void main(String[] args) {
		Person person1 = new Person();
		person1.name = "홍길동";
		person1.isHungry = true;
		System.out.println(person1.name + " : " + person1.isHungry);
		person1.eat();
		System.out.println(person1.name + " : " + person1.isHungry);

		Person person2 = new Person();
		person2.name = "임꺽정";
		person2.isHungry = true;
		System.out.println(person2.name + " : " + person2.isHungry);
		System.out.println(person1.name + " : " + person1.isHungry);
		
	}
}
//
홍길동 : true
냠냠.
홍길동 : false
임꺽정 : true
홍길동 : false


----------------------------------------------------
2.2 객체와 메모리 

JVM의 메모리는 크게 3부분 
- 클래스 영역(class area)
- 스택영역(Stack area)
- 힙 영역(Heap area)

- 클래스 영역(class area)
클래스 원형이 올라가는 곳으로 
Method Area, CodeArea , Static Area 
로 불린다. 

#Field 정보: 멤버변수의 이름, 데이터 타입 접근 제어자에 대한 정보 
#Method 정보 : 메서드 이름, 리턴 타입, 파라미터,
#접근 제어자에 대한 정보 
#Type 정보 : 타입의 속성이 클래스인지 인터페이스(interface)인지,
타입의 전체 이름, 상위 클래스 이름, 접근 제어자 정보등.
#상수 풀(Constant Pool)
:타입(클래스 또는 인터페이스)에서 사용된 상수가 저장되는 곳으로 
문자 상수도 상수 풀에 저장. 

- 스택영역(Stack area)
:메서드 호출시 마다 로컬 변수들이 쌓이는 영역으로 
스레드(thread)별로 별도의 공간을 가진다. 
이 영역은 LIFO(Last In First Out)구조로 나중에 
메모리에 생성된 데이터가 먼저 소멸된다. 
로컬 변수란 호출된 메서드의 매개변수나 메서드 내부에 
선언된 변수등으로 객체의 멤버변수가 아닌 변수.

- 힙 영역(Heap area)
:힙은 new 키워드로 생성된 객체가 저장되는 공간으로,
스택과 달리 여러 스레드가 공유한다. 
이 영역에 생성된 객체들은 프로그램 코드로 임의로 삭제할 수 없고 
자동으로 G.C(Garbage Collection)가 실행될 때 
삭제되어 사용하던 메모리 공간이 반환된다. 

클래스 영역 #########
class Person
- name
- age
- isHungry

-eat()
-work()

class PersonTest
- main()

스택 영역 #########
Person person2
0x300
Person person1
0x100

힙 영역 ########
0x300 
0x400 :name ----> 0x400 임꺼정 
0 : age 
true : isHungry

0x100 
0x200 :name ----> 0x200 홍길동 
0 : age 
false : isHungry

코드 다시 살펴보기

실습3
ex)
package ch06.person;

public class PersonTest {
	public static void main(String[] args) {
		Person person1 = new Person();
		person1.name = "홍길동";
		person1.isHungry = true;
		System.out.println(person1.name + " : " + person1.isHungry);
		person1.eat();
		System.out.println(person1.name + " : " + person1.isHungry);

		Person person2 = new Person();
		person2.name = "임꺽정";
		person2.isHungry = true;
		System.out.println(person2.name + " : " + person2.isHungry);
		System.out.println(person1.name + " : " + person1.isHungry);
		
	}
}
//
홍길동 : true
냠냠.
홍길동 : false
임꺽정 : true
홍길동 : false

----------------------------------------------------
3. 변수의 종류 

3.1 선언 위치에 따른 변수의 종류 

멤버 변수(Member Variable)와 로컬변수(Local Variable)
로 나눈다. 
멤버 변수 : 클래스 영역에 선언된 변수.
static 키워드 사용 여부에 따라 
클래스 멤버 변수, 인스턴스 멤버 변수로 나눈다. 

로컬 변수 : 메서드나 생성자, 초기화 블록처럼
클래스 영역 내에 있는 또 다른 블록 내부에 선언된 변수.
메서드 등의 선언부에 파라미터로 선언된 변수를 특별히 
파라미터 변수라 부른다. 

구분 : 선언위치 : 변수 종류 : 특징 
멤버변수 : 클래스 영역 : 클래스 멤버변수: static 키워드 사용 
멤버변수 : 클래스 영역 : 인스턴스 멤버변수: static 키워드 없음 

로컬변수 : 함수 등 내부 : 로컬변수 
로컬변수 : 함수 등 내부 : 파라미터 변수 : 메서드 파라미터

실습4
ex)

package ch06.variable;

public class VariableTypes {
	int instanceVariable; // 인스턴스 멤버 변수
	static int classVariable; // 클래스 멤버 변수

	public static void main(String[] args) {// 파라미터 변수

		int localVariable = 10; // 로컬 변수
		for (int i = 0; i < 100; i++) { // 로컬 변수
			System.out.println(i);
		}

	}

}
//


----------------------------------------------------
3.2 인스턴스 멤버 변수의 특징 

인스턴스 멤버 변수는 클래스 영역에 static 키워드 없이 
선언된 변수. 
인스턴스 멤버 변수는 객체가 만들어질 때 객체별로 생성된다. 
생성되는 위치는 객체 내부이기 때문에 힙 영역.
생성 시점에 타입별로 초기화가 된다. 
초기값은 배열에서 각 요소의 타입별 초기값과 동일 .

자료형 : 기본값 : 비고 
boolean : false
char : '\u0000' : 공백문자
byte,short,int : 0
long : 0L
float : 0.0f
double : 0.0 
참조형 변수 : null : 아무 것도 참조하지 않음 

인스턴스 멤버변수는 객체 내부에 생성되기 때문에 각 객체의 소속이다. 
따라서 변수를 사용 할려면 , 객체를 생성 메모리에 올린 후,
객체 이름으로 접근한다. 
인스턴스 멤버변수의 값은 객체마다 생성되기 때문에 객체별로 
고유한 값, 즉 상태를 가질 수 있다. 
ex)
Person person1 = new Person();
person1.name = "홍길동";
Person person2 = new Person();
person2.name = "임꺽정";


인스턴스 멤버변수가 메모리에서 삭제되는 시점은 객체가 없어지는 
가비지 컬렉션이 일어나는 시점. 따라서 프로그램에서 이 변수를 
임의로 삭제할 수는 없다. 


----------------------------------------------------
3.3 클래스 멤버 변수의 특징 

클래스 멤버변수는 static 멤버변수라고도 한다. 
ex)
public class Person {
static String scientficName = "Homo Sapiens";
String name;
}

클래스 멤버변수는 클래스 영역에 클래스가 로딩되는 시점에 메모리에 생성되므로 
개별 객체의 생성과는 무관. 이 변수는 소속이 객체가 아니라 클래스다.
클래스 멤버변수는 같은 클래스를 통해 만들어진 모든 객체가 공유하게 
되므로 공유 변수라고도 불린다. 
클래스 멤버변수 역시 생성시 타입별로 기본 초기화가 된다. 

클래스 멤버 변수에 접근시 클래스 이름으로 접근하자. 
객체를 생성하고 객체 이름으로 접근도 가능 하지만,
적절한 방법은 아님.
컴파일러는 "The static field[클래스이름.변수명]
should be accessed in a static way"
라는 경고 메시지를 보낸다. 

ex)
Person p = new Person();
p.scientficName = "객체를 통한 부적절한 변경";
//The static field Person.scientficName 
should be accessed in a static way
Person.scientficName = "클래스를 통한 적절한 변경";
}

static 멤버변수가 소멸되는 시점은 프로그램이 종료되는 시점.

----------------------------------------------------
3.4 로컬 변수 (지역변수)의 특징 

클래스의 영역 이외의 모든 중괄호 안에 선언되는 변수.
메서드나 생성자의 내부 또는 파라미터 그리고 초기화 블록의 내부에 
선언된 변수들. 
ex)
void call(String to) {//파라미터 변수 
String beep ="띠"; // 로컬변수 
for (int i = 0; i<3 ; i++) { //로컬변수 
System.out.println(beep);
}
//System.out.println(i); 
//이제 i는 메모리에서 삭제된 상태
}

변수가 선언된 행이 실행될 때 스레드별로 생성된 메모리의 스택 영역에
생성되고 해당 영역(중괄호)이 끝나면 자동으로 삭제된다. 
예제에서 call() 메서드가 호출되는 시점에서 파라미터인 로컬변수
to가 생성되고 이후 변수 beep가 생성된다. 

for 문이 실행되면서 변수 i가 메모리에 추가되고 반복문 내부에서 
사용할 수 있게 된다. 이 시점에 beep 역시 아직 스택 영역에 남아
있고 사용가능. for 문을 벗어나면, 변수 i는 삭제되고 사용할수 
없게 되고 메서드가 종료되면서 로컬 변수 beep, to 의 순서로
스택에서 삭제된다. 

주의.
자바의 로컬변수는 멤버변수와 달리 자동으로 초기화가 이뤄지지 않는다. 
따라서, 로컬 변수는 사용하기전에 반드시 명시적인 초기화가 필요하다. 
다음 처럼 변수 localVariable을 선언만 하고 값을 할당하지 않은
상태에서 출력할 경우 오류가 발생한다. 
ex)
int localVariable;
System.out.println(localVariable);
//The loca variable localVariable may 
not have been initialized .
----------------------------------------------------

4. 메서드 

4.1 메서드 정의와 필요성 

객체가 하는 동작을 프로그래밍 에서는 메서드라고 부른다. 
어떤 작없을 수행하는 명령문(코드)의 집합으로 표현. 
메서드 작성 이유
반복적으로 사용되는 코드의 중복을 방지하고
코드의 양을 줄여 유지 보수성을 향상하기 위함. 

실습5
ex) 
class Person {

//메서드의 선언 
void printInfo(){
System.out.println(name + ":" + age);
}
} //Person

//호출 
Person p = new Person();
p.printInfo();

//메서드의 선언 (name -> userName 한번만 변경하면된다. )
void printInfo(){
System.out.println(userName + ":" + age);
}

----------------------------------------------------
4.2 메서드 작성 

파라미터, 실행문, 리턴 값 

선언부, 구현부로 나눈다. 
ex)
//선언부
제한자 리턴_타입 메서드이름(타입변수_명, 타입변수_명...)
//구현부
{
// do something
}

(1)선어부:리턴_타입
리턴_타입은 메서드 호출의 결과로 메서드를 호출한 곳으로 
돌려주는 값의 타입을 지정한다. 
결과 받는 곳 묵시적형변환이 가능. 
예)
add() 메서드는 int를 리턴하는데 이 메서드를 호출한 곳에서 
int 받거나, int 보다 큰 타입인 double로 받을 수 있다. 
ex)
//add 메서드가 호출되면 int 타입의 값이 반환됨 
public int add(int a , int b) {
return a+b;
}

//add 호출 결과를 int 타입의 result1에 할당 
int result1 = add(100,200);
//add 호출 결과를 double 타입의 result2에 할당 
double result2 = add(100,200);
System.out.println(result1 + ":" + result2);
//300 : 300.0 

메서드의 호출 결과 아무것도 리턴하지 않을 경우는 리턴_타입
void 라고 쓴다. 이 경우는 아무런 값이 없으므로 메서드 
호출 결과를 변수에 값을 할당한다거나 출력할수 없다. 

ex)
//sayHello 메서드는 아무런 값을 반환하지 않음.
public void sayHello(){
System.out.println("Hello");
}
//System.ou.println(sayHello());
//메서드 호출 결과가 없으므로 출력할 수 없음. 

메서드는 호출 결과로 리턴_타입에 해당하는 하나의 데이터만을 
리턴한다. 

다음 예는 Coffee[] 타입에 여러 개의 Coffee 객체를 
담아서 리턴하는 모습. 
ex)
//하나의 Coffee 객체를 리턴함
public Coffee getCoffee(){
return new Coffee();
}

public Coffee[] getCoffee(){
// 두 개의 Coffee 객체가 담긴 Coffee[] 배열 하나를 리턴함 
return new Coffee[] {
new Coffee(),new Coffee()};
}

다른 문제 , 동일 타입의 데이터만 리턴 가능하다. 
커피와 케이크를 주문 한다면?
타입이 달라 배열로 대체 안된다. 
이 때, 클래스 타입을 리턴 가능. 
클래스에 여러 개의 멤버 변수를 선언할 수 있음 기억.
다음 예 
Coffee 와 Cake 타입을 멤버 변수로 갖는 CoffeeSet 클래스 
정의하고, getCoffeeSet() 메서드에서 CoffeeSet을 리턴하는 형태 

ex)
class Coffee{}
class Cake {}
class CoffeeSet {
Coffee coffee;
Cake cake;
}

public CoffeeSet getCoffeeSet(){
return new CoffeeSet();
}

CoffeeSet set = getCoffeeSet();
System.out.println(set.coffee + ":" +set.cake);

이를 응용하여 로그인 시스템 만들어 보기.
아이디와 비밀번호를 사용자로부터 입력받아 로그인 성공 여부를 
true/false의 boolean 값으로 리턴한다. 
로그인에 실패 실패 이유를 String으로 리턴.
리턴 데이터는 boolean과 String으로 두가지.
아이디가 admin이고 비밀번호가 1234이면 로그인 성공.

로그인 시스템은 LoginResult , LoginSystem, 
LoginTest 3개의 클래스로 구성. 

먼저, LoginResult 클래스 만들기. 
이 클래스는 로그인 결과를 담아서 리턴한다.
로그인 결과는 성공여부(boolean)와 실패이유(String)
가져야 한다. 
클래스는 boolean 타입의 result와 String 타입의 
message를 멤버 변수로 갖는다. 
추가로 로그인 정보를 출력할 수 있는 메서드 
printResult()를 만들자. 
!

실습6
ex1)
package ch06.login;

public class LoginResult {
	boolean result;
	String message;

	public void printResult() {
		System.out.println(this.result + " : " + this.message);
	}
}

두번째 클래스는 LoginSystem.
로그인을 처리하는 doLogin() 메서드를 작성한다. 
doLogin() 에서는 String 타입의 id와 pass를 
파라미터로 받아서 각각 admin, 1234 와 비교 후 결과를 
LoginResult에 설정해서 리턴한다. 
    리턴되는 LoginResult 객체의 상태 
상황 : result : message
아이디/비밀번호 모두 맞음 : true : 반갑습니다.
아이디가 잘못된 경우 : false(기본값) : 아이디를 확인하세요.
비밀번호가 잘못된 경우 : false(기본값) : 비밀번호를 확인하세요. 

실습7
ex2)
package ch06.login;

public class LoginSystem {
	public LoginResult doLogin(String id, String pass) {
		LoginResult result = new LoginResult();
		if(id=="admin" && pass=="1234" ) {
			result.result = true;
			result.message=id+"님 반갑습니다.";
		}else if(id!="admin") {
			result.message = "아이디를 확인하세요.";
		}else {
			result.message="비밀번호를 확인하세요.";
		}
		return result;
	}
}

마지막 이 시스템을 사용하는 주체 LoginTest 클래스 
main() 메서드에서 LoginSystem 타입의 객체를 만들고 doLogin()
메서드를 사용 

실습8
ex3)
package ch06.login;

public class LoginTest {
	public static void main(String[] args) {
	    LoginSystem login = new LoginSystem();
	    LoginResult result = login.doLogin("hong", "1234");
	    result.printResult();
	    //false : 아이디를 확인하세요.

	    result = login.doLogin("admin", "12345");
	    result.printResult(); // false : 비밀번호를 확인하세요.

	    result = login.doLogin("admin", "1234");
	    result.printResult();// true : admin님 반갑습니다.
	  }
}

(2) 선언부 : 메서드 이름 
메서드 이름은 메서드를 호출할 때 사용하며 메서드에서 수행하는 
작업의 내용을 한눈에 파악하기 쉽게 의미 있는 단어를 이용하는게 좋다. 
기본적인 명명규칙은 변수의 명명규칙과 동일 

(3) 선언부: 파라미터 목록 
일반적인 변수를 선언하는 것처럼 변수의 타입과 변수명을 나열해서 
파라미터를 설정.
단, 선언만 가능하고 값 할당은 안됨.
파라미터값 전달은 호출되는 시점에

메서드가 호출되기 위해서는 선언된 파라미터와 동일한 개수의 파라미터가
제공되어야 하고, 묵시적형변환이 가능. 

ex) 
//메서드를 호출하기 위해 long과 long이 필요 
public long add(long a, long b){
return a + b;
}

add(10L, 20L); //적절 
add(100, 200); //적절 :묵시적형변환이 진행 
add(1.1, 2.2); //부적절 : long 에 double 할당 불가
add(100, 200 , 300); 
//부적절 : 파라미터의 개수가 다름 
add(100); 
//부적절 : 파라미터의 개수가 다름 

(4) 선언부:가변인자(Variable arguments)
메서드는 호출될 때 파라미터가 일치 해야 한다. 
만약, 더해야 하는 숫자의 개수가 다양한 경우,
파라미터 개수에 맞춰 메서드를 작성한다. 
대안 
배열을 파라미터로 받는다면 배열의 크기에 따라 더하기 가능.
하지만, 배열은 초기화하고 값을 할당하기 번거롭다.

이때 가변인자를 사용하면 이런 불편함을 해소해줄수 있다. 
내부적으로 사용하는데 별도의 초기화 과정이 필요 없고 
값을 할당할 때 단순히 나열해주기만 하면 된다. 
가변인자 표현 방식은 파라미터 타입과 변수명 사이에 
... 으로 표시.
의미 선언한 데이터 타입의 변수가 0개 이상 올수 있다. 

실습9
ex)
package ch06.method;

public class VariableArgsTest {

	public void add(int... params) {
		int sum = 0;
		for (int i : params) {
			sum += i;
		}
		System.out.printf("파라미터 개수: %d, 총 합: %d%n",params.length,sum);
	}
	
	public static void main(String[] args) {
		VariableArgsTest vt = new VariableArgsTest();
		vt.add(1, 2, 3, 4, 5);
		vt.add(1, 2, 3);
		vt.add();
	}

}
//
파라미터 개수: 5, 총 합: 15
파라미터 개수: 3, 총 합: 6
파라미터 개수: 0, 총 합: 0

(5)구현부 
중괄호{ } 내에서 처리해야 할 내용 즉 비즈니스 로직을 구성. 
구현부의 맨 마지막에는 선언된 리턴 타입에 해당하는 값을 return
문장과 함께 반환해야 한다. 
단 반환할 값이 없는 경우, 즉 리턴 타입이 void 인 경우는 
return 문장을 생략한다. 
값을 반환할때는 묵시적 형변환이 적용된다. 
즉 int를 리턴하기로 했을 때 int 보다 작은 byte,short,char
타입의 값도 리턴 가능하다.

예) int 리턴하도록 작성된 getNumber()에서 char 타입을 
리턴하는 예.
public int getNumber(){
return 'A';
}

메서드 수행 도중 return 문장을 만나거나 메서드의 마지막 문장을 
실행하면 메서드는 종료한다. 조건문 내에서 return을 사용하는 경우 
모든 조건에서 return 될수 있도록 주의.
각각의 조건에 따라 return 문장을 작성할수도 있지만,
조건에 맞게 값을 수정한 후 맨 마지막에 한 번만 반환하는 것도 
좋은 방법. 
예) 상황에 따라 매번 리턴하는 경우와 
상황에 따라 값만 바꾼 후 한번 리턴하는 형태 
비교

ex)
public double calc(double a, double b, char oper){
if (oper == '+'){
return a+b; // 조건별 결과값 반환 
}else if (oper == '-'){
return a-b;
}else{
return 0;
}
}

public double calc2(double a, double b, char oper){
double result = 0; //기준값 설정 
if (oper == '+'){
return a+b; // 로직에 따라 기준값 변경 
}else if (oper == '-'){
return a-b;
}
return result; // 기준값 반환 
}
}

----------------------------------------------------
4.3 메서드 호출

static 과 non-static 멤버 비교 
비고	:	static 멤버 : non-static 멤버 
소속	:	클래스		: 객체 
접근방법 같은 클래스 : 바로호출 : 바로호출 
접근방법 다른 클래스 : 클래스_이름.멤버_이름 : 객체_이름.멤버_이름 

중요한 점 : 호출하려는 멤버가 메모리에 있는가?
메모리에 있는 멤버는 소속(클래스 또는 객체)을 통해 
호출할 수 있고, 그렇지 않으면 먼저 객체를 생성해 메모리에 로딩 후 
사용한다 

static 붙은 메서드 : 클래스 메서드, 정적 메서드 
항상 메모리에 있다. 
같은 클래스 내에서 호출시 클래스 이름도 필요 없다. 

다음 예 두개의 클래스에서 서로의 멤버를 호출하는 다양한
상황을 보자 
ex)
public class First{
static int cv; //(1)
int iv; // (2)
static void cMethodA() {}//(3)
static void cMethodB() {}//(4)
void iMethodA() {} //(5)
void iMethodB() {} //(6)
void iMethodC() {} //(7)
void iMethodD(Second s){}//(8)
}

class Second{
static void cMethod() {} // (9)
void iMethod() {} // (10)
}
보기 
a: Second.cMethod(); s.iMethod();
b: cv = 100; cMethodB();
c: First f = new First(); f.iv=10; f.iMethodA();
d: iv = 100; iMethodA();
e: cv = 100; cMethodA();
f: Second.cMethod(); Second s = new Second();
s.iMethod();

문1) (3)의 구현부에서 (1)과 (4)를호출 할려면?
답: b: cv = 100; cMethodB();
//static 이므로 이미 메모리에 올라가 있다. 다행히 (1)과 (4) 역시 
같은 클래스에 있는 static이므로 바로 호출하여 사용할수 있다. 

문2) (4)의 구현부에서 (2)과 (5)를호출 할려면?
답: c: First f = new First(); f.iv=10; f.iMethodA();
//(4)는 static이므로 메모리에 있지만 (2) 와 (5)는 non-static이므로 
아직 메모리에 없다. 따라서 같은 클래스에 있더라도 먼저 객체를 만들고 
객체를 통해서 접근해야 한다. 따라서 먼저 First 객체를 생성하고 접근. 

문3) (5)의 구현부에서 (1)과 (3)를호출 할려면?
답: e: cv = 100; cMethodA();
//non-static 이다. (1)과(3) 은 static으로 이미 메모리에 있으므로 바로 호출. 

문4) (6)의 구현부에서 (2)과 (5)를호출 할려면?
답: d: iv = 100; iMethodA();
//non-static 이며 (2)와 (5)도  non-static이다. (6)이 호출되는 시점에 
객체가 만들어 졌을 것이고, 이때 (2)와(5)도 함께 로딩되었을 것이다. 
소속이 같으므로 별도의 참조값은 필요 없다. 

문5) (7)의 구현부에서 (9)과 (10)를호출 할려면?
답: f: Second.cMethod(); Second s = new Second();
s.iMethod();
//(9) 와(10) 는 (7)과 다른 클래스이다. (9)는 static이므로 클래스 이름으로 
접근할수 있고 (10)은 non-static이므로 먼저 객체를 만들고 호출해야한다. 

문6) (8)의 구현부에서 (9)과 (10)를호출 할려면?
답: Second.cMethod(); s.iMethod();
//(8)에는 Second에 대한 참조값이 파라미터로 전달되고 있어서 이를 이용해 
(10)를 호출할수 있다. 물론 (9)는 static이므로 클래스 이름으로 접근할수 있다. 

주의 문4) (6) 문6) 파라미터 값 주의 

(1) 메서드 호출 스택 
스택? 순차적으로 데이터를 쌓는 구조.
입구 = 출구 같다. FILO(First In Last Out) 
LIFO(Last In First Out ) 

메서드 호출 과정에서 메서드 호출 스택을 구성.
메서드를 쌓는다는 개념. 

모든 메서드는 호출 할 때마다 메서드 동작을 위한 메모리 상자를
하나씩 할당 받음.
상자 내부에는 메서드에서 사용되는 파라미터 변수 등 로컬 변수들이 저장. 
외부에서 상자에 접근 못함. 로컬변수들은 메서드 내부에서만 접근.

만약 A 메서드가 최초 호출. 스택 메모리영역에 A를 위한 상자 생성.
A에서 새로운 B 메서드 호출시 B 실행을 위한 메모리 상자를 A위에 
쌓는다. 
항상, 맨 위에 있는 상자만 동작한다는 점을 기억. 
이 때 A는 잠시 정지. 만약, B 메서드가 종료(return)하게 되면 
B 메서드를 위한 메모리 상자가 제거되고 메모리를 반납한다. 
다시 A가 최상위 메서드가 되어서 나머지 동작을 수행. 

실습10
ex)
package ch06.method;

public class MethodCallStack {
	public static void main(String[] args) {
		MethodCallStack mcs = new MethodCallStack();
		mcs.aMethod();
	}

	public void aMethod() {
		System.out.println("aMethod start");
		int age = 10;
		bMethod(age); // 새로운 메서드 상자 요청
		System.out.println("aMethod end");
	}

	public void bMethod(int age) {
		System.out.println("bMethod start");
		System.out.printf("나이는: %d%n", age);
		System.out.println("bMethod end");
	}
}
//
aMethod start
bMethod start
나이는: 10
bMethod end
aMethod end

(2) 기본형 변수와 참조형 변수의 전달 차이 

변수의 값이 파라미터로 전달될 때 기존의 값이 복사되어 전달. 
기본형 변수는 변수에 저장되는 것이 값 자체이고 
참조형 변수는 실제 객체가 아니라 객체에 대한 참조값이다. 

실습11
ex)
package ch06.method;

public class CallByTest {
	int memberVar = 10;

	static void change1(int var) {
		var += 10;
		System.out.printf("change1 : %d%n", var);
	}

	static void change2(CallByTest cbtl) {
		cbtl.memberVar += 100;
		System.out.printf("change2 : %d%n", cbtl.memberVar);
	}

	public static void main(String[] args) {
		CallByTest cbt = new CallByTest();
		cbt.memberVar = 5;
		System.out.printf("change1 호출 전 memberVar: %d%n", cbt.memberVar);
		
		change1(cbt.memberVar);
		System.out.printf("change1 호출 후 memberVar: %d%n", cbt.memberVar);

		change2(cbt);
		System.out.printf("change2 호출 후 memberVar: %d%n", cbt.memberVar);
	}
}
//
change1 호출 전 memberVar: 5
change1 : 15
change1 호출 후 memberVar: 5
change2 : 105
change2 호출 후 memberVar: 105



----------------------------------------------------
4.4 메서드 오버로딩

(1) 메서드 오버로딩이란?
단순 의미: 동일한 기능을 수행하는 메서드를 추가로 작성. 
메서드 오버로딩과 뒤에 나올 메서드 오버라이딩 구분하기.

메서드의 파라미터 값이 다른 메서드는 각각 다른 메서드이다. 
ex)
println 메서드 
System.out.println(1);
System.out.println('C');
System.out.println("hi");
각각 다른 메서드 
public void println(int x)
public void println(char x)
public void println(String x)

(2)메서드 오버로딩 방법 
동일 메서드에 파라미터의 개수 또는 파라미터의 타입을 다르게 작성. 

ex1)
add 메서드를 오버로딩 경우. 
//기본메서드 
int add(int a, int b) {
return a+b;
}
double add(double x, double y) {
return x+y;
}
int add(byte a, byte b){
return a + b;
}

ex2)
//파라미터의 이름만 다른 것은 의미 없음
int add(int x, int y) {
return x+y;
}
//리턴타입만 다른 것은 의미 없음
long add(int a, int b) {
return a+b;

ex3)
long add(long a, int b) {
return a+b;
long add(int a, long b) {
return a+b;

add(3,4)로 호출 하면 , 어떻게 되나?
중복 되어 오류 발생. 각각 자동 형변환이 일어남. 

(3) 메서드 오버로딩과 코드의 재사용 

예)
walk() 메서드.
walk(int distance) 오버로딩 
walk(int distance, String unit) 오버로딩 

실습12
ex)
package ch06.overloading;

public class WalkTestBad {
	void walk() {
		System.out.println("100cm 이동");
	}

	void walk(int distance) {
		System.out.println(distance + "cm 이동");
	}

	void walk(int distance, String unit) {
		switch (unit) {
		case "cm":
			break;
		case "inch":
			distance *= 2.54;
			break;
		default:
			System.out.println("unknown");
			distance = 0;
		}
		System.out.println(distance + "cm 이동");
	}
	public static void main(String[] args) {
		WalkTestBad wtb = new WalkTestBad();
		wtb.walk();
		wtb.walk(100);
		wtb.walk(100,"cm");
	}
}
//
100cm 이동
100cm 이동
100cm 이동

중복 코드 제거 System.out.println

실습13
ex2)
package ch06.overloading;

public class WalkTestGood {
	void walk() {
		walk(100, "cm");
	}

	void walk(int distance) {
		walk(distance, "cm");
	}

	void walk(int distance, String unit) {
		switch (unit) {
		case "cm":
			break;
		case "inch":
			distance *= 2.54;
			break;
		default:
			System.out.println("unknown");
			distance = 0;
		}
		System.out.println(distance + "cm 이동");
	}

	public static void main(String[] args) {
		WalkTestGood wtg = new WalkTestGood();
		wtg.walk();
		wtg.walk(100);
		wtg.walk(100,"cm");

	}

}
//
100cm 이동
100cm 이동
100cm 이동

메서드 안에서 또 메서드 호출 했음.

----------------------------------------------------
5. 생성자 

5.1 생성자의 형태 

생성자란 객체를 생성할 때 호출하는 메서드 비슷한 것을 말하는데
지금까지 new 키워드와 함께 호출했었다.
생성자에서는 주로 일반 멤버 변수의 초기화나 객체를 생성할 때
실행하는 작업을 정리한다. 

생성자는 메서드처럼 선언부와 구현부로 나뉘지만 선언부에서 
리턴타입 없고 이름은 클래스 이름과 똑같이 써야 한다. 

ex)
//선언부
제한자 클래스_이름(타입변수_명, 타입변수_명...)
{
//멤버 변수 초기화 작업 구현부
}

class Person{
String name;

public Person(){
name = "홍길동";
}
// 생성자에서는 주로 일반 멤버 변수의 초기화

----------------------------------------------------
5.2 생성자의 종류 

파라미터 유무에 따라 기본 생성자 , 파라미터 생성자 

(1) 기본생성자
파라미터가 없고, 구현부가 비어 있는 형태.
생성자 만든적 없는데 어떻게 호출?
만들지 않았을 때, 컴파일러에 의해 컴파일 타임에 자동으로 삽입.
주의. 별도의 생성자를 만들지 않을 때 생성.!!
일단 빈 객체를 생성 후 객체의 멤버 변수들을 별도로 설정.

실습14
ex)
package ch06.constructor;

public class DefaultPerson {
	String name;
	int age ;
	boolean isHungry;
	
	//public DefaultPerson() {} -- 생략된 기본 생성자

	public static void main(String[] args) {
		DefaultPerson person = new DefaultPerson();
		person.name = "홍길동";
		person.age = 10;
		person.isHungry = false;
	}
	
	void test() {
		new DefaultPerson();
	}
}

(2)파라미터 생성자
생성자가 파라미터 받는 형태.
주로 멤버변수 초기화에 사용.

ex)
package ch06.constructor;

public class ParameterPerson {
	String name;
	int age;
	boolean isHungry;

	// 생성자의 역할 : member 변수의 초기화..
	ParameterPerson(String n, int a, boolean i) {
		name = n;
		age = a;
		isHungry = i;
	}

	public static void main(String[] args) {
		ParameterPerson person = new ParameterPerson("홍길동", 10, true);
		//ParameterPerson p2 = new ParameterPerson();
		//파라미터 값 없는 생성자가 없어서 , 객체 생성 안됨.
		//기본생성자가 없을 때, 시스템에서 자동으로 만들어줌. 
	}
}


----------------------------------------------------
5.3 this의 용법 
this. this()
알아보기.

(1)객체를 참조하는 this 

현재 객체를 참조하기 위한 용도.
ex)
ParameterPerson(String name, int age, boolean isHungry) {
		name = name;
		age = age;
		isHungry = isHungry;
		
파라미터 이름을 멤버변수의 이름과 동일. 오류는 아니지만,
이것을 구분 하기 위해 this 사용. 
this는 참조변수로 나중에 메모리에 생성되는 객체 자신을 가리킴.

실습15
ex2)
package ch06.constructor;

public class ThisPerson {
	String name;
	int age;
	boolean isHungry;


	
	ThisPerson(String name, int age, boolean isHungry) {
		this.name = name;
		this.age = age;
		this.isHungry = isHungry;
	}

	String getPersonInfo() {
		return String.format("name: %s, age: %d, isHungry: %b", this.name, this.age, isHungry);
	}
	
	public static void main(String[] args) {
		ThisPerson person = new ThisPerson("홍길동", 20, true);
		System.out.println(person.getPersonInfo());
	}
}
//
name: 홍길동, age: 20, isHungry: true

this 는 객체에 대한 레퍼런스(참조값)이기 때문에 객체가 생성되기
전에는 사용할수 없다. 
static 영역에서는 this 키워드 사용 못함. 

(2) 다른 생성자를 호출하는 this 

파라미터를 다르게 해서 여러개의 생성자를 정의하는 것을 생성자 오버로딩.
오버로딩 에서 중복 코드 발생하여 다른 메서드 호출.
생성자에서도 중복 코드를 제거하기 위해 다른 생성자 호출 할 때 사용 this 

실습16
ex)
package ch06.constructor;

public class OverloadConstructorPerson {
	String name = "아무개";
	int age = 0;
	boolean isHungry = false;

	OverloadConstructorPerson(String name, int age, boolean isHungry) {
		this.name = name;
		this.age = age;
		this.isHungry = isHungry;
	}
	OverloadConstructorPerson(String name, int age){
		this(name, age, false);
	}

	OverloadConstructorPerson(String name) {
		this(name, 0, false);
	}

	OverloadConstructorPerson() {
		//System.out.println("first line");
		this("홍길동", 100, false);//Constructor call must be the first statement in a constructor 
	}
}
//
주의 
this 를 통한 생성자 호출은 생성자의 맨 처음 행에서만 가능. 


----------------------------------------------------
5.4 이클립스 에서 위저드를 이용한 파라미터 생성자 작성 

코드 편집창에서 우클릭- Source->Generate Constructor
Using Fields] 메뉴 선택.


----------------------------------------------------
6. 초기화블록

6.1 초기화블록의 특징  

객체의 초기화에 초기화 블록이 사용.
클래스 영역에 중괄호를 이용해 작성되며 이름이 없다. 
코드에 의해 호출 될수 없다. 
목적 멤버변수 초기화.
객채 생성 할수 없고, 파라미터를 받을수 없다.
외부에서 값을 받아서 멤버 변수에 할당도 못한다. 
초기화 과정에서 복잡한 로직이 들어가는 경우 사용한다. 

ex)
int iv;
static int cv;
static{
System.out.println("클래스 초기화 블록: static 멤버변수 초기화");
cv = 100;
}
{
System.out.println("인스턴스 초기화 블록: 인스턴스 멤버변수 초기화");
iv = 100;
}

----------------------------------------------------
6.2 초기화블록의 종류 

클래스 초기화 블록, 인스턴스 초기화 블록 
클래스초기화블록은 static 키워드가 추가된 초기화블록으로 
클래스 멤버 변수의 초기화에 사용. 클래스가 로딩될 때 JVM에 의해 
1회만 호출. 특정 객체 상관 없다. 

인스턴스 초기화블록 static 키워드가 없으며 인스턴스 멤버변수의 
초기화에 주로 사용. 
객체를 생성할 때마다 한 번씩 호출된다.
주의 생성자 보다 먼저 호출. 
ex)
객체생성 -> new 사용 -> 인스턴스 초기화블록 -> 생성자 코드. 

실습17
ex2)
package ch06.initializer;

public class InitializerTest {
	int iv;
	static int cv;

	static {
		System.out.println("static initializer");
		cv = 100;
	}

	{
		System.out.println("instance initializer");
		iv = 100;
	}

	public InitializerTest() {
		System.out.printf("constructor iv: %d, cv: %d%n", iv, cv);
		this.iv = 300;
	}

	public static void main(String args[]) {
		InitializerTest it = new InitializerTest();
		System.out.printf("객체 1 생성 후- cv: %d, iv: %d%n",InitializerTest.cv, it.iv);
		InitializerTest it2 = new InitializerTest();
		System.out.printf("객체 2 생성 후- cv: %d, iv: %d%n",InitializerTest.cv, it2.iv);
	}
}
//
static initializer
instance initializer
constructor iv: 100, cv: 100
객체 1 생성 후- cv: 100, iv: 300
instance initializer
constructor iv: 100, cv: 100
객체 2 생성 후- cv: 100, iv: 300


----------------------------------------------------
7 JavaDoc 주석 작성

자바의 도큐멘테이션 형태의 문서를 만드는데 사용하는 주석을 말한다. 
프로젝트 수행하면 대부분 메서드, 클래스의 용도가 무엇인지 설명을
문서로 남기는데 아주 번거롭다.
JavaDoc 주석을 이용해서 평소에 주석을 작성해 놓으면, 
편하게 문서를 생성할수 있다. 
Javadoc 주석은 클래스, 멤버변수, 메서드, 생성자에 대해 
/** 와 */ 사이에 주석 내용을 작성한다. 
ex)
package ch06.javadoc;
/**
 * 이 클래스는 자바의 도큐멘테이션 주석을 테스트하기 위한 클래스이다.
 * @author itsme
 *
 */
public class JavaDocTest {
	/**
	 * 멤버 변수에 대한 주석
	 */
	public int memberVar;

	/**
	 * 기본 생성자이다.
	 */
	public JavaDocTest() {
		System.out.println("기본 생성자");
	}
	
	/**
	 * 멤버 메서드에 대한 주석
	 * @param num	memberVar에 곱해지는 수
	 * @return		num과 memberVar의 곲을 리턴한다.
	 */
	public int multiPlyMemberVar(int num) {
		return memberVar * num;
	}
}

아직 생성된 것은 아니다. 

Java 가 설치된 경로의 bin 디렉터리에 있는 javadoc.exe 사용. 

1
해당 폴더 이동 .
ex)git이 할당이 된 폴더 위치
cd C:\Users\pc\git\java-kame
2
javadoc -encoding utf-8 -sourcepath ./src -subpackages ch06.javadoc -d ./mydoc

-encoding 옵션은 한글 데이터 처리를 위해 추가 
-sourcepath 옵션은 소스 파일의 위치를 나타내고 
-subpackages는 javadoc 을 생성할 패키지를 나열 
-d 옵션은 결과물을 출력할 디렉토리를 의미.

mydoc 디렉토리 생성되고, 그 안에서 여러 html 파일들이 있다. 
그중 index.html 더블 클릭하면 클래스 목록이 나오고 
JavaDocTest 클릭하면 소스코드에 대한 입력한 주석들을 문서로 확인 가능. 

3 이클립스를 통해서 간편하게 javaDoc 만들기 

이클립스 메뉴 - Project - Generate Javadoc 선택.

기본 선택하고 ,
옵션에서 
-encoding UTF-8
입력.


----------------------------------------------------
8. UML을 이용한 클래스 표현 

8.1 UML 소개 

Unified Modeling Language 의 약자.
표준화된 모델링 표기 체계를 이야기한다. 

클래스를 만들기 전에 이렇게 만들면 어떻까?
모델링 단계에서 사용.
클래스 이름, 속성의 이름, 타입, 메서드 이름,
파라미터, 리턴타입등 글보다는 그림을 그리는 방식 
표준화.

특징 
-가시화: 설계 내용을 가시적인 그래프 형태로 작성해서
이해 관계자 간의 의사소통 자료로 사용. 
-명세화: SW 개발 단계의 각 과정에 필요한 모델을 정확하고 완전하게
명세 
-구축화: 다양한 객체지향 프로그래밍 언어로 변환 가능 
(순공학, 역공학 적용)
-문서화 : 프로젝트 참여자들 간의 통제, 평가 및 
의사소통에 필요한 문서화 가능. 

순공학(Forward Engineering)
요구사항 정의 -> 분석 -> 설계 -> 구현 의 단계 
개발하는 것으로 일반적인 개발 절차를 말함. 
반대로 
역공학(Reverse Engineering)
구현->설계->분석->요구사항 정의 
만들어진 시스템을 역추적해서 처음의 문서, 
설계기법 등의 자료를 얻어내는 과정. 

----------------------------------------------------
8.2 클래스 다이어그램 

클래스의 구성 요소와 클래스 간의 관계를 묘사하는 
다이어그램.
클래스의 구성요소를 나타낼 때는 박스 모델을 이용해 
클래스 이름 및 멤버 변수, 멤버 메서드를 작성. 
클래스 간의 관계를 표현할 때는 선을 이용해 상속이나 
구현, 포함 등을 표시. 
하나의 클래스를 어떻게 클래스 다이어그램으로 표현하는지 보고,
나머지는 7장에서. 

클래스를 표현할 때 최상단의 박스에 클래스 이름을 표기.
필요에 따라 패키지 이름까지 표기.
멤버변수를 표시할 때 가시성(visibility), 변수의 
이름과 타입, 기본값을 정의.
가시성은 접근 제어자로 
public(+), protected(#),default(생략)
private(-) 4가지 레벨로 조절. 
용도는 7장에서 보기.

ex) ParameterPerson 클래스 에 대한 다이어그램으로
작성. 
ParameterPerson
name:String
age:int
isHungry:boolean
ParameterPerson(n:String, a:int, i:boolean)
+main(args: String[]):void 
!
@
설치 해보기.
StarUML Setup 3.0.2.exe 


===================================
[자바 해바라기 정리] 7 클래스의 관계
실습 27

1. 상속 

상속, 데이터 은닉과 보호, 다형성의 개념을 통해 어떻게 
클래스 간의 관계를 맺고 프로그램의 유지보수성을 향상 
시킬수 있는지 알아보자. 

1.1 상속의 정의와 구현 

Inheritance 상속, 중요한 개념.
ex) 부모의 재산을 상속,

자바에도 상속. 프로그램에서 상속은 기존 클래스의 재산을 
다른 클래스에서 재사용하기 위한 것.
재산: 기존 클래스에 있던 멤버(변수와 메서드)를 이야기.
생성자와 초기화블록은 상속의 대상 아니다. 

상속 물려주는 클래스 , 조상클래스, 부모클래스, 상위클래스,슈퍼클래스
라고 한다. 
상속 받는 클래스를 자식클래스, 자손클래스, 하위클래스, 서브클래스
라고 한다. 
상속의 관계를 UML 표시 하기 위해서는 실선의 화살표를 이용. 

ex) Person class, 를 상속받은 SpiderMan class 표현 

SpiderMan class -> Person class 

상속 관계 이야기 할 때, "is ~ a 관계"라 함. 
SpiderMan 은 Person의 모든 멤버를 가지고 있어서,
'SpiderMan is a Person'의 관계가 성립한다. 

상속받은 클래스는 물려받은 멤버들을 자신의 것처럼 
사용할 수 있고, 코드의 절감 효과.
부모코드를 변경하면 모든 자식 클래스들에게도 
적용되므로 유지보수성이 좋다. 

문법 
자식클래스 선언부에서 extends 키워드와 함께 조상클래스 이름 표시.
ex) class child_class_name extends super_class_name 

UML을 코드로 옮겨 보기. 
기본 Person class, 하나의 멤버 변수(name), 두개의 method (eat(), jump())
선언. 

실습1
ex)
package ch07.extend;

public class Person {
	String name;
	
	public void eat() {
		System.out.println("밥 먹기");
	}
	public void jump() {
		System.out.println("뛰기");
	}
}

Person을 상속받은 SpiderMan class ,
SpiderMan 은 추가로 boolean 타입의 변수 
isSpider와 fireWeb() 메서드를 작성한다. 

실습2
ex2)
package ch07.extend;

public class SpiderMan extends Person {
	boolean isSpider;

	public void fireWeb() {
		System.out.println("거미줄 발사");
	}
}

Person을 상속 받아서 SpiderMan이 가질 수 있는 멤버의
개수는 총5개.
부모클래스 Person에서 물려받은 멤버3개, 자식인 SpiderMan
에 선언된 고유 멤버 2개.

----------------------------------------------------
1.2 다양한 관계

(1)상속과 Object class
멤버를 확인하기 가장 좋은 방법은 객체를 만들고,
'.'(dot)을 통해서 객체가 접근 할수 있는 요소 확인방법.

SpiderManTest 라는 class 만들고 main 메서드에서 
SpiderMan 타입의 객체(sman)을 만든후 ,  어떤
멤버에 접근하는지 확인.
'sman.'까지 입력후 ctrl+space 입력.
Code Assist 동작. 팝업 표시 .

▲ fireWeb() : void - SpiderMan
▲ :접근 제한자 
fireWeb()  : 멤버이름 
void : 타입 또는 리턴_타입 
SpiderMan : 소속 class

접근 제한자는 뒤에서.

boolean 을 리턴하는 equals() method는 소속이 
느닷없이 Object로 나옴. 의외?

Object는 자바에서 아주 중요한 class. 
모든 class의 조상 class , 만약 class 선언부에 
명시적인 extends 선언이 없는 경우 무조건 
extends Object 코드 생략된거다. 
Person 도 별도의 extends가 없어서 생략 되었음. 

UML 로 표현. 

SpiderMan class -> Person class -> Object class
Person은 Object를 상속 받아서 Object의 모든 
멤버를 물려 받았고, 
SpiderMan은 Person을 상속 받아서,
Person , Object 의 멤버를 모두 가지고 있다. 
Object를 뒤에서 

(2) 단일 상속 지원 
SpiderMan class -> Person class-> Object class
Employee class-> Person class-> Object class

SpiderMan 과 Employee 는 형제? 그런거 없음. 

하나의 class를 여러 class가 상속받는 것 문제 안됨.
다중 상속은 안됨.

만약, 다중 상속을 받는 다 하면, 두 class의 같은 method
를 호출시 문제.
이런 문제를 극복하기 위해, 나중에 interface 포함 관계 사용. 

(3)포함관계
연관 관계 또는 'has a' 관계로 불린다. 
상속 이외의 클래스를 재활용하는 방법. 
상속 받고, 나머지 class들은 멤버 변수로 처리해서 
사용하는 것.
UML 로 실선이 포함관계.
ex)
Spider class --- SpiderMan class -> Person class

멤버변수로 다른 객체를 갖게되면 필요할 때 
해당 객체의 속성과 기능을 사용할 수있다. 
즉 거미줄 발사하고 싶으면 Spider 타입의 멤버변수가 
가지고 있는 fireWeb() 메서드를 호출하면된다. 

실습3
ex2)
package ch07.extend;

public class Spider {
	public void jump(){
		System.out.println("키 * 1000만큼 엄청난 점프");
	}
	
	public void fireWeb(){
		System.out.println("거미줄 발사");
	}
}

실습4
ex3)
package ch07.extend;

public class SpiderMan2 extends Person {
	Spider spider = new Spider();
	boolean isSpider;

	public void fireWeb() {
		if (isSpider) {
			spider.fireWeb();
		} else {
			System.out.println("Person은 거미줄 발사 불가");
		}
	}

	@Override
	public void jump() {
		if (isSpider) {
			spider.jump();
		} else {
			//System.out.println("뛰기");
			super.jump();
		}
	}
}

SpiderMan2는 Spider를 'has a' 관계로 포함하면서
Spider class 에 있는 기능, 속성들을 사용가능.
Spider의 코드를 수정하면 자동으로 SpiderMan2도
변경된 코드를 사용하므로 유지보수성이 좋다. 

어떤 class를 포함하는게 좋을까? 상속?
'is a', 따져보고, 프로젝트 관점에 따라 다르다.

----------------------------------------------------
1.3 메서드 오버라이딩

ex) 3대 걸친 맛집.
조상이 물려준 방식대로만 요리 안한다. 
자식들이 새로운 요리법을 만든다.

조상클래스에 정의된 기능을 자식클래스에 적합하게
수정해서 재정의하는 것을 메서드 오버라이딩
overriding: 재정의 

오버로딩 추가 적재(메서드 추가)
오버라이딩 기존 메서드 재정의 개념.
기존 메서드위에 덮어쓰기 개념.

메서드 오버라이딩 5개 규칙
1) 메서드 이름은 조상클래스의 메서드 이름과 같아야한다.
2) 매개변수 개수,타입, 순서는 조상클래스의 메서드와 같아야한다.
3) 리턴타입은 조상클래스의 메서드와 같아야한다
4) 접근제한자는 조상클래스의 메서드보다 범위가 같거나
넓어야 한다. 
5) 조상클래스의 메서드보다 더 상위의 예외를 던질수없다.

4),5) 잠시 보류.
선어부 동일하고, 구현부만 다시 작성하는 것.

Person class 에 jump 기능을 정의.
SpiderMan은 처음부터 jump 할수 있었다.
그러나, Person의 jump는 두 다리로 뛰는 것.
SpiderMan이 멤버로 가진 Spider는 키의 1000배 만큼 뛰다.
이것을 활용. 

따라서  SpiderMan2는 과감하게 조상인 Person이 물려준 
jump()를 재정의해서 평상시에는 사람처럼 뛰다가,
isSpider가 true인 상황에서는 Spider의 jump()를 사용. 

SpiderMan2의 jump() 동작을 보자.
main()에서 SpiderMan2 객체를 만들고 jump를 호출 .

실습5
ex)
package ch07.extend;

public class SpiderManTest2 {

	public static void main(String[] args) {
		SpiderMan2 sman = new SpiderMan2();
		System.out.println("거미 모드로 변신:");
		sman.isSpider=true;
		sman.jump();
		System.out.println("사람 모드로 변신:");
		sman.isSpider=false;
		sman.jump();
	}
}
//
거미 모드로 변신:
뛰기
사람 모드로 변신:
뛰기


코드를 작성하는 중에 'sman.' 까지 입력후 ctrl +space
확인. 
jump()는 Person class에서 정의된 class
실행 결과를 보면 isSpider의 값과 상관없이 
언제나 Person에 정의된 대로 살짝 뒤는 수준. 

SpiderMan2에서 jump() 오버라이딩

실습6
package ch07.extend;

public class SpiderMan2 extends Person {
	Spider spider = new Spider();
	boolean isSpider;

	public void fireWeb() {
		if (isSpider) {
			spider.fireWeb();
		} else {
			System.out.println("Person은 거미줄 발사 불가");
		}
	}

	@Override
	public void jump() {
		if (isSpider) {
			spider.jump();
		} else {
			//System.out.println("뛰기");
			super.jump();
		}
	}
}
거미 모드로 변신:
키 * 1000만큼 엄청난 점프
사람 모드로 변신:
뛰기

다시, SpiderMan2Test2 를 에서,
sman.jump 를 보면 SpiderMan2에서의 메서드이다. 
SpiderMan2가 상속받아 가지고 있던 jump()가
재정의 된것. 

애노테이션
컴파일러등을 위한 주석으로 8장에서 상셓.
@Override는 이 메서드는 재정의한 메서드이니까,
메서드 오버라이딩 규칙에 맞지 않으면 오류를 발생 
시켜라. 정보를 컴파일러에게 전달. 

잠시,
jump() 구현부를 보면 isSpider가 false일 경우의 동작인 
System.out.println("뛰기")
라는 부분이 Person의 그것과  동일하다. 코드 중복. 

어떻게 조상클래스의 메서드를 호출?

----------------------------------------------------
1.4 super 키워드

(1) 조상의 멤버를 참조하는 super 
this를 통해서 객체의 멤버에 접근 하듯이 
super를 통해서 조상의 멤버에 접근. 
this 는 현재 객체 참조.
super는 조상 객체 참조. 
전 
	public void jump() {
		if (isSpider) {
			spider.jump();
		} else {
			System.out.println("뛰기");
			//super.jump();
		}
	}
후
	public void jump() {
		if (isSpider) {
			spider.jump();
		} else {
			//System.out.println("뛰기");
			super.jump();
		}
	}
3개의 jump 메서드를 가지게 되었고,
SpiderMan 입장에서 각각을 참조하는 방법. 

super 와 this는 아주 유사. 
멤버참조 역할. static 영역에서는 사용 목함. 
둘다, 어떤 객체에 대한 참조 인데 static 영역은 
객체가 없는 상태에서도 호출될수 있어야 하므로.

조상의 조상 메서드에 접근 불가.
super.super.jump() 안됨.
1촌까지만.

변수는 자신이 선언된 곳에서 부터 점점 영역을 확장해가며
최초로 만난 선언부에 연결된다는 점.
즉,
메서드 내부에서 사용된 변수는 
메서드 내부의 로컬변수-> 해당 클래스 멤버 변수 ->
부모클래스 멤버변수->조상클래스 멤버변수로 확장해 가며
선언된 곳을 찾아간다. 
그러나, 최상위 객체인 Object까지 찾아봤지만, 선언된 
변수가 없으면 오류가 발생. 
this 로 접근할 때는 로컬 변수에서 찾는 것은 생략하고 
해당 클래스의 멤버변수 부터 검색한다. 
물론, 
super 로 접근할 때는 부모 class의 멤버변수 부터 찾는다. 

다음 예 
조상클래스와 자식클래스, 메서드 내부에 동일한 이름의 
변수가 선언되어 있을때 실제로 어떤 변수를 찾아가는지 확인 
하는예.

실습7
ex)
package ch07.extend;

class Parent {
	String x = "parent";
}

class Child extends Parent {
	String x = "child";

	void method() {
		String x = "method";
		System.out.println("x : " + x);
		System.out.println("this.x : " + this.x);
		System.out.println("super.x : " + super.x);
	}
}

public class ScopeTest {

	public static void main(String[] args) {
		Child child = new Child();
		child.method();
	}
}
//
x : method
this.x : child
super.x : parent

만약, 11행 주석	
//	String x = "method";
//
x : child
this.x : child
super.x : parent

만약, 8행 주석	
//String x = "child";
x : parent
this.x : parent
super.x : parent

부모를 찾아 간다. 

(2) 조상의 생성자를 호출하는 super 
this가 자신의 다른 생성자를 호출 했던것처럼 
super는 조상의 생성자를 호출할수있다. 

어떤 코드에서 자식 class 타입 객체를 만들때 초기화 파라미터
를 넘겨주게된다. 
이 파라미터 중에는 자식 class가 선언한 멤버 변수도 있지만,
조상 class에서 선언된 멤버 변수들도 포함될 수 있다. 
조상 클래스에 선언된 멤버 변수들은 조상 클래스의 생성자에
의해 초기화가 이루어지므로 조상 클래스의 생성자를 
호출해서 초기화하고 
자식클래스에서는 자식이 선언한 멤버변수들만 초기화를 진행하면된다. 
이때 조상클래스의 생성자를 호출하기 위해 super()가 사용된다.

실습8
ex)
class Phone {
String number;

public Phone(String number){
this.number = number; //-->위에 String number 가리키고
}
}

class HandPhone extends Phone {
int price;
public HandPhone(String number, int price) {
super(number); // class Phone의 생성자 public Phone(String number)가리킴.
this.price = price; // class HandPhone의 int price 가리킴. 
}
}

this()의 호출은 언제나 생성자의 첫번째 행에만 올수 있다. 
super()도 마찬가지로 생성자의 첫번째 행에만 올수 있다. 

또, 명시적으로 this() 또는 super()를 이용해서 다른 생성자를 
호출하는 코드가 없다면 컴파일러는 언제나 조상의 기본 생성자를
호출하는 super()를 생성자의 첫 행에 삽입하게 된다. 

실습9
ex)
class Person2 {
String name;

Person2(String name){
// super(); // 자동 삽입된 super() --> Object의 기본 생성자 호출.
this.name = name;
}
}

this(), super() 호출에 따라 코드 검토하고 어떻게 동작하는지 보기.

실습10
ex)
package ch07.extend;

class Person2 {
	String name;
	Person2(String name) {
		// super();		// --> Object의 기본 생성자 호출
		this.name = name;
		System.out.println("Person2(String name) 끝");
	}
}

public class SpiderMan3 extends Person2 {
	Spider spider;
	boolean isSpider;

	SpiderMan3(String name, Spider spider, boolean isSpider) {
		super(name);
		this.spider = spider;
		this.isSpider = isSpider;
		System.out.println("SpiderMan3(String name, Spider spider, boolean isSpider) 끝");
	}

	SpiderMan3(String name) {
		this(name, new Spider(), true);
		System.out.println("SpiderMan3(String name) 끝");
	}

	public static void main(String[] args) {
		SpiderMan3 sman = new SpiderMan3("피터 파커");
	}
}
//
Person2(String name) 끝
SpiderMan3(String name, Spider spider, boolean isSpider) 끝
SpiderMan3(String name) 끝

----------------------------------------------------
2. 패키지(package)와 임포트(import)

2.1 패키지(package)

예)윈도우즈 많은 파일 관리 디렉터리이용.

많은 클래스들을 체계적으로 관리 필요. 
자바는 디렉터리 대신 패키지라는 것을 사용. 
패키지이름 포함된 클래스들의 용도를 유추할수 있는 의미 
있는 이름으로 작성. 
패키지는 필요에 따라 하위 패키지를 둘수있고, 
각 단계는 '.' dot 를 이용해 구분한다. 
ex)
package ch06.method.call;

ch06->method->call 하위 폴더 로.

선언 package 키워드 쓰고, 뒤에 . dot 로 연결해서 표시. 
package 키워드는 주석,공백을 제외하고 소스파일의 
첫번째 문장에 단 한번만 등장. 
패키지를 선언하지 않으면 기본 패키지에 속한다. 
이것은 바탕화면에 마구 파일을 저장하는 것과 같다. 

만들때 규칙. 
맨처음에는 회사등 소속. 도메인을 거꾸로 사용. 
예)
example.com 회사이면 
com.example 형태 
인사관리(Human Resource Management) 프로그램이라면 
hrm 정도. 
공통적인 내용을 담는다. common. 
서비스 로직 service
ex)
package com.example.hrm.common;
package com.example.hrm.service;
 ----------------------------------------------------

2.2 임포트 (import)

다른 패키지에 선언된 클래스를 사용하기 위해 필요한 키워드 .
import는 package 선언과 class 선언사이에 위치하며
package 선언과 달리 필요한  클래스가 있을 때마다 사용 

import 선언시 , 키워드 뒤에 package 이름을 포함한 class명까지 
모두 입력하거나, 해당 package의 모든 클래스를 포함할 때, '*'
를 사용한다. 
단, '*'를 사용한다고 해도 하위 패키지에 있는 클래스까지 
import 하지는 않는다. 
ex)
import package_name.[package_name.]class_name;
import package_name.[package_name.]*;

임포트시 중복되는 경우 
ex)
java.util , java.awt 패지에 List 클래스가 각각 있다. 
만약, 두개의 List 클래스를 동시에 사용하기 위해서는 
둘다 import하고 클래스 내부에서 List라고만 쓰면 
구분이 안된다. 
둘중 하나의 클래스만 import 하고,
다른 클래스는 이름 앞에 전체 패키지명을 입력해서 사용. 

실습11
ex) 
package ch07.imp;

import java.io.InputStream;	// 특정 클래스 import
import java.util.*;			// java.util 패키지의 모든 클래스 import

public class ImportTest {
	Date date;	// java.util 패키지의 클래스
	List list;	// java.util 패키지의 클래스
	
	InputStream input;
	
	java.awt.List list2;	//동일한 이름의 List를 위해 패키지 이름 사용
}
//

작성한 소스들 중 만들지 않은 클래스가 많다. 
System , String, Object 와 같은 클래스들. 
이 모두 java.lang 패키지에 속해 있다. 
그리고, 자주 쓰여서 자동으로 import되어 있다. 

자동 import 기능 
프로젝트의 클래스 패스에 포함된 클래스 중에서 이름 기반으로 
원하는 클래스를 찾아서 자동으로 import 문장을 만들어 준다. 
사용법 
클래스를 import 없이 쓰고 "ctrl + shift + O" 입력 

(1)정적 임포트 (static import)

static import는 static으로 설정된 멤버에 대해 바로 import처리.
이런 멤버들을 호출할 때 클래스 이름을 생략하고 바로 사용. 

실습12
ex)
package ch07.imp;

import static java.lang.Math.random;
import static java.lang.System.out;


public class StaticImportTest {

	public static void main(String args[]) {
		out.println(random());
	}
}

실습13
ex2)
package ch07.structure; //패키지 선언부

import java.io.*; //외부 패키지 import 

public class ClassStructure { // 클래스 선언부
	String name;  //멤버 변수 
	int age; 
	
	{
		name="andy";   //초기화블록 
	}
	
	public ClassStructure(String name, int age) {  //생성자 
		this.name = name;
		this.age = age;
	}
	
	public void setName(String name) {  //멤버 메서드 
		this.name = name;
	}
	
	public String getName() {  //멤버 메서드 
		return this.name;
	}
	
	public static void main(String [] args) {
		ClassStructure cs = new ClassStructure("hong", 10);
	}
}


----------------------------------------------------
3. 제어자 

3.1 제어자(modifier)

클래스, 변수, 메서드의 작성 시 같이 사용. 부가적인 의미를 부여해주는 
키워드. 종류는 2가지.

접근 제어자
접근 제어자는 멤버 변수등을 사용할 수 있는 범위를 지정하는 키워드.
 public, protected, (default = package), private 
 
 그외의 제어자
 static, final, abstract, synchronized , 이절에서는 final 에 대해서.
 abstract 는 추상클래스에서 
 synchronized는 14장에서 
 
 하나의 대상에 여러 제어자를 조합해서 사용 가능하지만, 
 하나만 사용.  순서는 무관.
접근제어자를 앞에 쓰고 , 뒤에 나머지 제어자 사용. 

ex) 클래스 생성할 때 , New Java Class 대화상자에서
Modifiers 에서 접근제어자는 라디오 버튼 적용돼,
하나만 선택, 나머지는 체크 박스라 동시에 여러개 사용 가능. 

(1) final 
마지막, 더는 바뀔수 없음. 
class, 메서드, 변수에 사용 가능. 
final 선언된 class는 더는 확장 못함. 
클래스 레벨에서의 확장이란 상속을 의미.
final 클래스는 상속 받을 수 없는 클래스.

어떤 경우에 사용? final 클래스 

상속을 하면 메서드를 오버라이딩해서 원하는 형태로 변경 가능.
그래서, 최초 의도했던 메서드의 방향과 다른 방향으로 바꿀수 있다. 

그러면, Math 클래스, random() 메서드 를 오버라이딩 한다고 하면,
기존 메서보다 더 좋게, 또는 잘못 재정의 할수 있다는 말. 
그래서, final를 String, Math 같은 클래스에 지정해서, 
완변한 클래스로 생각하고 사용. 

 final , 상속 안되니, 오버라이딩도 안됨. 
 
 final 메서드는 final 클래스의 제한을 메서드 레벨에서 설정한 것. 
클래스 자체는 상속받도록 허용하지만, 특정 메서드만 오버라이딩
못하게 하는 것. 

final 변수는 더이상 값 변경 불가. 
변수를 상수화해서 읽기 전용으로 사용.

final 변수는 초기화 과정에 주의. 
final  변수는 선언과 동시에 초기화하는 경우가 많다. 
만약, 만들면서 초기화를 진행하지 않는 경우가 발생.
이를 blank final 변수라 함. 
blank final 변수  를 사용할 경우, 객체마다 다른 값을 가져야 하는데,
객체 내에서 값을 바꿀 수 는 없게 하려는 경우. 
초기화를 위해서는 생성자를 이용하는 수밖에 없다. 
생성자에서 초기화를 처리 하지 않으면 오류 발생. 
참고,
로컬변수는 초기화하지 않고 사용하면 오류가 발생.

실습14
ex) 
public class BlankFinalTest {
// The blank final field name may not have been initialized 
final String name; // 초기화 해주는 생성자가 없으므로 오류 발생. 
} 

ex2) 
package ch07.modifier;

class FinalMemberClass {
	final String name;  
	// name 변수가 final 인데 값이 할당되지 않은 blank final 형태. 

	// 생성자를 통해서 blank final 변수에 값 할당. 
	public FinalMemberClass(String name) {
		this.name = name;
	}
}

public class BlankFinalTest {
	public static void main(String[] args) {
		FinalMemberClass fmc1 = new FinalMemberClass("hong");
		FinalMemberClass fmc2 = new FinalMemberClass("lim");

		System.out.printf("name: fmc1 - %s, fmc2 - %s%n", fmc1.name, fmc2.name);
		//The final field FinalMemberClass.name cannot be assigned
		//fmc1.name = "kim";  
	}
}
//
name: fmc1 - hong, fmc2 - lim



----------------------------------------------------
3.2 접근 제어자

멤버등에 사용 해당요소를 외부에서 사용할수 있게 할 것인지를 제어. 
종류 
public, protected, default(=package), private
default 는 별도의 키워드 없이 접근 제어자를 생략 하는 것. 
클래스, 생성자, 멤버에 사용 가능. 
클래스 레벨에서는 public과 default만 사용 가능. 

구분   :클래스 :  생성자  :  멤버 
public : 가능 		: 가능  : 가능 
protected :불가능:가능	:가능
default:  가능 		: 가능  : 가능 
private :불가능	:가능	:가능

접근 가능한 범위. 
public : 어디서든 다 접근 가능. 
protected : 같은 클래스나 같은 패키지, 패키지가 달라도 
자손클래스에서 접근 가능. 
default : 같은 클래스나 같은 패키지에서만 접근 가능. 
private : 같은 클래스만 가능. 

구분  : 같은 클래스 :  같은 패키지 :  다른패키지자손클래스 : 전체 
public:  가능: 가능: 가능:가능 
protected:  가능: 가능: 가능:불가능
default(package):  가능: 가능: 불가능:불가능 
private:가능:불가능:불가능:불가능

ex) 접근 여부 확인 해보기. 
같은 패키지 
package ch07.modifier.p1

class Parent 

SamePackageChildClass

SamePackageSomeClass


다른  패키지 
package ch07.modifier.p2

OtherPackageChildClass

OtherPackageSomeClass

실습15
ex) 
package ch07.modifier.p1;

public class Parent {
	public int publicVar;
	protected int protectVar;
	int defaultVar;
	private int privVar;
	
	public void useMember() {
		this.publicVar = 10;
		this.protectVar = 10;
		this.defaultVar = 10;
		this.privVar = 10;
	}
}

실습16
ex2)
package ch07.modifier.p1;

public class SamePackageChildClass extends Parent {
	public void useMember() {
		this.publicVar = 10;
		this.protectVar = 10;
		this.defaultVar = 10;
		//The field Parent.privVar is not visible
		//this.privVar = 10;
	}
}

실습17
ex3)
package ch07.modifier.p1;

public class SamePackageSomeClass {
	public void method() {
		Parent p = new Parent();
		p.publicVar = 10;
		p.protectVar = 10;
		p.defaultVar = 10;
		//The field Parent.privVar is not visible
		//p.privVar = 10;
	}
}

실습18
ex4)
package ch07.modifier.p2;

import ch07.modifier.p1.Parent;

public class OtherPackageChildClass extends Parent {
	public void useMember() {
		this.publicVar = 10;
		this.protectVar = 10;
		// The field Parent.privVar is not visible
		//this.defaultVar = 10;
		// this.privVar = 10;
	}
}

실습19
ex5)
package ch07.modifier.p2;

import ch07.modifier.p1.Parent;

public class OtherPackageSomeClass {
	public void method() {
		Parent p = new Parent();
		p.publicVar = 10;
		//The field Parent.privVar is not visible
		//p.protectVar = 10;
		//p.defaultVar = 10;
		//p.privVar = 10;
	}
}

멤버를 만들고 사용 못하게 할까?
신뢰도?
실생활 예)
부모님만 간직하고 싶은 비밀 (private)
같은 집(package) 사는 사람들(default)까지.
같은 집에 안 살아도 자식들(protected) .
모든 이가 다 아는 public
!
메서드 오버라이딩 조건,
부모 메서드의 접근 제어자와 같거나 넓어야 한다. 규칙.
ex)
부모 클래스 메서드가 protected 로 선언돼 있다면 
자식 클래스에서는 public, protected 제한. 

private < default < protected < public

실습20
ex)
package ch07.modifier;

class Parent{
	protected void method() {}
}

public class OverrideRule extends Parent{
	@Override
	// Cannot reduce the visibility of the inherited method from Parent
	//void method() {}
	protected void method() {}
	//public void method() {}
}

----------------------------------------------------
3.3 데이터 은닉과 보호

Encapsulation 

실생활로 
우리가 가진 멤버 변수에 은행 잔고도 있다. 
만약, 이 멤버변수를 모두가 접근할 수 있다면 (public)
어떻게 될까?
잔고도 얼마나 있는지 조회가 되고, 심지어 깡통 계좌로
만들수 있다. 

실습21
ex)
package ch07.modifier.encapsulation;

class UnbelievableUserInfo {
	//이름은 null이 될 수 없음.
	public String name = "홍길동";
	// 계좌는 0보다 커야 함.
	public int account = 10000;
}

public class UnbelievableTest {
	public static void main(String[] args) {
		UnbelievableUserInfo info = new UnbelievableUserInfo();
		System.out.printf("사용자 정보:%s, %d%n", info.name, info.account);
		info.name = null;
		info.account = -1000;
		System.out.printf("사용자 정보:%s, %d%n", info.name, info.account);
	}
}
//
사용자 정보:홍길동, 10000
사용자 정보:null, -1000

이름 변경, 마이너스 통장으로 됨. 
이유? 외부에서 변수에 직접 접근하기 때문.
할당되는 과정에서 무언가 보호장치가 개입될 여지가 없어서,

직접 접근 막기. 접근 제어자 이용.
소중한 데이터인 멤버 변수들 모두 private 접근 제어자를 
갖는다. 이제 멤버변수가 선언된 클래스에서만 해당 멤버변수에 직접 
접근이 가능.
그럼 외부에서 변수를 사용하는 방법?
직접적으로는 접근할 수 없다. 
대신 public 등으로 공개되는 메서드를 제공해서 private
멤버에 접근할 수 있는 통로로 활용한다. 
값을 조회하는 메서들의 이름은 get으로 시작하고
이런 부류를 getter라고 부르고, 값을 설정하는 메서드들의
이름은 set으로 시작하며 setter라고 한다. 
통로로 활용되는 메서드 내에는 정보 보호를 위한 필요한 로직을 넣을 
수 있으므로 부적절한 값의 설정을 방지 할수있다.
getter 에서는 필요에 따라 권한 정보를 요구해서 권한이
있는 사용자가 값을 조회하게 할수있다
setter에서는 설정되는 값이 처음 의도한 범위내에 있는지 확인한 후 
안전한 값만 설정할수 있도록 처리한다. 

이과정을 데이터 은닉과 보호, 즉 Encapsulation이라한다. 

실습22
ex)
package ch07.modifier.encapsulation;

class BelievableUserInfo {
	private String name = "홍길동";
	private int account = 10000;
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		if(name!=null) {
			this.name = name;
		}else {
			System.out.println("부적절한 name 할당 시도 무시: "+name);
		}
	}
	
	public int getAccount() {
		return this.account;
	}
	
	public void setAccount(int account) {
		if(account>0) {
			this.account = account;
		}else {
			System.out.println("부적절한 account 할당 시도 무시: "+account);
		}
	}
}

public class BelievableTest {
	public static void main(String[] args) {
		BelievableUserInfo info = new BelievableUserInfo();
		//System.out.printf("사용자 정보:%s, %d%n", info.name, info.account);
		System.out.printf("사용자 정보:%s, %d%n", info.getName(), info.getAccount());
		//info.name = null;
		info.setName(null);
		//info.account = -1000;
		info.setAccount(-10000);
		System.out.printf("사용자 정보:%s, %d%n", info.getName(), info.getAccount());
	}
}
//
사용자 정보:홍길동, 10000
부적절한 name 할당 시도 무시: null
부적절한 account 할당 시도 무시: -10000
사용자 정보:홍길동, 10000

생성자 코드와 마찬가지로 getter , setter 의 기본 형태도 
단순하고 반복되는 코드들이다.
이클립스 위저드를 이용해 코드들을 자동으로 생성할 수 있는 기능을 
알아보자. 
편집 창 우클릭 -> Source -> Generate Getters and 
Setters] 메뉴 클릭. 생성할 멤버 변수들을 체크하여 선택. 
개별 선택 가능. 
이미 소스 코드 가 표시된 부분은 안보임. 
필요한 경우 하단의 접근제어자 변경 가능. 


----------------------------------------------------
3.4 객체의 생성 제어와 Singleton 디자인 패턴 

주변에 객체를 마구 만들 수 없거나, 만들 필요가 없는 상황이 존재한다. 
비싼집 마음대로 new 해서 가질수 없고,
편의점에 나에게만 서비스할 직원도 필요 없고,
단지 그 직원을 모든 손님이 공유하고,
자신의 정보를 직원에게 줄 필요도 없다. 

프로그램도 마찬가지.
객체가 여러개 필요한 경우는 객체마다 가지는 멤버변수의 값이 다를 
경우.
그래서, 멤버변수가 없거나, 같은 값만 사용된다면 굳이 
여러 객체를 만들어 사용할 필요가 없다. 

자바에서 데이터베이스를 사용하기 위해서는 
java.sql.Connection 타입의 객체가 필요한데,
이 객체는 네트워크를 통해 애플리케이션과 데이터베이스를 연결
하는 비싼 자원이다. 프로그래밍에서 비싸다라는 말은 
시간이 오래 걸리거나 메모리등의 시스템 리소스가 많이 드는 것을 이야기 한다. 
따라서 계속 연결과 반환을 반복하는 것 보다는 하나 또는 몇개를 
미리 만들어 놓고 재사용하는 것이 유리.

개념은 정의했지만, 막상 구현이 어려움. 
이럴 때 프로그래밍에서 선배들이 미리 정의해 놓은 것을 
디자인 패턴이라고 한다. 

디자인 패턴이란 같은 상황에 부딪쳤던 많은 개발자가 이뤄낸 작업의
정리 결과로 반드시 따라야하는 법칙은 아니지만,
어떤 목적을 달성하기 위한 프로그래밍 가이드 정도로 생각. 
디자인 패턴을 이용하면 특정 목적의 작업을 효율적으로 처리 가능. 

이 문제를 처리하기 위한 디자인 패턴에는 싱글턴 디자인 패턴이 있다. 
Singleton class 구현해보자. 

싱글턴 디자인 패턴의 출발점은 대상 객체를 외부에서 직접 생성할 수 
없었다 한다. 그래서 생성자에는 private 접근제어자를 
사용해서 외부에의 노출을 차단한다. 

private SingletonClass() {}

이제 이 생성자에 접근할 수 있는 것은 이 클래스 내부만 가능. 
따라서 내부에서 자신의 객체를 생성하고 멤버변수에 저장. 
소중한 멤버변수이므로 private 접근제어자를 적용한다. 

private SingletonClass instance = new SingletonClass();

다음은 private 멤버변수에 접근할수 있는 setter 와 getter
가 필요한데, 외부에서는 어차피 객체를 만들수 없기 때문에
setter는 필요없고 getter만 충분. 

public SingletonClass getInstance() {
return instance;
}

그런데 막상 위의 getter를 쓰려고 보니 메서드에 접근할 수 있는 
객체가 없다. 따라서 마지막으로 객체 없기 메서드를 사용하기 위해 
메서드와 멤버변수에 static 선언이 필요해진다. 

private static SingletonClass instance 
= new SingletonClass();

public static SingletonClass getInstance() {
return instance;
}

이제 Singleton 디자인패턴이 완성. 
SingletonClass의 객체가 필요할 때는 객체를 생성하는 것이 
아니라 getInstance() 메서드를 호출하면 되고 이 메서드의 
리턴은 언제나 하나의 객체일 것이다. 

실습23
ex)

package ch07.modifier;

class SingletonClass{
	private static SingletonClass instance = new SingletonClass();
	private SingletonClass() {}
	
	public static SingletonClass getInstance() {
		return instance;
	}
	
	public void sayHello() {
		System.out.println("Hello");
	}
}

public class SingletonTest {
	public static void main(String[] args) {
		SingletonClass sc1 = SingletonClass.getInstance();
		SingletonClass sc2 = SingletonClass.getInstance();
		System.out.printf("두 객체는 같은가? %b%n", sc1==sc2);
		sc1.sayHello();
	}
}
//
두 객체는 같은가? true
Hello


----------------------------------------------------
4. 다형성 

4.1 다형성 (Polymorphism)

많을 다에 형태 형을 사용. 형이란 타입.
4대특징 중 P에 해당 Polymorphism.

붕어빵 이야기, 황금잉어빵. 상속이야기. 
어떤 때는 붕어빵이라고, 어떤 때는 황금잉어빵이라고, 
이것을 다형성이라고 한다. 

상속관계에 있을 때 조상클래스타입으로(붕어빵)으로 
자식클래스객체(황금잉어빵)를 레퍼런스 할수 있는 성질.

SpiderMan의 상속 관계로 다시 다형성 설명. 

ex)
Venom-->SpiderMan-->Person-->Object
상속 구조 

SpiderMan 타입 객체가 하나 있다. 

SpiderMan onlyOne = new SpiderMan();

onlyOne은 SpiderMan인가? 질문.
이 말은 SpiderMan 타입으로 onlyOne을 참조할수 있는가?
와 같다. 코드는 이렇게도 표현 가능. 

SpiderMan sman = onlyOne

다시 질문.
onlyOne은 Person 타입인가?
상속은 is a 관계이고, SpiderMan은 Person을 상속 
받았으므로 맞는말이다. 코드로 보자. 

Person person = onlyOne 

마지막 질문. 
onlyOne은 Object 타입인가? 모든 객체의 최상위에는 
Object 클래스가 있기 때문에 역시 맞는 말. 

Object obj = onlyOne

조상클래스 타입으로 자식 클래스 타입의 객체를 참조하는 것은 
프로그래밍에서 매우 당연. 

실습24
ex)
package ch07.poly;

import ch07.extend.Person;
import ch07.extend.SpiderMan;

public class PolymorphismTest {

	public static void main(String[] args) {
		SpiderMan sman = new SpiderMan();
		Person person = sman;
		Object obj = sman;

		System.out.printf("sman==person? %b%n", sman == person);
		System.out.printf("sman==obj? %b%n", sman == obj);
	}
}
//
sman==person? true
sman==obj? true

----------------------------------------------------
4.2 다형성 의 활용 

어디에 사용할까? 
자바의 개념 전반에 넓게 깔려 있어서 특정 분야가 아니라 
어디에서나 적용되고 있다. 
다형성이 잘 작용된 애플리케이션은 황금잉어빵을 붕어빵이라고
팔수있을 만큼 유연하게 동작한다. 

배열의 예.
같은 타입의 데이터를 묶어서 관리하는 것이 특징.
Person 타입의 배열을 만들면 Person 타입의 객체들만 
담을 수 있다. 만약, Person 타입 10개와 SpiderMan 
타입 10개를 관리해야 한다면 Person 타입의 배열과 SpiderMan
타입의 배열로 두개의 배열이 필요하다 

ex)
void beforePoly(){
Person [] persons = new Person[10];
persons[0] = new Person();
//Person 전용 
SpiderMan [] spiderMans = new SpiderMan[10];
spiderMans[0] = new SpiderMan();
// SpiderMan 전용 
}

그러나, 이제 다형성을 배웠고, 이를 적용한다면 SpiderMan은 
Person이기 때문에 Person의 배열에 SpiderMan을 담을 수 
있다. 

ex2)
void afterPoly() {
Person [] persons = new Person[10];
person[0] = new Person();
person[1] = new SpiderMan();
// Person 하위 클래스용 
}

더 나아가 Object의 배열을 만들게 되면 어떤 타입의 객체라도 
다 저장할수 있게 된다. 자바의 자료구조가 간단해질 수 있는 것은 
다형성 덕분이다.  이 특징을 이용해서 나중에 학습할 
Collection API 가 등장. 

다형성의 또 다른 예로 매개변수에서의 다형성 활용에 대해서 알아봄. 

System.out.println() 을 이용해 다양한 객체를 출력.
System.out.println( new Person());
System.out.println( new SpiderMan());

메서드가 호출될 때는 이름과 함께 메서드에서 요청하는 적절한 
파라미터를 제공 해야한다. 

설마 이런 메서드가 Java 기본 라이브러리에 있을까?ㅋ
public void println(Person p){...}
public void println(SpiderMan sm){...}
물론 없다. 

실제 동작한 메서드의 API 
ex)
public void println(Object x) {
String s = String.valueOf(x);
synchronized(this) {
print(s);
newLine();
}
}

비밀은 파라미터 타입이 Object인 점. Object는 모두의 
조상이므로 어떤 객체가 들어오더라도 모두 연결할 수 있는 것.
자바 API를 보면 다수의 범용적인 메서드들이 Object를 파라미터
로 받도록 작성되었는데 다형성을 이용해 어떤 객체든 처리하기 위해서.

(1) 다형성과 참조형 객체의 형변환 

메모리 동작 살펴보기

이 코드는 다형성을 적용해 Person 타입으로 SpiderMan 타입의 
객체를 참조한 것. 

ex)
Person person = new SpiderMan();

등호의 오른쪽은 힙 영역에 있는 SpiderMan 타입의 객체이다. 
이 객체는 거미줄도 쏘고(fireWeb) 스파이더 모드(isSpider)
에 대해서 설정 가능. 
하지만 등호의 왼쪽은 아무리 봐도 Person 타입이다. 
이 person이 거미줄을 발사할 수 있을까?
person이 할수 있는 일 Code Assist 기능을 이용해 보기 

person. 보면 , Object와 Person에서 선언했던 내용만 파업이
되고 , SpiderMan에서 선언했던 내용은 보이지 않는다. 

비록 실제 메모리에 있는 객체가 SpiderMan 이여도 참조하는 
타입이 Person이므로 SpiderMan의 고유한 기능을 모르는 것. 
물론, 만약 Object 타입으로 참조하고 있다면 Object의 영역만 
사용 할수 있을 것이다. 

그림 Object obj 위에   // Object 고유영역
Person person 위에  // Person 고유영역
SpiderMan sman 위에 // SpiderMan 고유영역
= new SpiderMan() 

그림을 보면 다형성이 왜 가능한지도 알수있다. 
메모리에 있는 내용이 언제나 참조하는 타입(Object, Person, SpiderMan)
의 내용을 다 가지고 있는 충분조건을 만족하기 때문이다. 

메모리에 있는데도 불구하고 사용할수 없다는 점 아쉽다.
어떻게 하면 전체 내용을 사용할수 있을까?

단순히 참조하는 변수의 타입에 관한 문제이기 때문에 타입을 바꿔주면 된다. 
바로 변수에서 배웠던 형변이다. 
달라진점, 기본형이 아니라 참조형이라는 점. 

기본형에서의 형변환 규칙. 작은집에서 큰 집으로 이동할 때는 값이 
잘릴 염려가 없기 때문에 묵시적형변환이 발생하고,
나머지 경우는 명시적형변환 필요.
묵시적형변환이 연산자(괄호)를 생략가능.
명시적형변환에서는 반드시 사용. 
참조형에서도 동일.
작은 집 = 자손클래스
큰 집 = 조상클래스

형변환이 되면 변환된 타입으로 선언된 기능들을 사용할수 있다. 

실습25
ex)
package ch07.poly;

import ch07.extend.Person;
import ch07.extend.SpiderMan;

public class CastingTest {
	public void primitive() {
		byte b = 10;
		// 묵시적 형변환: 작은 집 --> 큰집
		int i = b;
		// 명시적 형변환: 큰집 --> 작은 집
		byte b2 = (byte) i;
	}

	public void reference() {
		// 묵시적 형변환: 작은 집 --> 큰집
		Person p = new SpiderMan();
		// p.fireWeb(); -- 메모리에 있지만 사용할 수 없다.
		// 명시적 형변환: 큰집 --> 작은 집
		SpiderMan sman = (SpiderMan) p;
		sman.fireWeb();// 이제는 SpiderMan 타입이므로 fireWeb을 사용할 수 있다.
	}
}
묵시적형변환 하고 명시적 형변환 
묵시적형변환 작은 -> 큰 : 업캐스팅
명시적형변환 큰 -> 작 : 다운캐스팅

(2)instnaceof 연산자 p260~

참조형 객체의 형변환 처리시 주의점. 
다음의 예 
먼저, Person 타입의 객체 person을 만든 후 SpiderMan 타입으로 
형변환 처리한 예.

ex) 
Person person = new Person();
SpiderMan sman = (SpiderMan)person;

이 코드는 문법적으로 전혀 문제가 없다. 하지만 실제 프로그램이 동작 
할 때, 문제 발생. 여기서 메모리에 있는 객체는 Person 타입.
SpiderMan이 되기 위한 충분조건( fireWeb 메서드등)을 갖추지 못한 상태.
무늬만 SpiderMan.

따라서 런타임 시의 메모리 구성상 형변환을 할수 없다. 
이렇게 동작시키면 형변환을 처리하다가 java.lan.ClassCastException
을 발생시키고 종료.

결론적으로 부모 타입을 언제나 형변환 연산자를 통해 자식 타입으로는 
변경할수는 없다는 이야기.
먼저, 메모리에 있는 객체가 형변환을 위한 충분조건을 갖추고 있는지 확인. 
이때 사용하는 연산자 : instanceof 이다. 

instanceof 연산자는 실제 메모리에 있는 객체가 특정 클래스 타입인지를 
boolean 타입으로 리턴. 


ex)
Person person = new Person();
if (person instanceof SpiderMan) {
SpiderMan sman = (SpiderMan) person;
}
여기서는 형변환이 발생하지 않는다. 


실습26
ex)
package ch07.poly;

import ch07.extend.Person;
import ch07.extend.SpiderMan;

public class InstanceOfTest {
	public void badCasting() {
		Person person = new Person();
		SpiderMan sman = (SpiderMan) person;
		sman.fireWeb();
	}

	public void goodCasting() {
		Person person = new Person();
		if (person instanceof SpiderMan) {
			SpiderMan sman = (SpiderMan) person;
			sman.fireWeb();
		}else {
			System.out.println("SpiderMan에 적합하지 않은 객체");
		}
	}
	
	public static void main(String[] args) {
		InstanceOfTest iot = new InstanceOfTest();
		// 아래 메서드 호출은 runtime 오류를 발생시킨다.
		// iot.badCasting();
		iot.goodCasting();
	}
}
//
SpiderMan에 적합하지 않은 객체

형변환과 다형성이 적용된 메서드의 파라미터를 함께 적용하는것에
대해 생각. 
equals() 나 println() 메서드의 예에서 메서드의 파라미터에 
상위 타입을 적용하면 그만큼 처리할수 있는 범위가 넓어진다는 것 
확인. 
그럼 언제나 Object를 파라미터로 받는다면 메서드가 
그만큼 유연해질까?

만약 Object, Person, SpiderMan 객체가 하나씩 있는 상태에서 jump 라는 
동작을 시키고 싶을 때 가장 적절한 메서드는 어떤 것일까?
(jump()는 Person에서 처음 정의된 메서드.)

ex)
public void useJump1(Object obj) { }
public void useJump2(Person person) { }
public void useJump3(SpiderMan spiderMan) { }

첫번째 메서드는 어떤 객체가 할당되던지 다처리 가능.
아주 활용도가 높아 보이지만, 전달받은 객체인 Object에는 
jump() 가 없기 때문에, 내부에서는 별도의 형변환 절차가 필요.
물론 형변환 전에 instanceof를 이용해 obj가 Person 타입인지 
확인해야 하는 것도 필수이다. 
활용도는 최고지만 번거로움도 만만치 않다. 

ex2)
public void useJump1(Object obj) {
if ( obj instanceof Person) {
Person casted = (Person)obj;
casted.jump();
}
}
public void useJump1(Object obj) { }
public void useJump2(Person person) { }
public void useJump3(SpiderMan spiderMan) { }

두번째 메서드는 Person 또는 SpiderMan만 처리 가능. 
하지만 호출할 jump() 메서드는 어차피 Person에서 처음 
등장한 메서드니 파라미터로 들어온 객체들은 모두 jump()가
가능할 것이고 형변환도 필요 없다. 
필요한 객체만 할당될 수 있으니 형변환의 절차도 필요 없어진다. 

ex3)
public void useJump2(Person person) {
person.jump();
}
public void useJump1(Object obj) { }  //사용불가
public void useJump2(Person person) { }
public void useJump3(SpiderMan spiderMan) { }

세번째 메서드는 SpiderMan만 처리 가능. 
별도의 형변환 절차는 필요 없겠지만,  Person은 이 메서드를 사용 
할수 없기 때문에 활용도가 떨어진다. 

ex4)
public void useJump3(SpiderMan spiderMan) {
spiderMan.jump();
}
public void useJump1(Object obj) { }  //사용불가
public void useJump2(Person person) { }   //사용불가
public void useJump3(SpiderMan spiderMan) { }

정리, 다형성을 이용해 메서드의 파라미터를 구성할때는 가급적
상윕 타입을 잡는것이 좋다. 하지만, 최상위의 Object까지 
올라가면 별도의 형변환 절차가 필요해서 번거롭다.
Object 를 파라미터로 받는 메서드들은 대부분 자바 API 처럼 
광범위하게 사용되는 경우이다. 
프로젝트 진행할때는 프로젝트 내에서 작성한 객체 중 적절한 
상위 객체를 사용하는 것이 바람직.

(3) 참조 변수의 레벨에 따른 객체의 멤버 연결 

상속 이용시, 조상의 멤버들을 그대로 물려받아서 
필요할때 자손은 그 멤버들을 재정의 할수있다.
이 상황에서 실제 메모리에 있는 객체와 이를 참조하는 변수의 
타입이 다를 때 어떤 현상이 일어나는지 확인해보자. 

SuperClass 클래스와 이를 상속받은 SubClass 클래스가 정의.
두개의 클래스에는 각각 x라는 변수가 선언 되었고,
각 각 내용은 super, sub 이다. 
SuperClass 에서 선언된 method()가 SubClass에서 재정의.

ex)
class SubClass {
String x = "super";
public void method() {
System.out.println("super class method");
}
}

class SubClass extends SubClass {
String x = "sub";
public void method() {
System.out.println("sub class method");
}
}
이 클래스들을 사용하는 예 보기.
먼저, SubClass 객체를 만들고 SubClass로 참조한 후 
멤버 x의 값을 출력해보고 method()도 호출해보자.
어떤 값이 출력되는가?

ex2)
SubClass subClass = new SubClass();
System.out.println(subClass.x);
subClass.method(); 

메모리에 있는 객체는 SubClass 타입이고 참조하는 클래스의 
타입도 SubClass이므로 메모리에 있는 모든 내용을 다 볼수 있다. 
따라서 예상되는 출력 결과는 'sub'와 'sub class method' 이다. 

이제는, 
다형성을 이용해서 SuperClass 타입으로 객체를 참조하고 
동일한 작업을 해보자. 
어떤 값이 출력될까?
SuperClass superClass = subClass;
System.out.println(superClass.x);
superClass.method();

실제 메모리의 객체는 SubClass 타입이지만 참조하는 객체의 타입은 
SuperClass 이므로 superClass 객체가 볼수 있는 부분은 
SuperClass 부분으로 한정된다. 
그럼 출력되는 값은 'super'와 'super class method' 일까?

반은 맞고 반은 틀렸다. 
연결되는 멤버 변수는 선언된 객체의 타입에 따라 달라진다. 
따라서 x의 값은 'super'가 출력되고,
하지만, method()의 경우는 예상과 달리 'sub class method'가 출력된다.

상속관계에서 객체의 멤버 변수가 중복될때,
참조변수의 타입에 따라 연결이 달라진다. 
즉, SuperClass로 참조할때는 SuperClass의 멤버변수로,
SubClass로 참조할때는 SubClass의 멤버변수가 사용된다.

하지만, 상속관계에서 메서드가 오버라이딩 되었을 때는 
무조건 자식 클래스의 메서드가 호출된다. 이것을 가상 
메서드 호출(virtual method call)이라고 한다. 
메서드 재정의는 부모가 물려준 메서드를 자식 입장에 
맞게 최적화시킨다고 할 때, 실제 메모리에 있는 객체가 
가진 가장 최적화된 메서드가 동작한다고 보자.
이런동작은 프로그래밍하면서 아주 유용하고 중요하다. 

이해하기 위해서 객체가 출력되는 과정을 예로 들어보자. 

실27
ex)
package ch07.poly;

class UserInfo {
	String name = "홍길동";

	/*@Override
	public String toString() {
		return "이름: " + this.name;
	}*/
}

class MemberInfo extends UserInfo {
	String grade = "정회원";

	/*@Override
	public String toString() {
		return super.toString() + ", 등급: " + grade;
	}*/
}

public class PrintObject {

	public static void main(String[] args) {
		Object member = new MemberInfo();
		System.out.print("객체 정보: " + member);
	}
}
//
객체 정보: ch07.poly.MemberInfo@368239c8

메모리의 객체는 MemberInfo 타입이고 Object 타입의 member
로 참조하고 있다. 

print() 메서드를 이용해 객체를 출력할수있다. 
출력결과를 보면 조금 아쉽다. 이 주소값으로 할수 있는 일이 없다. 
오히려 객체 멤버들의 name이나 grade 같은 내용이 출력되는 
것이 조금 의미 있지 않을까?

어떻게 객체가 출력되는지 살펴보자. 
먼저, print라는 메서드의 소스 코드를 분석하자. 

System 클래스에 선언된 static 변수인 out의 타이은 
PrintStream이다. 
이 클래스의 print 메서드는 다음과 같다. 

ex)
public void print(Object obj) {
write(String.valueOf(obj));
}

파라미터로 선언된 변수의 타입이 Object이므로 어떤 객체가 
들어오더라도 다 출력 가능. 
내부에서 처음 진행되는 일은 String 클래스가 가진 valueOf라는 
static 메서드에 이 객체를 넘겨준다. 

다시, String 클래스의 valueOf 를 살펴보자. 
valueOf는 파라미터가 obj가 null인지 확인해서 null이면 
문자열 'null'을 출력하고 그렇지 않으면 Object가 가지고 있는 
toString의 결과를 리턴한다. 

ex)
public static String valueOf(Object obj) {
return (obj == null ) ? "null" : obj.toString();
}

마지막으로, 최종적인 출력의 형태는 Object 클래스가 
가진 toString 메서드가 결정한다. 
toString 메서드에서는 클래스 이름과 hashCode를 이용해 
객체의 출력 내용을 결정한다. 

ex)
public String toString() {
return getClass().getName() + "@" + Integer.toHexString(hashCode());
}

이제 MemberInfo 객체가 왜 ch07.poly.MemberInfo@368239c8
로 출력 되는지 확인 되었다. 

모든 클래스는 Object를 상속받고 있으므로 모든 객체는 
Object로 부터 물려받은 toString() 메서드를 가지고 있다. 
따라서 모든 객체는 출력된다.
하지만, 출력내용은 우리가 원하는 방향은 아닌듯.
이상황에 필요한 것?
메서드 오버라이딩이다. UserInfo에서 Object로부터
물려받은 toString 메서드를 오버라이딩해서 이름 정보를 
출력하도록 수정하고 다시 실행. 

ex)
class UserInfo {
String name = "홍길동";

public String toString() {
return "이름: " + this.name;
}
}
현재 메모리에 있는 객체가 toString 메서드를 오버라이딩
했으므로 가장 최적화된 메서드는 UserInfo에서 재정의된
toString이 되고 이를 이용해서 출력 내용이 결정된다. 
이로써 PrintObject를 수정하지 않아도 UserInfo의
수정 내용이 최종 결과에 반영된다. 

MemberInfo도 자신의 입맛에 맞게 toString 메서드를 
오버라이딩하면 다시 MemberInfo에 적합하게 출력결과가
변경될것이다.

ex)
class MemberInfo extends UserInfo {
String grade = "정회원";

@Override
public String toString() {
return super.toString() + ".등급: " + grade;
}
}
정리, Object의 toString() 메서드 덕에 어떤 
객체라도 출력될수 있다. 하지만 그 출력 내용은 객체의 
특성을 충분히 반영하지는 못한다.
출력되는 내용을 변경하려면 자식 클래스에서 toString()
메서드를 오버라이딩해야 한다. 
이 경우 가상 메서드 호출(Virtual Method Call)에
의해 언제나 마지막에 재정의된 메서드가 동작해서 출력 내용이
결정된다. 

(4) 공변(Covariant) 리턴타입
공변: 하나가 변하면 다음 것이 따라서 변하는 것.

원래 메서드 오버라이딩 시 자식 메서드의 리턴타입은 조상 
메서드의 리턴타입과 같아야한다.
하지만, 조상메서드의 리턴타입을 서브클래스 범위 안에서 
다양하게 사용할수 있다는 것이 공변 리턴타입이다.
JDK 1.5 버전에서 추가.

다음 예,
Phone을 상속받는 HandPhone 클래스.
Phone에는 Phone을 리턴하는 aboutMe() 메서드가 있고,
HandPhone이 이 메서드를 오버라이딩하고 있다. 
이 때 배운 대로 조상 메서드가 반환하는 타입을 그대로 사용한다. 

ex)
class Phone {
public String number;
public Phone aboutMe() {
return this;
}
}

class HandPhone extends Phone {
public int weight = 100;
@Override
public HandPhone aboutMe() {
return this;
}
}

이제 이 클래스를 사용해보자. HandPhone 객체를 
만들고 aboutMe 를 호출하면 Phone 타입을 
반환받게 된다. 따라서 HandPhone의 특성을 사용하려면 
다시 HandPhone으로 형변환을 해야 하는 번거로움 발생.

HandPhone hp = new HandPhone();
Phone aboutMe = hp.aboutMe();
if ( aboutMe instanceof HandPhone) {
System.out.println(((HandPhone) aboutMe).weight);
}

HandPhone에서 aboutMe()를 재정의할 때 공변 반환
타입을 사용한다면 다음과 같이 반환 타입을 Phone 의 
하위 타입인 HandPhone으로 바꿔볼 수 있다.

ex)
class HandPhone extends Phone {
public int weight = 100;
@Override
public HandPhone aboutMe() {
return this;
}
}
다시 aboutMe()의 반환 값을 사용한다면 별도의 
형변환 없이 쉽게 사용할수 있다.
HandPhone aboutMe2 = hp.aboutMe();
System.out.println(aboutMe2.weight);

공변 반환 타입을 이용하면 형변환의 번거로움을 많이 
줄일수 있다. 



===================================
[자바 해바라기 정리] 8 나머지 주요 구성요소
실습35
1. 추상 클래스 (Abstract Class)

자바를 구성하는 가장 기본적인 요소는 클래스이다.
기본 클래스 이외에 자바 애플리케이션을 구성하는 요소들에 대해 보자.
이들은 클래스가 아닐 뿐 전체적으로 많이 사용되므로, 각 요소의
정확한 사용법을 알고 유연한 자바 애플리케이션을 작성하자.

----------------------------------------------------
1.1 추상 클래스의 정의 

회사 차량 관리 프로젝트. 처음 관리할 자동차는 디젤연료를 사용하는 SUV 차량.
이 차의 관리 포인트는 현재의 위치를 보고하는 기능(reportPosition)과 
연료를 주입하는 기능(addFuel)이다. 
간단한 클래스 작성 

실습1
ex)
package ch08.abs.bad;

public class DieselSUV {
	private int curX, curY;
	
	public void reportPosition() {
		System.out.printf("현재 위치: (%d, %d)%n", curX, curY);
	}
	
	public void addFuel() {
		System.out.printf("주유소에서 급유");
	}
}

사업 번창, 전기차(ElectricCar) 추가.
전기차 관리 포인트는 DieselSUV와 동일. 
차이점은 addFuel() 메서드를 구현할때 '주유소에서 급유'라는 내용 
대신 급속 충전이라고 구현부만 변경.
기존 클래스 복사,붙여넣기 한 뒤에 변경된 부분만 바꿔주면 쉽다. 

실습2
ex2)
package ch08.abs.bad;

public class ElectricCar {
	private int curX, curY;
	
	public void reportPosition() {
		System.out.printf("현재 위치: (%d, %d)%n", curX, curY);
	}
	
	public void addFuel() {
		System.out.printf("급속 충전");
	}
}

만약, 사업이 계속 잘되면 이런식으로 관리해야 할 클래스들은 계속해서 늘어난다. 
만약, 위치를 보고하는 기능이 바뀐다면 모든 클래스에서 수정해야 함. 
상속 구조를 사용한다면 어떨까?
공통 모듈들은 뽑아서 조상클래스로 넘겨주고 자식들은 변경된 부분만 재정의 
또는 추가하면 간단히 해결된다. 

실습3
ex3)
package ch08.abs.middle;

class Vehicle {
	private int curX, curY;

	public void reportPosition() {
		System.out.printf("현재 위치: (%d, %d)%n", curX, curY);
	}

	public void addFuel() {
		System.out.println("모든 운송 수단은 연료가 필요");
	}
}

class DieselSUV extends Vehicle {
	@Override
	public void addFuel() {
		System.out.println("주유소에서 급유");
	}
}

class ElectricCar extends Vehicle {
	@Override
	public void addFuel() {
		System.out.println("급속 충전");
	}
}

class HorseCart extends Vehicle{}

public class VehicleTest {

	public static void main(String[] args) {
		Vehicle[] vehicles = { new DieselSUV(), new ElectricCar() };
		for (Vehicle v : vehicles) {
			v.addFuel();
			v.reportPosition();
		}
	}
}
//
주유소에서 급유
현재 위치: (0, 0)
급속 충전
현재 위치: (0, 0)

전체적으로 상속을 통한 소스 코드의 재사용, 다형성을 이용한 관리를 이용한 잘 
작성된 애플리케이션이다. 
그런데, 이 38행짜리 애플리케이션에서 전혀 동작하지 않는 코드가 한줄 있다. 
어디?
답, 11행 즉 Vehicle 클래스의 멤버인 addFuel() 메서드의 구현부이다. 
addFuel() 메서드는 하위 클래스들에 의해 재정의되어 있다. 
따라서 실제로 호출되는 메서드는 17행과 24행처럼 각 클래스별로 재정의한 메서드다.

이상황에서 10행의 addFuel() 메서드를 힘들게 구현한 개발자는 고민이다.
힘들게 구현한 메서드가 정작 사용되지는 않는다고 실망한 개발자가 10~12행을 삭제
한다면 어떻게 될까?

addFuel()가 조상클래스라는 공통 코드에서 사라지게 되므로 34행처럼 
Vehicle을 통해 addFuel()를 호출할수 없다. 
Vehicle을 DieselSUV나 ElectricCar로 형변환 후 비로소 
addFuel()를 사용할수 있게 된다. 오히려 처리할 일들이 늘어남. 

좀더 보면, Vehicle 입장에서는 연료주입(addFuel)이 필요하지만, 
아직 차의 종류가 확정되지 않았기 때문에 어떤 연료를 주입할지는 모르는 상황.
그래서 메서드의 선언부까지는 작성이 가능하지만 구현부는 작성할수 없는 것.

이렇게 자손클래스들에서 어차피 재정의해서 사용되기 때문에 조상 입장에서는 
구현 할 필요가 없거나 조상 레벨에서 아직 작성할 수 없는 메서드에 대해 
선언부만 작성하고 구현부를 세미콜론(;)으로 대체하고 구현부가 없다는 의미로
abstract 키워드를 선어부에 추가한다. 
또한, 클래스가 abstract 메서드를 포함하고 있는 경우 반드시 클래스 
선언부에도 abstract 키워드를 추가해야 한다. 이런 형태의 프로그래밍
기법을 abstract method design pattern 이라 한다. 

실습4
ex)
package ch08.abs.good;

abstract class Vehicle {
	private int curX, curY;

	public void reportPosition() {
		System.out.printf("현재 위치: (%d, %d)%n", curX, curY);
	}

	public abstract void addFuel();
}

class DieselSUV extends Vehicle {
	@Override
	public void addFuel() {
		System.out.println("주유소에서 급유");
	}
}

class ElectricCar extends Vehicle {
	@Override
	public void addFuel() {
		System.out.println("급속 충전");
	}
}
//he type HorseCart must implement the inherited abstract method Vehicle.addFuel()
/*class HorseCart extends Vehicle{
	@Override
	public void addFuel() {
		System.out.println("건초 공급");
	}
}*/

public class VehicleTest {


	public static void main(String[] args) {
		Vehicle[] vehicles = { new DieselSUV(), new ElectricCar() };
		for (Vehicle v : vehicles) {
			v.addFuel();
			v.reportPosition();
		}
		// Vehicle v = new Vehicle(); // abstract 클래스는 객체를 생성할 수 없다.
		Vehicle v = new DieselSUV();  // 자식을 참조하는 것은 문제 없음

	}
}
//
주유소에서 급유
현재 위치: (0, 0)
급속 충전
현재 위치: (0, 0)



----------------------------------------------------
1.2 추상 클래스의 특징과 용도 

메서드의 구현부가 없는 메서드가 호출되면 어떻게 될까?
당연히 동작할 내용이 없기 때문에 프로그램 코드를 실행해야 하는 JVM으로서는 
당혹스러움. 따라서 abstract 클래스는 객체를 생성 못함. 
하지만, 상속 전용의 클래스가 되어 자식을 참조할수 있다. 

// Vehicle v = new Vehicle(); // abstract 클래스는 객체를 생성못함. 
Vehicle v = new DieselSUV(); // 자식을 참조하는 것은 문제 없음. 

만약, 자손클래스에서 abstract 메서드를 재정의 하지 않는다면 어떻게 되나?
자식클래스 입장에서 abstract 메서드를 물려받아서 가지고 있는 형태가 되기 
때문에 자식클래스 역시 abstract로 선언되어야 하고,
자식클래스도 객체를 생성 못한다. 

바로 여기에 추상클래스를 사용하는 이유가 등장. 
바로 구현의 강제를 통해서 프로그램의 안정성을 향상할수 있다. 

차량관리 프로젝트가 규모가 더 커져서 말이 끄는 HorseCart를 추가로 
관리한다. 이때 회사에 초급 프로그래머가 입사했고 , 그 직원에게 
HorseCart에 대한 관리 모듈을 작성하도록 지시하면서,
기존의 Vehicle이 있으니 이를 상속받아서 하면 편리할 것이라고 이야기함. 

abstract를 사용하지 않은 상태인 ch08.abs.middle.VehicleTest.java
에 있는 Vehicle을 상속 받는고 가정. 긴장한 초급 개발자가 Vehicle을 
상속받아보니 일단 프로그램이 잘 동작하는 것 같아서 addFuel()을 재정의를 
깜박함. 

class HorseCart extends Vehicle{}

결과, HorseCart 타입 객체의 addFuel() 메서드를 호출하면 
"모든 운송 수단은 연로가 필요"라늠 모호한 말만 되풀이 되며 실제 연료 
주입은 안된다. 

다시, abstract 가 적용된 상태인 
ch08.abs.good.VehicleTest.java 에 있는 Vehicle을
상속받아서 처리하는 경우를 가정. 
HorseCart가 Vehicle을 상속받으면 addFuel() 메서드를 
재정의하지 않고 서는 컴파일을 할수가 없다. 
결국, 아무리 초급개발자라고 하더라도 addFuel() 메서드를 재정의
할수 밖에 없을것.
물론, abstract class로 선언하는 방법이 있겠지만, 
이는 객체를 생성할수 없으니 원래의 의도를 벗어나게 된다. 

실습5
ex)
class HorseCart extends Vehicle {
@Override
public void addFuel() {
System.out.println("건초 공급");
}
}
// addFuel() 메서드를 오버라이딩하지 않았을 때 오류 메시지
//The type HorseCart must implement the inherited abstract
method 
//Vehicle.addFuel()

UML에서 기울여서 작성된 부분은 abstract를 의미한다. 
p276 그림에서 
오른쪽 Vehicle 클래스 와 addFuel();void 가 기울져 있다. 

abstract 클래스를 사용하는 두번째 이유는 인터페이스에 선언된 메서드중 일부 
구현 할수있는 메서드를 구현해서 개발의 편의를 제공하기 위함에 있다. 
이 부분은 인터페이스를 학습하고 다시 살펴보자. 



----------------------------------------------------
2. 인터페이스 (interface)

2.1 인터페이스의 정의

사전적으로 두 시스템 간에 만나는 접점이라는 의미.
자주 사용하느 인터페이스에는 GUI(Graphic User Interface)
가 있따. 

ex)
실습도구로 사용하는 이클립스에는 [저장] 버튼이 있다. 
이 버튼은 이클립스를 사용하는 사용자와 이클립스 사이의 인터페이스이다. 

이 버튼을 바라보는 사용자의 관점은 아마도 " 이 버튼을 클릭하면 저장이 되겠지?"
정도 일것이다. 어떤 과정을 거쳐서 저장이 이뤄지는지는 사실 별로 안궁금.
이 과정을 프로그래밍의 관점에서 생각.

어떤 일이 일어나는 것은 기능 즉 메서드에 대한 이야기.

"버튼을 클릭한다"는 것은 메서드를 호출한다는 것.
"저장된다"라는 것은 메서드의 동작 결과 즉 리턴값에 해당. 
"어떻게 저장되는지 잘 모르는 것"은 구현부가 없는 즉
abstract 상태라는 뜻. 
따라서 사용자의 현 상황을 코드로 구현하면 
"abstract void save();" 정도가 된다. 

[저장] 버튼을 가지고 있는 이클립스의 입장에서는 어떨까?
어떻게 이 버튼이 클릭되는지는 관심 밖의 사항이다. 
이클립스 내부에서는 버튼이 클릭되었을 때의 동작인 메서드의 
구현부가 작성되어 있다. 

ex)
public void save() {
// 1. 변경 정보 확인 
// 2. OutputStream을 통해 내용 저장 
// 3. 화면상에 변경 완료 표시 
}

즉 이클립스는 abstract 메서드에 대한 구현체 클래스를 가지고 있다. 
만약, 이클립스의 저장 로직이 변경되었다고 생각해보자. 
사용자 입장에서 변경될 부분은 무엇일까?
정답, 없다.!
사용자는 공개된 인터페이스를 통해 간접적으로 저장 기능을 이용하고 있었으므로
내부적인 변경과 무관하게 원래처럼 사용이 가능하다. 따라서 도구가 
업데이트되더라도 대부분은 사용법은 유지 된다. 

----------------------------------------------------
2.2 인터페이스의 작성 

인터페이스는 클래스가 아니다. 
선언부에 class 대신 interface라고 작성한다. 
인터페이스 자체로는 객체가 될 수 없기 때문에 생성자나 초기화 블록도 존재하지 않고 
멤버 변수와 메서드로만 구성된다. 
인터페이스의 멤버 변수와 메서드를 작성할 때는 지켜야 할 규칙 있다. 

인터페이스의 모든 멤버변수는 반드시 public static final 이어야 한다. 
모든 변수에 이속성들이 적용되어야 하므로 이 3개의 제어자는 생략 가능. 
멤버변수의 접근 제어자를 protected 등으로 제한 못함. 
또한, 생성자가 없기 때문에 blank final 형태로 구성 못함. 

인터페이스에 선언된 모든 메서드는 public abstract 이어야 한다. 
멤버변수와 마찬가지로 이두개의 제어자는 생략가능.

이클립스 대화상자에서 인터페이스를 작성할 때는 이클립스의 메뉴 
File -> New -> Interface를 선택. 

이 대화상자에서 보면, Modifiers 항목을 보면,
인터페이스에 사용할수 있는 접근 제어자는 클래스와 같이 public 또는 
default(package)이고 다른 제어자는 사용 못함.
Extended interfaces 항목을 보니 인터페이스는 다른 인터페이스를 
상속 받을수 있는데 개수의 제한은 없다. 

실습6
ex)
package ch08.inter;

public interface MyInterface {
	public static final int MEMBER1 = 10;
	int MEMBER2 = 10;

	public abstract void method1(int param);

	void method2(int param);
}


----------------------------------------------------
2.3 인터페이스 간의 관계 

인터페이스 간에도 클래스 사이의 관계에서 처럼 'is a'와 
'has a'관계가 존재한다. 
상속 받을 때 클래스처럼 extends 키워드를 사용.
상속에서의 차이점은 클래스 상속과 다르게 다중 상속이 지원.

클래스가 단일 상속만을 지원하는 이유는 여러 클래스에서 
상속받았을 때 메서드의 구현이 중복되는 경우 복잡도가 올라가서.
하지만, 인터페이스는 메서드 선언이 중복되더라도 구현부가 
없기 때문에 복잡도가 올라가지 않는다. 
따라서 인터페이스는 여러 개의 다른 인터페이스를 상속 가능.

실습7
ex)
package ch08.inter;

interface Fightable{
	int fire();
}

interface Transformable{
	void changeShape(boolean isHeroMode);
}

public interface Heroable extends Fightable, Transformable{
	void upgrade();
}


----------------------------------------------------
2.4 인터페이스의 구현과 객체 참조 

인터페이스는 최고 수준의 추상화 단계로 모든 메서드가 abstract 형태로 
구성되어 있으며, 이 메서드들은 클래스를 통해서 구현되어야 한다.

클래스에서 인터페이스를 구현하기 위해서는 implements 키워드를 사용함. 
인터페이스를 구현(implements)하는 클래스는 인터페이스에 선언된 
메서드를 물려받는 형태가 된다. 
abstract 클래스에서 살펴봤듯이 물려받은 abstract 메서드를 재정의하지 
않으면 컴파일 오류가 발생한다. 
또는 클래스 자체를 abstract로 표시해서 객체에 대한 생성을 포기하고 
상속 전용의 클래스로 활용할 수도 있다. 

실습8
ex)
package ch08.inter;

public class IronMan implements Heroable {
	int weaponDamage = 100;

	@Override
	public int fire() {
		System.out.printf("빔 발사: %d만큼의 데미지를 가함%n");
		return this.weaponDamage;
	}

	@Override
	public void changeShape(boolean isHeroMode) {
		if (isHeroMode) {
			System.out.println("장갑 장착");
		} else {
			System.out.println("장갑 제거");
		}
		String status = isHeroMode?"장착":"제거";
		System.out.printf("장갑 %s%n", status);
	}

	@Override
	public void upgrade() {
		int before = weaponDamage;
		weaponDamage+=weaponDamage*0.1;
System.out.printf("무기 성능 개선: %d --> %d%n",before, weaponDamage);
	}

}

참고, 
인터페이스의 메서드 
이클립스에서 인터페이스를 implements하고 메서드를 재정의하지 않으면 
오류가 표시되는데 이때 오류가 발생한 클래스 위에 커서를 살짝 올리고 
있으면 오류를 수정할수 있는 2가지 옵션을 제공. 
처음 옵션은 구현되지 않은 메서드들에 대한 stub을 추가해주고,
두번째 옵션은 클래스 자체를 abstract로 처리 해준다. 

다형성은 조상클래스의 타입으로 자식 타입의 객체를 참조할수 있는 성질. 
클래스 뿐 아니라 인터페이스 역시 조상의 타입으로 사용될 수 있다. 
따라서 위 예에서 IronMan 타입의 객체는 Object 뿐 아니라
Heroable, Fightable, Transformable로 참조된다. 

실습9
ex)
package ch08.inter;

public class IronManTest {

	public static void main(String[] args) {
		IronMan iman = new IronMan();
		Object obj = iman;
		Heroable hero= iman;
		Fightable fight = iman;
		Transformable trans = iman;
	}
}


----------------------------------------------------
2.5 인터페이스의 필요성 

인터페이스를 사용해야 하는 이유.

1) 구현의 강제로 표준화 
2) 인터페이스를 통한 간접적인 클래스 사용으로 손쉬운 모듈 교체 지원 
3) 서로 상속의 관계가 없는 클래스들에게 인터페이스를 통한 관계 부여로 
다형성 확장 
4) 모듈 간 독립적 프로그래밍으로 개발 시간 단축 

(1) 구현의 강제 
abstract 클래스에서 봤듯이 abstract 메서드는 자손 클래스들이 
반드시 재정의해서 구현해야 하는 메서드들이다. 인터페이스에 선언된 
모든 메서드들은 abstract이기 때문에 인터페이스를 구현하는 하위 클래스들은 
모두 이 메서드를 구현해야 한다. 
따라서, 실수로 필요한 기능을 빼먹는 경우가 발생하지 않는다. 

(2) 손쉬운 모듈 교체 지원 
인터페이스를 통한 간접적인 클래스 사용으로 손쉬운 모듈 교체가 가능하다.
인터페이스는 구현을 가지고 있지 않고 필요한 기능에 대해 선언만을 갖는다. 
그리고 그 인터페이스에 대한 구현체 클래스가 실제적으로 동작하게 된다. 

인터페이스를 통해서도 다형성이 적용될수 있기 때문에 프로그래밍 과정에서 
객체를 클래스로 참조하지 않고 인터페이스를 사용하게 된다면 
뒤에서 동작하는 구현 클래스가 바뀌더라도 인터페이스를 사용하는 
코드는 변경되지 않아도 된다. 
어차피 기능은 인터페이스에 선언되기 때문이다. 

예)
프린터를 사용한다 가정. 
실제로 여러 프린터 제품이 존재하지만 대부분 기능은 유사하다. 
이런 유사한 기능들은 묶어서 Printer 인터페이스를 만들고 
이 인터페이스를 구현한 LaserPrinter, DotPrinter 와 같은 제품이 존재.
만약, 평소 LaserPrinter에 대한 사용법만 알고 있다가 
DotPrinter로 변경해야 한다면 새롭게 DotPrinter에 대한 
사용법을 학습해야 한다. 

실습10
ex) 
class LaserPrinter {
public void print(String filName){
System.out.printf("LaserPrinter로 출력중:%s%n", filName);
}
}
class DotPrinter {
public void printf("DotPrinter로 출력 중 : %s%n", filName);
}
}
LaserPrinter IPrinter = new LaserPrinter();

DotPrinter dPrinter = new DotPrinter();

하지만 Printer 인터페이스를 통해 LaserPrinter를 사용하고 있었다면 
코드상에서 LaserPrinter에 대한 내용이 등장하지 않기 때문에 DotPrinter 로
변경하는데 부담이 줄어든다.

실습11
ex)
package ch08.inter.printer;

interface Printer{
	void print(String fileName);
}

class LaserPrinter implements Printer{
	@Override
	public void print(String fileName) {
		System.out.printf("Laser Printer로 출력 중: %s%n", fileName);
	}
}

class DotPrinter implements Printer{
	@Override
	public void print(String fileName) {
		System.out.printf("Dot Printer로 출력 중: %s%n", fileName);
	}
}

class PrintClient{
	private Printer printer;

	public void setPrinter(Printer printer) {
		this.printer = printer;
	}
	
	public void printThis(String fileName) {
		printer.print(fileName);
	}
}


public class PrintClientTest {

	public static void main(String[] args) {
		PrintClient pc = new PrintClient();
		pc.setPrinter(new DotPrinter());
		pc.printThis("Hello.java");
		pc.setPrinter(new LaserPrinter());
		pc.printThis("Hi.java");
	}
}
//
Dot Printer로 출력 중: Hello.java
Laser Printer로 출력 중: Hi.java

이런 특성은 자바에서 아주 많이 사용된다.
자바에서 데이터베이스를 사용하기 위해서는 JDBC(Java Database Connectivity)
라는 기술을 사용하는데 여기에도 인터페이스가 등장.  
JDBC에서 인터페이스의 역할에 대해 살펴보자. 

자바와 데이터베이스, 두개의 진영이 있다고 보자. 
자바의 개발자 입장에서는 데이터베이스를 잘 알지 못한다. 
따라서, 자바에서 데이터베이스를 사용하기 위해 어떤 내용이 
필요한지 필요한 기능의 목록 정도만 작성할 수 있다. 
이것이 자바가 제공하는 JDBC 인터페이스다. 

데이터베이스 엔지니어들은 데이터베이스에 대해 잘 알기 때문에 자바가 제공한 
JDBC 인터페이스를 구현해서 드라이버(driver)라는 것을 제공 해준다. 
Oracle이나 MySQL등 회사별로 자기 회사의 제품에 적합한 드라이버가 있다. 

이제 자바 개발자는 JDBC 인터페이스를 통해 데이터베이스 회사에서 제공하는
드라이버를 사용한다. 

프로젝트 초기에 MySQL을 이용해 프로젝트를 진행하고 있다고 가정.
하지만 코드에서는 인터페이스를 사용할 뿐이므로 MySQL 드라이버에 대한 
내용이 등장할 필요가 없다. 
따라서, 나중에 데이터베이스를 Oracle로 변경한다고 할 때 우리 코드의 변경사항은 
거의 없을 것이다. 

(3) 다형성 확장 

세번째로 서로 상속 관계가 없는 클래스들에게 인터페이스를 통한 관계를 맺어서 
다형성을 확장할수 있다. 자바에서 클래스들에게 상속이란 단 한번만 사용할 수 있는 
매우 소중한 자원이다. 자바는 단일 상속만 지원. 

다음은 HandPhone 계열과 DigitalCamera 계열의 상속 관계도이다. 
두 클래스 모두 클래스의 상속을 통해서만 관계가 맺어졌고 각각 charge()
메서드를 통해 충전가능. 

여러 대의 HandPhone과 DigitalCamera를 관리하기 위해 배열을
쓴다고 가정. 
각각 최초 Object를 상속받은 것을 제외하고는 중간에 연결 고리가 없기 
때문에 현재는 Object의 배열을 사용할 수밖에 없다. 
묶는 것은 지장이 없지만, Object에는 일반적으로 필요한 기능
(여기서는 charge)이 없다. 
따라서, 배열에서 빼낸후 별도로 HandPhone 또는 DigitalCamera로 형변환 후 
사용해야 한다. 

실습12
ex)
Object [] objs = {new HandPhone(), new DigitalCamera()};
for(Object obj: objs){
if(obj instanceof HandPhone) {
HandPhone phone = (HandPhone)obj;
phone.charge();
} else if (obj instanceof DigitalCamera) {
DigitalCamera camera = (DigitalCamera)obj;
camera.charge();
}
}

하지만 인터페이스는 필요하다면 몇번이고 사용할수 있다. 
위 구조는 다음과 같이 변경 해볼수 있다. 

HandPhone과 DigitalCamera는 모두 Chargeable 인터페이스
를 구현한다. 따라서 Object를 통한 관계가 아닌 Chargeable 
인터페이스를 통해 둘을 묶을수 있게 되었다. 

ex)
Chargeable [] objs = {new HandPhone(), new DigitalCamera()};
for (Chargeable obj:objs) {
obj.charge();
}

이 짧은 코드는 앞의 긴 코드를 대체한다. 
인터페이스 타입으로 배열을 만들어서 객체를 관리함으로써 굳이 charge를 
호출하기 위해 형변환을 할 필요도 없어졌다. 

실습13
ex)
package ch08.inter.relation;

class Phone{}
class HandPhone extends Phone  implements Chargeable{
	public void charge() {
		System.out.println("HandPhone 충전 중...");
	}
}

class Camera{}
class DigitalCamera extends Camera implements Chargeable{
	public void charge() {
		System.out.println("BlackBox 충전 중...");
	}
}

interface Chargeable{
	void charge();
}

public class RelationTest {
	void badCase() {
		Object [] objs = {new HandPhone(), new DigitalCamera()};
		for(Object obj: objs) {
			if(obj instanceof HandPhone) {
				HandPhone phone = (HandPhone)obj;
				phone.charge();
			}else if(obj instanceof DigitalCamera) {
				DigitalCamera camera = (DigitalCamera)obj;
				camera.charge();
			}
		}
	}
	
	void goodCase() {
		Chargeable [] objs = {new HandPhone(), new DigitalCamera()};
		for(Chargeable obj: objs) {
			obj.charge();
		}
	}
	public static void main(String[] args) {
		RelationTest lct = new RelationTest();
		lct.badCase();
		lct.goodCase();
		
	}
}
//
HandPhone 충전 중...
BlackBox 충전 중...
HandPhone 충전 중...
BlackBox 충전 중...

(4) 모듈 간 독립적 프로그래밍

모듈 간 독립적 프로그래밍으로 개발 기간이 단축된다.
회사에서 계산기를 만드는 새로운 프로젝트를 시작했다고 가정. 
사용자가 두개의 숫자를 입력하면 내부 로직을 통해 두수의 합이 
계산되고 결과가 다시 화면에 출력돼야 한다. 

이 프로젝트는 두개의 팀이 진행하기로 했다. 
한 팀은 클라이언트를 위한 UI를 개발하는 팀(이하 A팀)이다. 
또 다른 한팀은 계산기의 내부 로직을 작성하는 팀 (B팀).

어느 팀의 작업이 먼저 진행돼야 할까? A팀은 당장 입력을 받을 수는 있겠지만
더하기 로직은 구성할 수가 없었다. 그래서 B팀의 결과를 기다려야만 
다시 화면에 출력 부분을 작성할 수 있다. 
B팀 역시 화면에서 두개의 숫자가 넘어와야 다음 로직을 구현할수 있다. 
하지만 서로가 상대팀의 작업이 끝나기만을 기다릴수는 없는 노릇이다. 
두팀이 동시에 작업을 진행해야 비용이 절감될 텐데 방법이 없을까?

역시 이 때 사용하는 것이 인터페이스이다. A팀의 입장에서는 B팀의 정확한 
로직이 처음부터 필요하지는 않다. 단지 '숫자 두개를 넘겨주면 결과로 숫자 
하나를 넘겨받는다'는 정도만 필요하다. 
즉 파라미터와 리턴값만 필요할 뿐이다. 
따라서 두팀이 인터페이스에 메서드를 정한후 각자 구현하면된다. 
다음 코드는 두팀이 협의해서 작성한 인터페이스이다. 

ex)
package ch08.inter.cowork.common;

public interface Calculator {
	int add(int a, int b);
}

이제 각 팀은 작업을 개별적으로 동시에 진행하면 된다. 
A팀은 로직을 제대로 구현할 필요는 없으므로 리턴되는 결과값에는 
신경 쓰지 않았도 된다. 형식만 맞추는 것으로 충분하다. 
이렇게 구현한 클래스는 통상 stub이라고 부른다. 
stub은 아직 개발되지 않은 코드를 임시로 대치하는 역할을 한다. 
A팀은 이 stub 객체를 멤버 변수로 가지고 프로그램을 작성. 
물론, 인터페이스를 통해 이 객체를 사용한다. 

실습14
ex2)
package ch08.inter.cowork.ateam;

import java.util.Scanner;

import ch08.inter.cowork.bteam.CalculatorImpl;
import ch08.inter.cowork.common.Calculator;

class CalculatorStub implements Calculator {

	@Override
	public int add(int a, int b) {
		System.out.printf("파라미터 확인: %d, %d%n", a, b);
		return 0;
	}
}

class CalculatorClient{
	Calculator calcLogic = new CalculatorStub();
	//Calculator calcLogic = new CalculatorImpl();
	
	public void add() {
		System.out.println("첫 번째 정수를 입력하시오.");
		Scanner scanner = new Scanner(System.in);
		int a = scanner.nextInt();
		System.out.println("두 번째 정수를 입력하시오.");
		int b = scanner.nextInt();
		System.out.printf("결과: %d+%d=%d%n", a, b, calcLogic.add(a, b));
	}
}

public class CalculatorTest {

	public static void main(String[] args) {
		CalculatorClient client = new CalculatorClient();
		client.add();

	}
}
//
첫 번째 정수를 입력하시오.
1
두 번째 정수를 입력하시오.
2
파라미터 확인: 1, 2
결과: 1+2=0

B 팀은 인터페이스를 제대로 구현한 클래스를 만들 것이다. 
이런 클래스를 통상 impl이라고 부른다. 
B팀이 로직을 테스트할 때는 Scaner 등은 필요치 않다. 
B팀의 작업 결과물. 

실습15
ex)
package ch08.inter.cowork.bteam;

import ch08.inter.cowork.common.Calculator;

public class CalculatorImpl implements Calculator{

	@Override
	public int add(int a, int b) {
		System.out.printf("파라미터 확인: %d, %d%n", a, b);
		return a + b;
	}
	
}

실습16
ex2)
package ch08.inter.cowork.bteam;

import ch08.inter.cowork.common.Calculator;

public class CalculatorLogicTest {
	public static void main(String[] args) {
		Calculator calcLogic = new CalculatorImpl();
		int result = calcLogic.add(100, 200);
		System.out.printf("결과 확인: %d%n",result);
	}
}
//
파라미터 확인: 100, 200
결과 확인: 300

이로써 두팀은 병렬로 작업을 진행할수 있었고 각 팀의 작업 내용을 살펴보면 
전혀 다른 팀의 결과에 영향을 받지 않음을 알수 있다. 
이제 두팀의 작업 결과물을 합하기만 하면 프로젝트는 완성.
변경될 부분은 A팀의 작업 내용에서 기존에 
CalculatorTest.java 파일에 있는 
CalculatorClient에서 CalculatorStub을 사용하던 부분은 
CalculatorImpl로 변경하기만 하면된다. 
//before 
Calculator calLogic = new CalculatorStub();
//after 
Calculator calLogic = new CalculatorImpl();
그리고 다시 CalculatorTest.java 파일을 실행 
//
첫 번째 정수를 입력하시오.
1
두 번째 정수를 입력하시오.
2
파라미터 확인: 1, 2
결과: 1+2=3


----------------------------------------------------
2.6 인터페이스에 추가할 수 있는 다양한 메서드 

인터페이스의 작성에서 인터페이스에 선언되는 메서드는 모두 abstract
라 설명했다.
JDK 1.8 버전 부터 많은 것이 추가. default 메서드와, static 메서드 
default 메서드는 인터페이스에 포함된 구현부가 있는 일반 메서드.
만드는 방법 메서드 선언부에 default 키워드를 추가하고 일반적인 메서드 
만들 듯이 만든다. 단, 접근제어자는 public만 사용하고, 생략가능.

실습17
ex)
package ch08.inter.method;

interface DefaultMethodInterface {
	void abstractMethod();

	default void defaultMethod() {
		System.out.println("이것은 기본 메서드입니다.");
	}
}

public class DefaultMethodTest implements DefaultMethodInterface {

	@Override
	public void abstractMethod() {
		System.out.println("자식에서 반드시 재정의 필요");
	}

	public static void main(String[] args) {
		DefaultMethodTest dmt = new DefaultMethodTest();
		dmt.abstractMethod();
		dmt.defaultMethod();
	}
}
//
자식에서 반드시 재정의 필요
이것은 기본 메서드입니다.
default 메서드. 이미 구현이 완료되어서 구현 클래스에서 재정의할 
필요없다. 주의점은 언제나 public.

왜 이런 메서드가 추가 되었을까?

예)
사용하는 시스템이 좀 오래되었다 가정. 그동안 많은 요구사항이 발생했고
새롭게 반영하고 싶은 기능들이 생겼다. 이때 만약 기존에 있던 인터페이스에
새로운기능, 즉 메서드를 추가하려면 인터페이스에 대한 수정은 물론이고 
이 인터페이스를 구현하고 있는 모든 클래스에서도 해당 메서드에 대한 재정의가
필요하다. 
이런 경우 default 메서드를 사용하면 이미 완전한 메서드이기 때문에
해당 기능이 필요 없는 클래스에서는 별도의 재정의(override) 가 필요 없어진다. 

그런데, default 메서드가 들어오면서 문제가 생긴다. 원래 인터페이스를 여러 개 
구현할수 있는 이유는 인터페이스는 메서드의 구현부가 없기 때문에 동작이 충돌 
하지 않기 때문. default 메서드가 추가되면서 조상클래스
또는 여러개의 조상 인터페이스에 구현된 메서드가 충돌ㄹ하는 일이 발생 가능성이 생겨서
이런 경우는 다음의 규칙을 적용해 충돌을 피한다. 

1) 조상클래스의 메서드가 가장 높은 우선순위를 갖는다.
조상클래스의 메서드와 인터페이스의 default 메서드가 
충돌하면 default 메서드는 무시된다. 

2) 하나의 인터페이스에서 default 메서드를 제공되고 
다른 인터페이스에 충돌하는 메서드가 있는 경우(default가 아니더라도)
자식클래스는 반드시 조상의 메서드를 재정의해야 한다. 

인터페이스에 static 메서드도 추가할 수 있는데 이 메서드의 용법은 
일반 클래스에 static 메서드를 추가할 경우와 동일하다. 
즉 특별한 객체를 생성할 필요가 없기 때문에 

이 메서드를 호출하기 위해 구현체 클래스가 있을 필요도 없이 
바로 인터페이스 이름으로 호출.

실습18
ex)
package ch08.inter.method;

interface StaticMethodInterface{
	static void staticMethod() {
		System.out.println("Static 메서드");
	}
}

public class StaticMethodTest {

	public static void main(String[] args) {
		StaticMethodInterface.staticMethod();
	}
}
//
Static 메서드
인터페이스의 static 메서드를 호출하기 위해 단순히 인터페이스
이름으로 접근하고 별도의 구현체 클래스가 존재하지 않는다.

----------------------------------------------------
3. 열거형 데이터 타입

3.1 enum 의 정의와 작성법 
enum은 열거형 데이터타입. 단어 그대로 무언가를 나열한다는 뜻.
데이터가 몇가지 한정된 상수값으로 구성될 때 주로 사용된다. 
예) 
계절은 봄, 여름, 가을, 겨울의 4개 값으로 구성되고,
요일은 월, 화, 수, 목, 금, 토, 일의 7개 값으로 구성.
이런 형태의 값들을 한번에 관리하기 위해 사용하는 데이터타입이 
Enum, 즉 열거형이다. 

열거형 데이터 타입은 내부적으로 java.lang.Enum 클래스
를 상속받고 있다. 
따라서 별도로 다른 클래스를 상속 받을수 없다. (단일상속만)
작성할 때도 class 대신 enum 키워드를 사용한다. 

enum 내부에는 사용할 값들을 상수 형태로 나열.
이 값들은 'enum 상수'라고 불리며 상수의 이름 작성법에 따라 
일반적으로 대문자로 쓰고, 단어 연결 시는 '_'를 사용한다. 
이 enum 상수 하나하나가 enum 타입의 객체가 된다. 
각각의 enum 상수에 접근할 때는 상수 답게 " Enum_이름.상수명"
의 형태로 접근.

실습19
ex)
enum Grade {
SALES, PART_TIME_JOB, NORMAL
}
System.out.println(Grade.SALES);

이클립스에서 enum을 작성할 때는 이클립스 메뉴
File -> New -> Enum을 선택.

enum 은 일반적인 클래스와는 여러 면에서 다른 점이 있다.
일단 제어자는 접근제어자 에서 public과 default(package)만 
사용가능. 이미 java.lang.Enum 을 상속받고 있어서,
추가로 다른 클래스를 상속 받을수 없다. 
여러 인터페이스를 구현하는 것은 상관이 없다. 

enum 타입을 사용할때는 클래스와 동일하게 선언하며 할당될수 있는 값은 
enum 상수와 null 값으로 한정된다.

실습20
ex)
package ch08.enume;

enum Grade {
	SALES, PART_TIME_JOB, NORMAL
}

public class GradeEnumTest {
	private static final int SALES = 100;
	private static final int PART_TIME_JOB = 200;
	private static final int NORMAL = 300;

	private static final int SPRING = 100;

	public void calcSalNormal(int grade) {
		if (grade == SALES) {
			System.out.println("영업 실적 반영");
		} else if (grade == PART_TIME_JOB) {
			System.out.println("근무 시간 반영");
		} else if (grade == NORMAL) {
			System.out.println("근로 계약 기준");
		}
	}

	public void calcSalEnum(Grade grade) {
		if (grade == Grade.SALES) {
			System.out.println("영업 실적 반영");
		} else if (grade == Grade.PART_TIME_JOB) {
			System.out.println("근무 시간 반영");
		} else if (grade == Grade.NORMAL) {
			System.out.println("근로 계약 기준");
		}
	}

	public static void main(String[] args) {
		Grade grade = Grade.SALES;
		System.out.println(grade);
		System.out.println(grade instanceof Enum); // true
		System.out.println(grade instanceof Object); // true

	}
}
//
SALES
true
true

enum 을 선언할 때는 다른 클래스의 외부뿐 아니라 클래스 
내부에도 선언 가능. 이때 외부클래스 에서 해당 enum 상수에
접근하기 위해서는 "외부클래스_이름.내부 enum_이름.enum_상수명"
의 형태로 사용.
참고, 일반클래스도 하나의 클래스 내부에서 또 다른 클래스를 선언가능.
이것을 내부클래스 (inner 클래스)라고 부른다.
내부클래스에 대한 자세한 내용은 10장에서 다룬다. 

실습21
ex)
package ch08.enume;

public class InnerEnumTest {
	enum MyEnum {
		DATE, BIRTH_DATE
	}

	public static void main(String[] args) {
		System.out.println(MyEnum.DATE);
	}
}

class OuterClass {
	public void useInnerEnum() {
		System.out.println(InnerEnumTest.MyEnum.BIRTH_DATE);
	}
}
//
DATE

----------------------------------------------------
3.2 enum 상수의 필요성 

enum을 사용하는 이유?
예)
직군에 따라 급여를 계산하는 방식의 다른 애플리케이션이 있다.
영업직, 일반직, 아르바이트의 3가지 구분을 두고 급여를 계산할 때 
다음과 같이 상수로 직군을 구분해서 작성한다. 

ex)
public static final int SALES = 1;
public static final int PART_TIME_JOB = 2;
public static final int NORMAL = 3;
// 직군그룹 , 값 충돌 발생: 1은 누구?

public static final int SEASON = 1; //계절그룹
public void calcSalNormal(int grade) {
if(grade == SALES) {
System.out.println("영업 실적 반영");
}else if(grade == PART_TIME_JOB) {
System.out.println("근무 시간 반영");
}else if (grade == NORMAL) {
System.out.println("근로 계약 기준");
}
}

SALES, PART_TIME_JOB, NORMAL 등은 변경되지 
않을 값들이기 때문에 final이고, 어디서나 접근이 쉽도록 
public static이 추가되었다. 네번째 상수로 앞의 상수들과는 
어울리지 않는 SEASON도 있는데 값은 SALES와 동일하다.
만약, calcSalNormal() 메서드를 다음과 같이 호출하면 
어떻게 될까?
ex)
calcSalNormal(SALES);
calcSalNormal(SEASON);

둘은 모두 실제적으로는 1이라는 값을 갖기 때문에 결과는 동일.
하지만, SALES가 급여를 받는 것은 맞지만, SEASON이 급여를 
받는 것은 이해하기 어렵다.
calcSalNormal()에는 SALES, PART_TIME_JOB, NORMAL
중 하나가 들어가야 최초의 의도에 적합하다. 하지만 엉뚱한 값이 
연결되더라도 오류가 발생하지 않는다. 이로써 잠재적인 결함이 발생 할수있다. 
이런 것을 논리적 오류라고 한다. 
calcSalNormal()이 int 타입이라면 어떤 것이든 파라미터로 받을수
있기 때문에 발생하는 일이다.

위의 enum을 이용한다면 급여를 계산하는 메서드는 다음처럼 
바꿀수 있다. 

ex)
enum Grade{
SALES, PART_TIME_JOB, NORMAL
}

public void calcSalEnum(Grade grade){//SEASON 정보 할당불가
if ( grade == Grade.SALES) {
System.out.println("영업 실적 반영");
}else if ( grade == Grade.PART_TIME_JOB) {
System.out.println("근무시간반영");
} else if (grade == Grade.NORMAL) {
System.out.println("근로계약기준");
}
}

별로 달라진 점이 없어 보이기도 한다. 
눈에 보이는 차이점은 먼저 단순히 변수로 관리 되던 것들은 
모아서 enum 타입으로 관리되었다.
중요한 차이점은 enum을 이용하면 비교할때 단순히 값만을
비교하는 것이 아니라 타입까지 비교한다는 점. 

calcSalEnum() 호출할 때는 반드시 Grade에 선언된 값 중 
하나만 할당될수 있다. 
이렇게 enum을 이용하면 값과 함께 타입에 대한 체크를 동시에 
진행함으로써 안정적인 프로그래밍 가능.


----------------------------------------------------
3.3 enum 상수를 이용한 연산 

enum 상수는 주로 비교 연산에서 사용.
두개의 enum 값이 같은지 파악할때는 == 연산자 또는 
equals 메서드를 사용.
하지만 기타 부등호 연산자는 사용할수 없다.
대신 상수가 정해진 순서를 이용해서 비교할 수 있는데
이때는 객체 간 비교이므로 부등호 대신 enum 클래스에 선언된 
compareTo() 라는 메서드를 사용할 수 있다. 
각각의 enum 상수들은 선언된 순서대로 ordinal(순서)
값을 갖는데 인덱스와 유사하게 0부터 시작하는 정수값이다.
compareTo()는 이 ordinal 값의 차이를 리턴한다. 

switch ~ case 문의 비교 조건에도 enum이 많이 사용되는데 
주의할점 여기서는 타입 없이 바로 상수값만 이용한다. 

실습22
ex)
package ch08.enume;

enum Season {
	SPRING, SUMMER, FALL, WINTER
}

public class SeasonEnumTest {
	public void compareEnum(Season season) {
		if (season.equals(Season.SPRING)) {
			System.out.println("따뜻한 봄날입니다.");
		} else if (season.compareTo(Season.WINTER) < 0) {
			System.out.println("최소한 겨울은 아니잖아요.");
		} else {
			System.out.println(season.compareTo(Season.WINTER));
		}
	}

	public void enumSwitch(Season season) {
		switch (season) { // switch 문에서는 enum 이름 생략 
		case SPRING:
			System.out.println("새 잎이 나는 시기");
			break;
		case SUMMER:
			System.out.println("열매가 무르 익는 시기");
			break;
		case FALL:
			System.out.println("잎이 떨어지는 시기");
			break;
		default:
			System.out.println("겨울잠을 자는 시기");
		}
	}

	public static void main(String[] args) {
		SeasonEnumTest set = new SeasonEnumTest();
		set.compareEnum(Season.FALL);
		set.enumSwitch(Season.SPRING);
		System.out.println(Season.WINTER.ordinal());
	}

}
//
최소한 겨울은 아니잖아요.
새 잎이 나는 시기
3
----------------------------------------------------
3.4 enum 메서드 

enum 타입들은 java.lang.Enum 클래스를 기본적으로 상속받고 
있어서 java.lang.Enum 클래스에 선언된 메서드들의 사용이 가능.

java.lang.Enum의 메서드 
메서드 명 :  선언부와 설명 
name() : public final String name()
enum 상수의 이름을 문자열로 리턴.

ordinal() : public final int ordinal()
0부터 시작하는 enum 상수의 순서를 리턴.

compareTo() : public final int compareTo(E o)
enum 상수의 ordinal 차이를 리턴.

values() : public static T [] values()
enum 타입에 선언된 enum 상수를 배열로 리턴. 

valueOf() : public static < T extends Enum <T> >
T valueOf(Class<T> enumType, String name)
문자열로 매핑된 enum 상수 객체를 리턴한다. 

실습23
ex)
package ch08.enume;

enum Tea {
	COFFEE, BLACK_TEA, GREEN_TEA
}

public class EnumMethodTest {
	public static void main(String[] args) {
		Tea[] teaArray = Tea.values();
		for (Tea tea : teaArray) {
			String strName = tea.name();
			System.out.printf("이름: %s%n", strName);
			System.out.printf("등장 순서: %d%n", tea.ordinal());
			// 문자열을 다시 Enum 타입으로
			Tea reTea = Tea.valueOf(strName);
			System.out.printf("원래의 객체와 같은가?- reTea.equals(tea): %b%n", reTea.equals(tea));
		}
	}
}
//
이름: COFFEE
등장 순서: 0
원래의 객체와 같은가?- reTea.equals(tea): true
이름: BLACK_TEA
등장 순서: 1
원래의 객체와 같은가?- reTea.equals(tea): true
이름: GREEN_TEA
등장 순서: 2
원래의 객체와 같은가?- reTea.equals(tea): true


----------------------------------------------------
3.5 enum 멤버 추가 

enum에도 사용자가 원하는 멤버를 추가해서 사용가능.
enum 상수 하나하나가 객체임을 신경쓴다면 작성 및 사용법은 
일반 클래스에서의 메서드 작성과 동일하다. 
주의점은 단순히 enum 상수들만을 정의할때는 마지막에 세미콜론(';')
이 필요 없지만, 별도로 멤버를 추가하는 경우에는 세미콜론을 
추가해서 상수 선언이 끝나는 것을 표시해줘야 한다. 

실습24
ex)
package ch08.enume;

enum Greeting {
	GOOD_MORNING, GOOD_AFTERNOON, GOOD_EVENING;
	//세미콜론 주의 
	String message;
	
	public Greeting nextGreeting() {
		if(this.equals(GOOD_EVENING)) {
			return GOOD_MORNING;
		}else if(this.equals(GOOD_AFTERNOON)) {
			return GOOD_EVENING; //각각의 객체 즉 enum 상수의 멤버가된다.
		}else {
			return GOOD_AFTERNOON;
		}
	}
}

public class CustomMemberTest {
	public static void main(String[] args) {
		Greeting current = Greeting.GOOD_AFTERNOON;
		current.message = "Hello";
		Greeting next = current.nextGreeting();
		next.message = "Hi";
		System.out.printf("지금: %s, 메시지: %s%n", current, current.message);
		System.out.printf("다음: %s, 메시지: %s%n", next, next.message);
	}
}
//
지금: GOOD_AFTERNOON, 메시지: Hello
다음: GOOD_EVENING, 메시지: Hi

----------------------------------------------------
3.6 생성자를 이용한 enum 상수 초기화 

enum에 추가한 멤버변수를 enum 생성자에서 초기화해서 사용가능.
주의, enum의 생성자의 접근제어자는 언제나 private이며 생략가능.
따라서 외부에서 해당 생성자를 호출할수 없고, 내부에서 상수를 정의하면서 
바로 파라미터를 전달한다.

실습25
ex)
package ch08.enume;

enum Family {
	FATHER("아빠"), MOTHER("엄마"), SON("아들"), DAUGHTER("딸");
	private String kor;
	
	Family(String kor){ //내부에서만 호출가능
		this.kor = kor;
	}

	public String getKor() {
		return kor;
	}

	public void setKor(String kor) {
		this.kor = kor;
	}
}

public class UseConstructorTest {
	public static void main(String[] args) {
		Family current = Family.MOTHER;
		System.out.printf("값 확인: %s, kor: %s%n", current, current.getKor());
		current.setKor("어머니");
		System.out.printf("값 확인: %s, kor: %s%n", current, current.getKor());
	}
}
//
값 확인: MOTHER, kor: 엄마
값 확인: MOTHER, kor: 어머니


----------------------------------------------------
4. 애노테이션 (annotation)

4.1 애노테이션

사전적의미 '주석'. 자바의 주석 형태로는 이미 단일 행주석(//),
다중 행 주석(/*...*/), javaDoc 주석(/**...*/) 있다.
또, 주석 
애노테이션은 개발자가 읽기 위한 주석이 아니라 JVM, 컴파일러, 
프레임워크 등에게 전달되는 일종의 메타데이터 이다.
메타데이터 란 (metadata)란 다른 데이터를 설명해주는 데이터로 
속성 정보라한다. 즉, 부가적인 정보를 추가하기 위해 그 데이터와
함께 제공 되는 것이다. 예를 들어 사람은 나이라는 데이터가 있는데 
나이는 1년씩 늘어난다와 같은 설명은 메타데이터가 된다.

예)
스프링(Spring)이라는 자바 프레임워크에서 단위 테스트를 위한 
클래스에 적용된 애노테이션의 예 
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations =
{"file:src/main/webapp/WEB-INF/mvc-config.xml"})
@WebAppConfiguration
public class RequestMappingTest {
..
}

클래스 선언부에 잔뜩 @로 시작하는 애노테이션들이 가득하다.
이처럼 애노테이션은 소스 코드에 라벨을 붙여 놓은 형태이며 코드에 대한 
부가적인 정보를 제공한다. 
이 정보를 JVM, 컴파일러, 프레임워크 등이 읽어서 소스 코드의
구조를 변경하기도 하고 환경설정 정보를 추가하기도 한다. 

----------------------------------------------------
4.2 JDK 에 포함된 기본 애노테이션

대부분 애노테이션은 별도의 프레임워크에서 제공된다. 따라서 
우리가 JDK를 통해 직접 사용해볼 애노테이션이 많지는 안다.
JDK에서 제공되는 대표적인 애노테이션들은 다음과 같다. 

애노테이션   :   설명 
@Override : 컴파일러에게 재정의된 메서드라고 알려준다.
@Deprecated : 앞으로 없어질수 있으니 사용을 자제하라고 알려준다.
@SupressWarnings : 컴파일러에게 특정 경고 메시지를 무시하라고 알려준다
@FunctionalInterface : 함수형 인터페이스라는 것을 알려준다.
(Lambda 참조)

@Override는 메서드 재정의에서 잠깐 언급한 바가 있다. 
컴파일러에게 ' 이 메서드는 재정의한 메서드이니 형식에 맞는지 
컴파일할 때 확인하세요.' 라는 요청을 전달한다.
따라서 @Override를 사용했는데 메서드 이름에 오타가 
있는 등 재정의 방법에 어긋나게 작성하면 오류가 발생한다.
이로써 안정적인 메서드 재정의가 가능하다.

실습26
ex)
package ch08.annotation;

class SuperClass{
	protected void someMethod() {}//오버라이드 실패 
}
public class SafeOverrideTest extends SuperClass{
	//@Override
	void someMeth0d() {}
	//The method someMeth0d() of type SafeOverrideTest must override or implement a supertype method
}

@Override가 someMeth0d에 선언되어 있고,
원래 조상메서드는 someMethod이므로 이름이 달라서 
메서드 재정의 실패. 컴파일러는 이를 파악하고 오류 메시지를 
발생시키며 컴파일이 진행되지 않는다. 
@Override 애노테이션을 주석 처리하면 오류는 없어지지만,
메서드 재정의와는 상관없이 새로운 메서드가 추가.

상속 범위 private -> default -> protected -> public

Deprecated란 원래 사용하던 메서드에 대해 앞으로 없어질 수 있으니 
더이상 사용하지 않도록 권고한다는 말. 보안적인 이슈가 발생했거나
더 좋은 성능의 메서드로 대체를 권장할때 사용된다.
메서드 선언부에 @Deprecated가 추가된 메서드를 사용하게 되면 
컴파일러가 경고 메시지를 출력한다. 

실습27
ex)
package ch08.annotation;

import java.util.Date;

class SomeClass{
	@Deprecated
	public void oldMethod() {}
}

public class DeprecatedTest {
	public static void main(String[] args) {
		SomeClass sc = new SomeClass();
		sc.oldMethod();
		
		new Date(2000, 01, 01);		
	}
}

@SupressWarnings 은 말 그대로 경고를 막겠다는 표시.
프로그래밍하다 보면 다양한 경고 메시지를 볼수 있는데 이때
경고 내용에 대해 이미 알고 있으니 보여주지 않아도 된다는 뜻.

ex)
package ch08.annotation;

public class SupressWarningTest {
	@SuppressWarnings(value="unused")
	public void method1() {
		int i = 0; // The value of the local variable i is not used
	}
	
	// @SuppressWarnings(value="unused") // 배열이지만 할당하려는 값이 하나인 경우 중괄호 생략 가능
	// @SuppressWarnings(value={"unused", "rawtypes"}) // 배열 형태의 값 할당
	@SuppressWarnings({ "unused", "rawtypes" }) // 할당하려는 속성이 하나인 경우 value 생략 가능
	public void method2() {
		int i = 0; 
		java.util.List list;
	}
}

int 타입의 변수 i를 선언했지만 사용한 적이 없다. 
이 경우 컴파일러는 값이 사용된 적이 없다는 경고 메시지를 출력.
이 경고를 보고 싶지 않다면 5행처럼 @SuppressWarnings
애노테이션에 'unused' 파라미터를 전달한다. 

@FunctionalInterface 는 함수형 인터페이스 선언에 활용되는 
애노테이션으로 10장에서 다룬다. 

----------------------------------------------------
4.3 애노테이션 구성요소

3개의 애노테이션 사용 했음. 사용법 조금씩 다름.
@Deprecated , @Override 경우 메서드 선언부에 
애노테이션 작성.
@SuppressWarnings의 경우는 로컬 변수의 위치에 작성하고 
파라미터까지 전달하고 있다. 사용법의 차이는?
그래서, @SuppressWarnings 를 좀더 살펴보자. 
중요한 애노테이션은 아니지만 사용법을 알기에 좋다. 

ex)
메타 애노테이션
@Target({TYPE, FIELD, METHOD, PARAMETER,
CONSTRUCTOR, LOCAL_VARIABLE})
@Retention(RetentionPolicy.SOURCE)

애노테이션 선언 
public @interface SuppressWarnings {
String[] value(); //애노테이션 속성
}

애노테이션 만들 때는 interface 선언과 유사하게 @interface
라고 선언한다. 애노테이션은 크게 선언부에 추가된 @Target, @Retention
과 같은 메타 애노테이션과 애노테이션 블록에 선언된 속성 정보로 구성.

속성 정보는 애노테이션의 바디 영역에 마치 추상 메서드 형태로 작성.
@SuppressWarnings 는 value 라는 속성이 하나 선언되어 있다. 
메서드의 이름인 value가 속성의 이름이고, 리턴 타입인 String[]이 
속성의 타입이다. 

이 속성을 사용할때 다른 속성들처럼 애노테이션을 선언할 때
'키 = 값' 형태로 전달한다. 만약 할당하려는 속성이 value 
하나뿐이면 키인 value를 생략하고 바로 값만 설정할수도 있다. 

값을 할당할때는 일반적인 자바의 자료형을 사용가능. 
다만 배열을 표현할때는 대괄호([]) 대신 중괄호({})로 
묶어서 표현하고 만약 그 값이 하나만 있으면, 즉 배열의 길이가 
1일 경우는 중괄호를 생략할수 있다. 따라서 위 
@SuppressWarnings는 다음처럼 다양하게 선언가능. 

ex)
//키 = 값 형태로 배열 할당 
@SuppressWarnings(value = {"unused","rawtypes"})
// 배열이지만 값이 하나인 경우는 중괄호 생략 가능 
@SuppressWarnings(value = "unused")
//할당하려는 속성이 value 하나인 경우 키 생략 가능 
@SuppressWarnings({"unused","rawtypes"})

또한, 속성에 기본값(default)을 설정해 놓을 수 있는데 
이런 경우 속성 설정을 생략할수있다. 
하나의 애노테이션에 여러 개의 속성이 있을수 있는데 쉼표를 이용해서 
속성들을 구분가능.

ex)
@annotationName(param1 = "value1", param2="value2")

애노테이션 선언부에는 대부분 @Target과 @Retention 같은 
메타 애노테이션(애노테이션의 정보를 표시하는 애노테이션)이 있다.
마치 상속처럼 메타 애노테이션의 속성은 대상 애노테이션에 전판된다. 
애노테이션을 잘 사용하기 위해서는 특히 @Target 정보가 중요하다.

@Target은 애노테이션을 어디에서 사용할수 있는가를 나타낸다. 
@Target의 소스코드.
ex)
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Target {
ElementType[] value();
}

@Target은 ElementType[] 타입의 value 속성을 가지며 
모든 애노테이션은 각자 value에 지정된 ElementType에만 선언될수
있다. ElementType은 enum 타입으로 가지고 있는 enum
상수값은 다음과 같다. 

ElementType 의 종류 
상수값		:	범위
TYPE : 클래스, 인터페이스(annotation type 포함)또는 enum 타입 
FIELD : 필드 또는 enum 타입의 값 
METHOD : 메서드 
PARAMETER : 메서드의 파라미터
CONSTRUCTOR : 생성자 
LOCAL_VARIABLE : 로컬변수
ANNOTATION_TYPE : 다른 애노테이션
PACKAGE : 패키지

따라서 @Target 애노테이션은 자신의 @Target에 할당된 
value가 ANNOTATION_TYPE이기 때문에 다른 애노테이션
설정에만 올수있고, @SuppressWarnings의 경우 
@Target의 value가
{TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR,
LOCAL_VARIABLE}이기 때문에 클래스 등 타입, 멤버 변수,
메서드, 파라미터, 생성자, 로컬변수 등에 올수 있다. 

@Retention은 얼마나 오랫동안 애노테이션 정보를 유지할 것인지
나타낸다.
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Retention {
RetentionPolicy value();
}

@Retention의 @Target 정보가 ANNOTATION_TYPE 이므로 
다른 애노테이션에만 사용가능. value 속성은 RetentionPolicy가 
하나 할당될 수 있는데 이것 역시 enum 타입으로 다음의 상수들이 정의 
되어 있다. 

RetentionPolicy의 enum 상수값 

상수값  :		적용범위
SOURCE : 컴파일러가 사용하며 결과물인 클래스 파일 안에는 
포함되지 않음 
CLASS : 컴파일시 클래스 안에 포함되나 VM에서 무시하며 
리플렉션(reflection)시 정보를 얻을수 없음 
RUNTIME : 컴파일시 포함되고 VM에서 인식하며 리플렉션 시
정보를 얻을수있음. 

리플렉션은 메모리에 생성된 객체를 통해서 거꾸로 클래스의 
정보를 분석해 내는 프로그래밍 기법이다.
이를 통해서 객체가 가지는 멤버변수, 메서드 등의 정보를 알수있다. 
주로 자동화된 툴을 만드는 일 등에서 많이 사용된다. 

우리가 일반적으로 컴파일러를 건드릴 일은 없기 때문에 
대부분 사용자 정의 애노테이션은 RUNTIME 까지 정보를 유지하고 
리플렉션을 통해서 작업을 처리한다. 
리플렉션의 자세한 내용은 java.lang.reflect API를 참조. 

----------------------------------------------------
4.4 사용자 정의 애노테이션 사용 

직접 애노테이션을 만들어 사용해보자.
만들어볼 애노테이션은 멤버변수에 설정하며 멤버변수의 용도(web 또는 db)
에 따라 자동 분류되도록 지원한다. 또한, 아직 값이 할당되지 않았을 때 
기본값이 할당될수 있도록 지원하는 기능도 갖도록 할것이다. 

이클립스에서 애노테이션을 생성하는 대화상자를 이용하기 위해서는
File -> New -> Annotation 선택 
혹시, 메뉴가 나오지 않을 경우 Other 선택후 filter 
항목에서 Annotation을 검색. 

Name : MyPropLabel 
Modifiers : public
Add @Retention : Runtime
Add @Target : Field 
이름이나 패키지, 접근제어자 설정은 클래스와 동일. 
추가로 메타 애노테이션인 @Retention과 @Target에 
대한 설정이 가능.
리플렉션을 사용할 예정이기 때문에 
@Retention은 Runtime을 선택. 
멤버변수에 사용할 계획이므로 @Target에서는 Field에 체크.

ex)
package ch08.annotation.custom;

import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

import java.lang.annotation.Retention;
import java.lang.annotation.Target;

@Retention(RUNTIME)//유효기간이 RUNTIME으로 설정되어 리플렉션 적용 가능 
@Target(FIELD)//적용대상이 FIELD라서 멤버변수에 적용가능.
public @interface MyPropLabel {
String value();//애노테이션은 String 타입의 value 속성을 갖는다.
기본값이 없으므로 애노테이션 적용시 반드시 값을 지정해야 한다. 

String strDefault() default "아직 값 설정 전";
}// strDefault는 String 타입의 속성으로 default 값을 
가지고 있으므로 반드시 설정해야 할 필요는 없다. 

정의된 애노테이션 적용 

실습28
ex2)
package ch08.annotation.custom;

public class CustomPropSet {
	@MyPropLabel("db")
	String dbHost="127.0.0.1";
	@MyPropLabel(value="web", strDefault="localhost")
	String serverHost;
	@MyPropLabel("db")	
	String dbPort;
	@MyPropLabel(value="web", strDefault="8080")	
	String serverPort;
}
애노테이션이 적용된 속성들을 어떻게 써먹을지 고민해보자. 
우리는 MyPropLabel에 얼마나 많은 멤버가 있는지 상관없이
순식간에 web 용도와 db 용도로 사용되는 변수들을 구별해 낼 것이다.
또한, 값이 할당되지 않은 변수들에 대해서 strDefault에 해당하는 
값들로 설정할 계획이다. 

다음 예는 리플렉션을 이용해 위 기능들을 구현. 

실습29
ex3) 
package ch08.annotation.custom;

import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

public class UseCustomAnnotationTest {

	public static void main(String[] args) throws Exception {
		CustomPropSet cps = new CustomPropSet();
		Map<String, Object> dbProp = new HashMap<>();
		Map<String, Object> webProp = new HashMap<>();

		Field[] fields = CustomPropSet.class.getDeclaredFields();
		for (Field field : fields) {
			MyPropLabel annotation = field.getDeclaredAnnotation(MyPropLabel.class);
			if (field.get(cps) == null) {
				field.set(cps, annotation.strDefault());
			}
			if (annotation.value().equals("web")) {
				webProp.put(field.getName(), field.get(cps));
			} else {
				dbProp.put(field.getName(), field.get(cps));
			}
		}
		System.out.printf("DB 관련 변수: %s%n", dbProp);
		System.out.printf("WEB 관련 변수: %s%n", webProp);
	}
}
//
DB 관련 변수: {dbPort=아직 값 설정 전, dbHost=127.0.0.1}
WEB 관련 변수: {serverPort=8080, serverHost=localhost}

지금까지 사용자 정의 애노테이션을 만들고 사용법에 대해 알아보았다. 
많은 경우 애노테이션은 시스템이나 프레임워크 등에서 제공하는 것을 
사용하는 정도가 일반적이다. 
더구나 위 내용은 뒤에 배울 API들을 많이 포함하기 때문에 현재 
단계에서는 이해하기 어려운 측면이 있다. 
실망하지 말고 뒷부분까지 학습한 후 다시 살펴보는 것도 좋다. 

----------------------------------------------------
5. 제너릭

5.1 제너릭의 필요성 
제너릭(Generic : 일반화)은 JDK 1.5 버전에서 등장.
당시에는 아주 획기적인 기능.
제너릭을 사용하면 컴파일 시점에 사용할수 있는 객체의 타입을 체크하기 때문에 
프로그램의 안전성이 획기적으로 향상되고 코드도 줄어든다. 
앞으로 언급하게 될 컬렉션 프레임워크, 람다식 등 API 전반에 걸쳐
사용되므로 반드시 잘 이해해야 한다. 
특히 제어자들이 적용된 복잡한 제너릭의 경우 잘 이해하지 못하면 
메서드를 사용할수 없게 된다. 

예)
마트에서 장난감과 식료품 구매 가정. 
물건을 사면 포장용 상자에 담는다.
담을 때 별다른 생각없이 아주 편리하게 담을수 있다. 
집 도착후, 열어본 상자에는 '물건'들이 담겨있고, 
하나를 빼낼 때 정확히 어떤 물건(장난감 또는 식료품)
이 나올 줄은 모른다. 물건을 정리하기 위해서는 하나씩 물건을
보고 확인해야 한다. 
과정에 필요한 것이 instanceof 연산자의 활용이고, 잘못되면 
ClassCastException이 발생. 

뭐든지 담을수있는 상자의 편리함과 번거로움.

실습30
ex)

package ch08.generic.type;

class Toy{}
class Grocery{}

class NormalBox{
	private Object some;
	public Object getSome() {
		return some;
	}
	public void setSome(Object some) {
		this.some = some;
	}
}

public class NormalBoxTest {
	
	public static void main(String[] args) {
		NormalBox nBox1 = new NormalBox();
		nBox1.setSome(new Toy());
		Object some = nBox1.getSome();
		if(some instanceof Toy) {
			Toy toy = (Toy)some;
			// toy 사용
		}else if(some instanceof Grocery) {
			Grocery grocery = (Grocery)some;
			// grocery 사용
		}else {
			System.out.println("알수 없음");
		}
		nBox1.setSome("Hello");
	}
}

이처럼 Object를 저장하는 일반적인 상자는 모든 객체를 
담을수있는 편리함이 있지만, 나중에 객체를 사용할 때에는 
어떤 객체인지 확인하고 사용해야 하는 번거로움이 있다. 

애초에 상자에 장난감, 식료품이라고 라벨을 붙였다면 어떨까?
그렇게 되면 담는 과정에서 상자별로 정확히 담아야 한다. 
장난감은 장난감 상자에, 식료품은 식료품 상자에 담길것이다. 
설마 장난감에 식료품을 담지는 않았을 것이다. 
이제 집에 와서 정리할 때 식료품 상자에서 빼낸 물건은 당연히 
식료품일 테니 확인할 필요가 없다. 
이렇게 상자에 라벨을 붙이는 개념이 바로 제너릭이다. 

제너릭은 미리 사용할수 있는 타입을 명시해서 컴파일 타임에 
타입을 체크한다. 
따라서 런타임에 발생할수 있는 ClassCastException이 
발생하지 않는다. 또한, 나중에 찾아서 쓸 때 형변환을 하지 않아도 
되도록 한다. 즉 instanceof를 이용해 객체의 타입을 비교할 
필요가 없어서 소스 코드가 간단해진다. 

이제 제너릭은 클래스 또는 인터페이스, 메서드의 파라미터, 메서드의 
리턴타입에 사용된다. 

---------------------------------------------------- 
5.2 제너릭 타입 

(1) 제너릭 타입의 작성과 객체 사용 
클래스와 인터페이스에 제너릭이 적용된 타입을 제너릭 타입이라고 한다. 
제너릭 타입은 클래스 및 인터페이스 이름 뒤 '<>'를 쓰고
내부에 타입 파라미터를 명시한다. 

ex)public class Class_Name<T> {}
public interface Interface_Name <T> {}

제너릭 타입과 상대적으로 제너릭을 사용하지 않은 상태를 원시 타입(Raw Type)
이라고 한다. 

위에서 T라고 쓰인 부분이 타입 파라미터 선언이다. 
일반적으로 타입 파라미터는 상징성을 나타내는 대문자 알파벳 하나를
사용하는데 여기서는 타입(Type)의 의미로 사용했다. 
작성자가 임의로 지정하는 것이기 때문에 꼭 T라고 써야 하는 것은 아니다. 
일반적으로 참조 타입을 말할때 T(Reference Type),
요소를 말할때 E(Element),
키를 이야기할 때 K(Key),
값을 나타낼 때 V(Value)를 쓰지만, 딱히 정해진 것은 아니다. 

예) 컬렉션 프레임워크의 클래스인 ArrayList와 HashMap 클래스에 
선언된 타입 파라미터의 예이다. 

ex)
public class ArrayList<E> extends AbstractList<E>
implements List<E>, RandomAccess, Cloneable,
java.io.Serializable{..}

public class HashMap<K,V> extends AbstractMap<K,V>
implements Map<K,V>, Cloneable, Serializable{..}

타입 파라미터는 클래스를 작성하는 시점에서는 무엇인지 알수없다.
나중에 그 클래스를 이용해서 객체를 만들 때 타입 파라미터가 전달되고 
형식이 결정된다. 

제너릭 타입의 객체를 만들때는 타입 선언시 타입 파라미터 부분에 실제 사용할 
객체 타입을 적는다. 사용하는 생성자 쪽에는 타입 파라미터를 적을수도 있고
생략할수도 있다. 
단, 타입을 적을 때는 클래스에 선언한 타입 파라미터와 같은 타입을 적는다. 
ex)
Class_Name<String> generic = new class_Name<String>();
Class_Name<String> generic2 = new class_Name<>();
Class_Name generic3 = new Class_Name();

위의 예에서 세번째 경우처럼 제너릭 타입의 클래스를 선언할때 제너릭 타입을
사용하지 않고 원시 타입을 사용하면 이클립스에서 경고를 출력.
가급적 제너릭 타입을 사용하자. 

앞의 NormalBoxTest 예제를 변경한 GenericBoxTest를 보자.

실습31
ex)
package ch08.generic.type;

import java.util.ArrayList;

class Toy2 {}
class Grocery2 {}

class GenericBox<T> {
	private T some;
	public T getSome() {
		return some;
	}
	public void setSome(T some) {
		this.some = some;
	}
}

public class GenericBoxTest {
	public static void main(String[] args) {
		GenericBox<Toy2> gBox1 = new GenericBox<>();
		gBox1.setSome(new Toy2());
		//Toy2만 할당가능
		Toy2 toy = gBox1.getSome();
		// toy 사용
		GenericBox<Grocery2> gBox2 = new GenericBox<>();
		gBox2.setSome(new Grocery2());
		Grocery2 grocery = gBox2.getSome();
		// grocery 사용
		// gBox1.setSome(new Grocery2()); // Grocery2만 할당 가능
	}
}

이처럼 타입 파라미터를 사용하면 클래스에 넘겨줄수 있는 타입을 제한 가능.
그런데 잠깐 고민해보면 상자에 아무거나 담을 때가 편하기도 했던 것 같다. 
이처럼 모든 타입의 객체를 수용하고 싶을 때는 타입 파라미터에 Object를
넘겨주면된다. 

ex)
GenericBox<Object> objBox1 = new GenericBox<>();
objBox1.setSome(new Toy2());
objBox1.setSome("Hello");

이제는 기존의 NormalBox처럼 모든 객체를 다 사용할수 있게 되었다. 

(2) 타입 파라미터 사용시 주의점 
제너릭은 객체마다 생성될 때 전달된 타입 파라미터를 독립적으로 사용하게 된다. 
따라서 타입 파라미터는 언제나 인스턴스 변수로 간주한다.
그런데 만약 이 타입 파라미터를 static 멤버에 적용하면 어떻게 될까?
static 멤버는 모든 객체가 공유하는 특성이 있고 
static 멤버에서 인스턴스 멤버를 직접 사용할수 없다. 
따라서 static이 붙은 멤버에는 타입 파라미터를 적용할수 없다. 

ex)
public class Test<I> {
static I item;
//Cannot make a static reference to the 
non-static type I
static void method(I item) {}
}

또한, 타입 파라미터를 이용해서 객체를 생성할 수 없다. 
new 연산자는 컴파일 타입에 정확한 타입을 알아야 하는데
클래스 내부에서 파라미터만 보아서는 타입을 알 길이 없기 
때문이다. 비슷한 이유로 instanceof의 피연산자로 
타입 파라미터가 사용될수도 없다. 

ex)
public class Test<I>{
I i = new I(); //Cannot instantiate the type I
Object obj = new Object();
{
if(obj instanceof I) {
//Cannot perform instanceof check against type parameter I
}
}
}

마지막으로 클래스 내부에서 사용할수 있는 타입 파라미터의 메서드는 
Object에 선언된 것으로 한정된다. 아직 타입이 정해지지 않은 상태에서 
누구의 메서드도 가져다 쓸수 없을 것이다. 단, 모든 클래스는 최소한 
Object이기 때문에 Object에 선언된 메서드들은 사용할수있다.

(3) 제너릭 타입의 상속과 구현 
제너릭 타입도 다른 클래스와 마찬가지로 상속을 적용할 수 있다.
이때 부모 클래스에 적용된 타입만을 그대로 사용할 수도 있고 
필요에 따라 타입 파라미터를 추가할 수도 있다. 
단 부모가 선언한 타입 파라미터는 반드시 자식에도 선언되어야 한다. 

실습32
ex)
package ch08.generic.type;

import java.util.Date;

class Fruit{}
class Company{}

class Market<P>{
	protected P product;
}
interface Useable<D>{}

class Mart<C, P, D> extends Market<P> implements Useable<D>{
	private C coworker;
	
	public Mart(C coworker, P product) {
		this.coworker = coworker;
		this.product = product;
	}

	@Override
	public String toString() {
		return "Mart [coworker=" + coworker + ", product=" + product + "]";
	}
}

public class MartTest{
	public static void main(String[] args) {
		Mart<Company, Fruit, Date> mart = new Mart<>(new Company(), new Fruit());
		System.out.println(mart);
		
		Market<Fruit> market = new Mart<>(new Company(), new Fruit());

	}
}
//
Mart [coworker=ch08.generic.type.Company@16f65612, product=ch08.generic.type.Fruit@311d617d]

제너릭 타입의 상속을 배웠는데 다형성을 사용하면서 자주 혼선이 오는 부분을 
짚고 넘어가자.
GenericBox<Object> 와 GenericBox<String>은 어떤 관계가 
있을까? 잘못 생각하면 Object는 모든 객체의 조상이므로 GenericBox<Object>
가 GenericBox<String>의 조상으로 오인하는 경우가 많다. 
하지만 둘은 전혀 상관없는 타입이다. 둘 모두 GenericBox 타입으로 전자는 
Object를 후자는 String을 담을 수 있을 뿐이다. 

타입 파라미터의 관계는 제너릭의 상속 관계와 무관하다. 
다음 처럼 Market과 Mart 가 상속 관계가 있는 것이다. 

ex)
class Mart extends Market {}
Market<Fruit> market = new Mart<Fruit>(new Company(), new Fruit());

(4) 사용 가능한 파라미터 타입의 제한 

타입 파라미터가 선언되면 Object와 그 자식들이 (따라서 모든 객체)
타입 파라미터에 대입될수있다. 하지만, 필요에 따라 대입되는 파라미터의 
타입을 제한할 필요가 있는데 이때 extends 키워드를 사용할수 있다. 

extends가 적용되면 대입할수 있는 타입은 해당 클래스와 그 자식클래스로 한정.
또한, 대입될수있는 객체의 최소 타입이 Object에서 extends에 사용된 
클래스로 변경되기 때문에 타입 파라미터를 통해 사용할수 있는 멤버도 
그 클래스에 선언된 멤버로 확대된다. 

실습33
ex)
package ch08.generic.type;

class NumberBox<T extends Number> {
 // T 는 최소한 Number
	public void addSomes(T... ts) {
		double d = 0;
		for (T t : ts) {
			d += t.doubleValue();
		} // Number의 멤버 사용 가능 
		System.out.println("총 합은: " + d);
	}
}

class TypeRestrict1<T extends Cloneable>{}
class TypeRestrict2<T extends Number & Cloneable>{}

public class ExtendsTest {

	public static void main(String[] args) {
		NumberBox<Number> numBox = new NumberBox<>();
		numBox.addSomes(1.5, 5, 4L);
		
		NumberBox<Integer> intBox = new NumberBox<>();
		intBox.addSomes(1,2,3);

		//NumberBox<String> strBox = new NumberBox<>();//Bound mismatch
	} //Number의 하위 클래스만 사용 가능 
}
//
총 합은: 10.5
총 합은: 6.0

타입 파라미터로 받을 수 있는 타입을 인터페이스로 제약해야 할 
경우에도 implements가 아니라 extends 를 사용함을 주의하자. 
추가로 클래스와 함께 인터페이스를 동시에 제약 조건에 명시하기위해서는 
&를 사용한다. 

ex)
class TypeRestrict1< T extends Cloneable> {}
class TypeRestrict2< T extends Number & Cloneable> {}


----------------------------------------------------
5.3 제너릭 메서드 

(1) 메서드에 선언된 제너릭 
제너릭 선언은 클래스뿐 아니라 메서드에서도 이뤄짐.
메서드의 리턴 타입 앞에 타입 파라미터 변수를 선언하고 
리턴 타입 또는 파라미터로 사용가능.

ex)
[제어자] <타입_파라미터, [...]> 리턴_타입 메서드_이름(파라미터){
//do something
}

물론 메서드에 선언된 타입 파라미터의 사용 범위는 해당 메서드로 
국한되며 메서드가 호출될때 확정된다. 타입 파라미터의 타입은 
두가지 방식으로 결정되는데 코드를 통해서 명시적으로 
사용할 타입을 지정하거나 컴파일러가 파라미터의 값을 보고 
타입을 추정하게 할수있다. 

실습34
ex)

package ch08.generic.method;

public class TypeParameterMethodTest<T> {

	T some;
	
	public TypeParameterMethodTest(T some){
		this.some = some;
	}
	
	public <P> void method1(P p) {
		System.out.println("클래스 레벨의 T"+some.getClass().getName());
		System.out.println("파라미터: " + p.getClass().getName());
	}
	
	public <P> P method2(P p) {
		System.out.println("클래스 레벨의 T"+some.getClass().getName());
		System.out.println("파라미터: " + p.getClass().getName());
		return p;
	}
	
	public static void main(String[] args) {
		TypeParameterMethodTest<String> tpmt = new TypeParameterMethodTest<>("Hello");
		tpmt.method1(10);
		tpmt.<Long>method2(20L);
	}
}
//
클래스 레벨의 Tjava.lang.String
파라미터: java.lang.Integer
클래스 레벨의 Tjava.lang.String
파라미터: java.lang.Long

다음과 같은 코드는 읽을 때 약간 혼돈이 올수 있다. 

public <P> TypeParameterMethodTest<T> ambigious (P p){
}
//<P> : 메서드 타입 파라미터
//TypeParameterMethodTest<T> : 리턴타입 

메서드 선언부에 <P>와 <T>가 선언된 것처럼 보이지만 <P>는 
메서드에 선언된 타입 파라미터가 맞고 <T>는 제너릭 클래스로 
TypeParameterMethodTest<T> 자체가 리턴 타입이다. 

또한, 클래스에 선언된 타입 파라미터는 static 멤버에서 사용할수 없지만,
static 멤버에서 선언되는 타입 파라미터를 사용하는 데는 전혀 지장이 
없다. 

ex)
public class StaticMethodTest<t>{
public static void method(T t) { //오류발생
// do something
}

public static <P> p method ( P p ) {
//do something
return p;
}
}

(2) 와일드카드의 사용 
제너릭 메서드에서는 사용되는 타입 파라미터에 제한을 두기 위해
와일드카드로 '?'를 사용한다. 와일드카드는 단독으로 사용될수 있고
extends나 super와 함께 사용될수 있다. 

1) <?> : 타입의 제한이 없으며 <? extends Object>와 동일 
2) <? extends T> : 와일드카드의 상한을 제한한다. 
이 타입 파라미터에는 T와 T를 상속받은 자손만 대입 가능. 
3) <? super T> : 와일드카드의 하한을 제한.
이 타입 파라미터에는 T와 그 조상 타입만 대입할수 있다. 

실습35
ex)
package ch08.generic.method;

class Person {}
class SpiderMan extends Person {}
class PersonBox<T> {}

public class WildTypeTest {
	public void method1(PersonBox<?> some) {}
	public void method2(PersonBox<? extends Person> some) {	}
	public void method3(PersonBox<? super Person> some) {}

	public static void main(String[] args) {
		WildTypeTest wtt = new WildTypeTest();

		wtt.method1(new PersonBox<Object>());
		wtt.method1(new PersonBox<Person>());
		wtt.method1(new PersonBox<SpiderMan>());
		
		//wtt.method2(new PersonBox<Object>());	
		wtt.method2(new PersonBox<Person>());
		wtt.method2(new PersonBox<SpiderMan>());
		
		wtt.method3(new PersonBox<Object>());
		wtt.method3(new PersonBox<Person>());
		//wtt.method3(new PersonBox<SpiderMan>());
	}
}
//


	

===================================
[자바 해바라기 정리] 9 예외처리와 디버깅

1. 예외(Exception)와 오류 

이클립스에서 프로그램을 작성하다 보면 자주 콘솔 창에 
빨간색의 글씨가 나오면서 당혹스럽게 한다. 
이런 경우 프로그램은 정상 동작 안하고 바로 종료한다.
예)
다형성에서 형변환이 잘못되는 경우 ClassCastException
이라는 예외가 발생하면서 프로그램은 종료된다.

프로그램이 어떤 원인에 의해 비정상 종료되는 상황에서 발생 
하는 것을 예외 또는 오류라고 한다. 

예외와 오류는 일반적으로 심각도에 따라 분류된다. 

먼저 오류(Error)는 메모리가 부족하거나 메서드끼리 호출을 
무한반복 하는것처럼 일단 발생하면 복구하거나 되돌릴수 없는 
심각한 상황이다. 
이 상황에 대한 처리방법은 오류를 발생하는 요인을 찾아서 
없애는 디버깅 뿐이다.
즉, 프로그램을 잘 짜는 것만이 대안이기 때문에 이 장의 목적인 
예외처리와 무관하다

반면, 예외(Exception)는 오류와 비교하면 심각도가 낮으며
프로그램의 정상적인 흐름을 방해하는 상황이다.
예)
파일을 읽으려고 할때 해당 파일이 없거나, 
네트워크 프로그램 동작 중 네트워크연결이 끊기는 상황들.
이런 상황들은 최초 프로그램의 작성 의도에서는 벗어난다.
읽을 파일없거나, 네트워크가 끊기는 경우는 프로그램이 
잘못 작성된 경우라고 보기 어렵고, 그냥 종료된다면 
매우 아쉽다. 
차라리 파일이 없다는 경고 메시지를 보여주면 어떨까?
종료할 필요 없이 다른 파일을 선택할수 있게 도와주면 
사용자의 불편을 최소화할수 있다. 

네트워크가 끊겼을때 연결이 안된다는 메시지를 보여주고 
잠시후 다시 시도하게 하는 것이 좋다. 
예외가 발생시 비정상적인 종료를 막고 계속해서 사용할수 있게
처리하는 것을 예외처리(Exception Handling)라 한다.
이를 위해 예외를 감지하는 코드와 예외가 발생했을때 동작하는 
코드가 필요하다.

배열의 예는 intArray는 1개의 데이터를 가지고 있는 배열.
그런데 2번 인덱스의 자료를 출력하고 있다.
ex)
int [] intArray = {10};
System.out.println(intArray[2]);

당연히 비정상적으로 종료된다.
종료되는 대신에 '배열의 길이를 확인하세요'라는 
오류 메시지를 보내준다면 좋지 않을까?

자바는 잘 짜인 상속 계층구조로 예외 관련 클래스 제공함.
예외와 관련된 최상위 클래스는 Throwable 이다.
하지만, 직접 사용하기보다는 Throwable 를 상속받은
Exception이나 Error가 주로 사용됨.
또한, Error는 예외 처리의 대상으로 보지 않기 때문에
제외하면 나머지 Exception 클래스와 그 하위 클래스가 
주요 처리 대상이다.

예외 클래스의 계층 
Object 하위 
Throwable 하위
1)Exception, 2)Error
1)
Exception의 하위 
SQLException 
IOException의 하위 
FileNotFoundException

Checked exception 계열 

1)
Exception의 하위 
RuntimeException의 하위 
ArithmeticException

UnChecked exception 계열 

2)
Error의 하위
OutOfMemoryError 

Error 계열 

Exception은 다시 RuntimeException 계열과
그외의 Exception 계열로 나뉜다.
차이는 컴파일 시점에 예외 상황에 대한 대비 코드 (try ~ catch)
가 있는지를 체크하는지 여부에 있다.
각각 unchecked exception과 checked exception.

RuntimeException의 하위 클래스들은 모두 
unchecked exception으로 예외에 대한 처리 코드가 
없어도 컴파일 오류가 발생하지 않는다. 
물론, 대비 코드를 작성하지 않은 상태에서 예외가 발생하면 
프로그램은 비정상 종료된다. 
하지만, 나머지 checked exception의 경우 예외에 
대한 처리 코드가 없을 경우 컴파일 오류가 발생하므로 
반드시 작성해야 한다. 

checked exception, unchecked exception 모두 
일단 발생하면 해당 예외에 대한 처리 코드가 있어야 
프로그램의 비정상 종료를 막을수 있다. 

----------------------------------------------------
2. 예외 처리 기법 

2.1 try - catch 구문 

예외를 거창하게 설명했지만 처리하는 방식은 사실 매우 간단하다. 
예외처리에는 try~catch 블록을 이용한다. 

먼저,try 블록에는 예외가 발생할 수 있는 코드를 작성한다. 
catch의 파라미터에는 try 블록에서 발생할수 있는 예외를 
설정한다. 마지막으로 catch 블록에서는 해당 예외가 발생했을 때
처리할 코드를 작성한다. 

ex) 
try {
// 예외가 발생할수 있는 코드 -> 이때 JVM 의 동작 
} catch (XXException e ) { // 던진 예외를 받음
//예외가 발생했을때 처리할 코드 
}
이때 JVM 의 동작 에서 
try 블록 모니터링 -> exception 발생 ->
new XXException() 후 던짐(throw)

작성된 코드는 나중에 JVM 에 의해 실행될 것이다. 
try 블록에 들어서면 JVM은 해당 블록을 유심히 
모니터링한다. 그리고 어떤 문제가 발생하면 그 문제에 해당하는 
예외객체를 생성(new XXXException())해서 던져버린다.(throw).
이 예외를 잡아채는 것이 catch이다. 
catch의 파라미터에 JVM이 던진 예외가 할당되면 catch 블록이 동작. 

다음 예 배열의 특정 위치에 있는 자료를 출력하고, '프로그램 종료합니다'
라는 메시지를 출력하고 종료하는 것이다. 
하지만, 배열이 가진 index 범위를 벗어난 위치에 있는 자료를 참조하려 
하기 때문에 java.lang.ArrayIndexOutOfBoundsException
이라는 예외가 발생하고 프로그램은 바로 종료.

ex)
package ch09.exception;

public class SimpleException {

	public static void main(String[] args) {
		int[] intArray = { 10 };
		System.out.println(intArray[2]); //예외발생하면
		System.out.println("프로그램 종료합니다."); //이 행은 동작안함.
	}
}
//
Exception in thread 
"main" java.lang.ArrayIndexOutOfBoundsException: 
Index 2 out of bounds for length 1
at ch09.exception.SimpleException.main
(SimpleException.java:7)

위 코드에서는 컴파일에는 문제가 없었지만, 실행 결과를 보면
알수 있듯이  ArrayIndexOutOfBoundsException 이발생.
따라서 프로그램은 비정상적으로 종료되었고, 8행의 메시지는 
출력되지 않았다. 이처럼 컴파일에는 지장이 없지만, 
프로그램 동작 중 발생하는 예외가 바로 runtime 
계열의 예외(unchecked exception)이다. 

위에서 발생한 예외를 try ~ catch 블록을 이용해서 처리.

ex)
package ch09.exception;

public class SimpleTryCatch {

	public static void main(String[] args) {
		int[] intArray = { 10 };
		try {
			System.out.println(intArray[2]);
		} catch (ArrayIndexOutOfBoundsException e) {
			System.out.println("예외가 발생했지만 처리함: 배열 크기 확인 필요");
			System.out.printf("예외 처리: 배열 크기 확인 필요:%s%n", e.getMessage());
			e.printStackTrace();
		}
		System.out.println("프로그램 종료합니다.");
	}
}
//
예외가 발생했지만 처리함: 배열 크기 확인 필요
예외 처리: 배열 크기 확인 필요:Index 2 out of bounds 
for length 1
java.lang.ArrayIndexOutOfBoundsException:
Index 2 out of bounds for length 1
프로그램 종료합니다.
at ch09.exception.SimpleTryCatch.main(SimpleTryCatch.java:8)


//e.printStackTrace();
예외가 발생했지만 처리함: 배열 크기 확인 필요
예외 처리: 배열 크기 확인 필요:Index 2 out of bounds for length 1
프로그램 종료합니다.

예외가 발생할 수 있는 코드 즉 8행을 try블록으로 감싼다. 
이 블록에서 
ArrayIndexOutOfBoundsException이 발생하고 JVM에 의해 던져짐.
JVM이 던진 예외객체가 e 변수에 할당되고 catch 블록이 동작한다. 
예최 처리가 끝났으므로 예외가 사라졌다. 이제 프로그램은 정상적으로 
종료된다. 

----------------------------------------------------
2.2 Exception 객체의 정보 활용 

catch 블록에 전달되는 예외 객체의 상위 객체는 Throwable이다. 
Throwable은 다양한 메서드로 예외에 대한 정보를 전달할 수 있는데,
주요 메서들은 다음과 같다. 

메서드명   : 선언부와 설명 
getMessage() : public String getMessage()
:발생된 예외에 대한 구체적인 메시지를 반환한다. 사용자 정의 예외를 
만들때 생성자를 통해 message를 공급할 수 있다. 

getLocalizedMessage() : public String getLocalizedMessage()
:예외의 메시지를 수정할때 오버라이드하며 별도로 오버라이드 하지 
않을 때는 getMessage()와 같다. 

getCause() : public Throwable getCause()
:예외의 원인이 되는 Throwable 객체 또는 null을 반환한다. 

printStackTrace() : public void printStackTrace()
:예외가 발생된 메서드가 호출되기까지의 메서드 호출 스택을 출력한다. 
디버깅의 수단으로 주로 사용된다. 

getMessage()는 발생한 예외에 대한 구체적인 메시지를 반환하므로
간단히 예외에 관한 내용을 확인시 좋다. 

printStackTrace()는 예외에 대한 자세한 디버깅을 위해 
주로 사용되는 메서드이다. 예외가 발생한 메서드가 호출되기 전까지
거쳐 온, 즉 그때 당시 구성된 메서드의 호출 스택을 추적해서 모두 
출력해준다. 정보가 많아서 부담스러울수 있지만, 전체적인 메서드들의
동작과 함께 예외의 발생 원인, 지점을 파악할때 아주 유용한 메서드이다. 

앞의 catch 블록을 다음처럼 수정 후 다시실행 

ex)
catch (ArrayIndexOutOfBoundsException e) {
System.out.printf("예외 처리: 배열 크기 확인 필요:%s%n", e.getMessage());
e.printStackTrace();
}
//결과 
예외 처리: 배열 크기 확인 필요:2
java.lang.ArrayIndexOutOfBoundsException:
Index 2 out of bounds for length 1
at ch09.exception.SimpleTryCatch.main(SimpleTryCatch.java:8)
프로그램 종료합니다.
(SimpleTryCatch.java:8) //클릭시 SimpleTryCatch.java 8행으로 이동 

e.getMessage()의 결과는 2이다. 즉 배열에서 2번째 인덱스에 
접근하려 했기 때문에 발생한 예외이다. 
그 이후는 printStackTrace() 의 동작 결과다. 
이클립스에서 실행하면 빨간색으로 내용이 출력돼서 긴장하게 되는데 
일반적인 출력이 System.out을 이용하는 반면 예외 정보 출력에는 
System.err 가 사용되는 것일 뿐 정상적인 처리의 결과이니 
걱정할 필요 없다.
java.lang.ArrayIndexOutOfBoundsException이 
2번 인덱스에 접근하므로 인해 발생했고 SimpleTryCatch의
main() 메서드 즉 SimpleTryCatch.java 의 8행에서 
발생했음을 알려주고 있다. 
이클립스 콘솔에서 해당하는 행번호를 클릭하면 소스 파일로 편하게 이동. 

참고,
이클립스에서 앞의 소스 코드를 실행하다 보면 출력결과가 매번 좀 다르게 
나타난다. 이는 정상 메시지를 출력하는 스트림(System.out)과 
오류메시지(System.err)를 출력하는 스트림이 꼬여서 발생하는 일종의
오류이다. 

실행결과1 
예외 처리: 배열 크기 확인 필요:2
java.lang.ArrayIndexOutOfBoundsException:2
at ch09.exception.SimpleTryCatch.main(SimpleTryCatch.java:8)
프로그램 종료합니다.

실행결과2
예외 처리: 배열 크기 확인 필요:2
java.lang.ArrayIndexOutOfBoundsException:2
프로그램 종료합니다.
at ch09.exception.SimpleTryCatch.main(SimpleTryCatch.java:8)

실행결과3
예외 처리: 배열 크기 확인 필요:2
프로그램 종료합니다.
java.lang.ArrayIndexOutOfBoundsException:2

at ch09.exception.SimpleTryCatch.main(SimpleTryCatch.java:8)

가장 이상적인 출력순서는 실행결과1 이지만,
다른 결과도 잘못된 것은 아니다. 
윈도우에서 명령프롬프트 창을 통해 프로그램을 실행하면 언제나
실행결과1이 출력된다. 

----------------------------------------------------
2.3 try - catch 구문의 흐름 

try 블록에는 문제가 발생할 수 있는 코드도 있고 그럴 염려가
없는 일반 코드도 섞여 있을수 있다. 

먼저, 예외가 발생하지 않는 경우
일단, try 블록에 있는 코드들이 다 실행된다. 
이후 catch할 예외가 발생하지 않았기 때문에 catch 블록은 
건너뛰고 catch 블록 다음 문장을 수행. 

하지만, try 블록에서 예외가 발생하면 그 이후의 일반 코드는 
수행되지 못하고 발생한 예외를 처리할수 있는 catch 블록으로 
연결된다. 만약 적당한 catch 블록을 만나지 못하면 예외처리는 실패다. 
예)
투수가 변화구를 던지는데 포수는 직구만 받을 수 있다면 포수는 
투수가 던진 공에 얻어맞는다. 
catch 블록이 실행된 후는 발생한 예외가 없어진 후이므로 
다음에 등장한 일반 코드들이 문제없이 수행된다. 

정수를 0으로 나누면 연산이 불가능하다. 이런 경우 자바에서는 
java.lang.ArithmeticException이 발생한다. 
다음 코드는 Random 클래스를 이용해 0 ~ 1 사이의 
무작위 정수를 만들고 이 숫자로 다른 정수를 나눴을 때 
상황별로 코드의 동작을 살펴볼수 있다. 

ex)
package ch09.exception;

import java.util.Random;

public class TryCatchFlow {

	public static void main(String[] args) {
		int num = new Random().nextInt(2);
		try {
			System.out.println("code 1, num: "+ num);
			int i = 1/num;
			System.out.println("code 2 - 예외 없음");
		}catch(ArithmeticException e) {
			System.out.println("code 3 - 예외 처리 완료");
		}
		System.out.println("code 4");
	}
}
//예외가 없는 경우
code 1, num: 1
code 2 - 예외 없음
code 4
//예외가 있는 경우
code 1, num: 0
code 3 - 예외 처리 완료
code 4



----------------------------------------------------
2.4 다중 예외 처리 

try 블록 내에서 한종류의 예외만 발생하라는 법은 없다. 
여러 종류의 예외를 처리하기 위해서는 어떻게 해야 할까?

하나의 try 블록에 여러 개의 catch 블록을 연결할 수 있다. 
각각의 catch 블록에서는 처리하려는 예외 타입을 선언하면 된다. 

ex)
try {
// exception 이 발생할 만한 코드 :YYException e 발생 
}catch (XXException e) { 
// XXException 발생시 처리코드  :e is a XXException? no
}catch (YYException e) {
// YYException 발생시 처리코드 : e is a YYException? yes
}catch(Exception e) {
// Exception 발생 시 처리코드 
}

그런데 여기서 catch 블록에서 처리할 예외의 순서를 정할때 주의할 점이 있다. 
JVM이 던진 예외를 적절한 catch 블록에게 연결할 때에도 
다형성이 적용된다. 
즉, 맨처음 등장한 catch 블록의 예외에서부터 차근차근 할당해보고 적용 가능한
경우라면 해당 catch 블록을 사용한다. 위의 예에서 만약 처음 
catch에서 처리할수 있는 예외가 XXException 이 아니라 
Exception이라면 어떻게 될까?

Exception은 다른 예외들의 조상 클래스 타입이기 때문에 
모든 예외가 처음 catch 블록에서 처리될수 있다. 
따라서 나중에 등장하는 catch 블록들은 평생 할 일이 없어진다. 
이 경우 'Unreachable catch block for Exception'
즉 '도달할수 없는 catch 블록'이라는 컴파일 에러가 발생한다. 

따라서 상속 관계가 없는 여러 예외를 처리할때는 순서가 상관없지만,
상속관계가 있는 예외를 처리하기 위해서는 자식 예외부터 조상 예외의 
순서로 catch 블록을 작성해야 한다. 

이번에는 checked exception 계열의 다중 예외를 
처리하는 예 
여기서 처리할 예외는 3개.
3줄의 코드를 사용할 것이고 각각 다른 예외를 발생시킨다. 
이 예외들은 checked exception 계열이므로 예외 처리에 대한 
코드를 작성하지 않으면 컴파일 되지 않는다. 각 코드에서 
발생하는 예외는 주석으로 표시했다. 

ex)
public static void main(String[] args) {
Class.forName("abc.Def"); //ClassNotFoundException
new FileInputStream("Hello.java"); //FileNotFoundException
DriverManager.getConnection("Hello");// SQLException
System.out.println("프로그램 정상 종료");
}

이 3개의 예외는 다행히 계층 관계는 없다. 따라서 순서와 무관하게 
예외를 처리할수 있다. 

ex)
package ch09.exception;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.sql.DriverManager;
import java.sql.SQLException;

public class MultiExceptionHandling {

	public static void main(String[] args) {
		try {
			Class.forName("ch09.exception.MultiExceptionHandling"); // ClassNotFoundException
			new FileInputStream("Hello.java"); // FileNotFoundException
			DriverManager.getConnection("Hello"); // SQLException
		} catch (ClassNotFoundException e) {
			System.out.printf("클래스를 찾을 수 없습니다.: %s%n", e.getMessage());
		} catch (FileNotFoundException e) {
			System.out.printf("파일을 찾을 수 없습니다.: %s%n", e.getMessage());
		} catch (SQLException e) {
			System.out.printf("DB 접속 실패: %s%n", e.getMessage());
		}
		System.out.println("프로그램 정상 종료");
	}
	
	public void exceptionHandling() {
		try {
			Class.forName("ch09.exception.MultiExceptionHandling"); // ClassNotFoundException
			new FileInputStream("Hello.java"); // FileNotFoundException
			DriverManager.getConnection("Hello"); // SQLException
		} catch (ClassNotFoundException | FileNotFoundException e) {
			System.out.printf("자원을 찾을 수 없습니다.: %s%n", e.getMessage());
		} catch (SQLException e) {
			System.out.printf("DB 접속 실패: %s%n", e.getMessage());
		}
		System.out.println("프로그램 정상 종료");
	}
}
//
파일을 찾을 수 없습니다.: Hello.java (지정된 파일을 찾을 수 없습니다)
프로그램 정상 종료

앞서 이야기했듯이 catch 블록은 다형성을 적용해 JVM이 던진 예외를 
할당한다. 따라서 catch 블록의 순서가 중요하다. 그럼 차라리 처음에 
Exception 하나로 모든 예외를 처리 할수도 있지 않을까?
Exception은 모든 예외의 상위 객체이기 때문에 아주 간단히 처리 할수 
있을것 같다. 

ex)
try {
Class.forName("ch09.exception.MultiExceptionHandling");
new FileInputStream("Hello.java");
DriverManager.getConnection("Hello");
}catch(Exception e){
System.out.printf("예외 처리 합니다.:%s%n", e.getMessage());
}

결론, 잘 동작함. 하지만, 예외라는 것은 다양한 상황에서 발생하는데
위 처럼 뭉뚱그려 Exception으로 처리하면 상황에 따른 예외 처리가 
어렵다. 
병은 여러가지인데, 처방은 언제나 하나인 경우.
따라서, 될수 있으면 예외는 예외별로 처리하는 것이 바람직하다. 

그런데 예외 중에는 성격이 비슷해서 처리하는 방식도 비슷한 것들이 있다. 
위의 예에서 보면, ClassNotFoundException이나 
FileNotFoundException의 경우 모두 사용하려는 리소스가 
없는 경우이다. 따라서, 대응도 유사하다. 
이런 경우 '|' 기호를 이용해서 여러 예외를 연결할 수 있다. 

ex)
public void exceptionHandling() {
try{
Class.forName("ch09.exception.MultiExceptionHandling");
new FileInputStream("Hello.java");
DriverManager.getConnection("Hello");
}catch(
ClassNotFoundException | FileNotFoundException e){
System.out.printf("자원을 찾을수 없습니다.:%s%n", e.getMessage());
}catch(SQLException e){
System.out.printf("DB 접속 실패: %s%n", e.getMessage());
}
System.out.println("프로그램 정상 종료");
}

위 예는 상속의 관계가 없는 예외들이 발생했을 경우이다. 
상속의 관계가 있을 경우는 자식 예외에 대한 처리가 먼저 
이루어져야 하고 조상 예외에 대한 처리가 나중에 이루어져야
한다. 

파일을 읽기 위해서는 FileInputStream을 생성하고 
이 객체가 제공하는 read() 메서드를 이용할수 있다. 
이때, FileInputStream의 
생성자에서는 java.io.FileNotFoundException
이 발생할 수 있고 read() 메서드에서는 java.io.IOException
이 발생할수 있다. 이들은 다음과 같은 상속의 관계가 이루어진다. 

java.lang.Object
 java.lang.Throwable
   java.lang.Exception
     java.io.IOException
	   java.io.FileNotFoundException
FileNotFoundException의 상속관계 

다음예 상속 관계에 있는 다중 예외를 처리하는 방식을 보여준다. 

ex)
package ch09.exception;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class HierarchyException {

	public static void main(String[] args) {
		String src = "./.project";
		try {
			FileInputStream input = new FileInputStream(src);
			int readData = -1;

			while ((readData = input.read()) != -1) {
				System.out.print((char) readData);
			}
		} catch (FileNotFoundException e) {
			System.out.printf("읽으려는 파일이 없습니다.: %s%n", e.getMessage());
		} catch (IOException e) {
			System.out.printf("파일 읽기에 실패했습니다.: %s%n", e.getMessage());
		}
		System.out.println("파일 읽음 완료!");
	}
}
//
<?xml version="1.0" encoding="UTF-8"?>
<projectDescription>
	<name>java_press</name>
	<comment></comment>
	<projects>
	</projects>
	<buildSpec>
		<buildCommand>
			<name>org.eclipse.jdt.core.javabuilder</name>
			<arguments>
			</arguments>
		</buildCommand>
	</buildSpec>
	<natures>
		<nature>org.eclipse.jdt.core.javanature</nature>
	</natures>
</projectDescription>
파일 읽음 완료!

// String src = "./.project"; , 프로젝트 안에 있음. 
// 파일은 이클립스를 통해 자바 프록젝트를 만들 때,
기본적으로 생성되는 파일.

try 블록 내에서 FileInputStream 객체를 생성하고 
read() 메서드를 사용한다. 
각각 FileNotFoundException과 IOException이 발생할수 
있으며 처리 코드가 필요하다. 

상속관계에 따라 FileNotFoundException과 
IOException의 순서대로 catch 블록을 구성한다. 

ch09.exception.HierarchyException.java 를 실행하면 
정상적으로 파일의 내용이 콘솔에 출력된다. 
간혹 혼동하는 때도 있는데 예외 발생에 대처하는 코드는 예외가 발생해서 
처리하는 것이 아니라 예외가 발생할수 있어서 대비하는 것이다. 
따라서 실제 발생 여부와는 상관없다. 
뒤에 throws 절에서 살펴보겠지만 단지 예외가 발생할수 있는 API를 
사용했다는 이유만으로 예외처리가 필요하다. 

----------------------------------------------------
2.5 try - catch - finally 구문 

try ~ catch 블록은 추가로 finally 블록을 가질수 있다. 
finally 블록은 예외발생여부와 상관없이 반드시 실행되어야 하는 
내용을 작성한다. 심지어 중간에 return 문을 만날때에도 
먼저 finally 블록을 실행 후 메서드가 리턴된다. 

ex)
try {
//exception 이 발생할 만한 코드 
}catch(Exception e) {
//XXException 발생시 처리코드
}finally{
// try block에서 접근했던 System 자원의 안전한 원상복구
}

try~catch~finally 블록의 실행 흐름에 대한 예제.
주의점, try 블록에서 마지막에 return문이 있다는 점. 

ex)
package ch09.exception;

import java.util.Random;

public class TryCatchFinallyFlow {
	public static void main(String[] args) {
		int num = new Random().nextInt(2);
		try {
			System.out.println("code 1, num: " + num);
			int i = 1 / num;
			System.out.println("code 2 - 예외 없음");
			return;
		} catch (ArithmeticException e) {
			System.out.println("code 3 - 예외 처리 완료");
		} finally {
			System.out.println("code 4 - 언제나 실행");
		}
		System.out.println("code 5");
	}
}
// 예외가 나온 경우
code 1, num: 0
code 3 - 예외 처리 완료
code 4 - 언제나 실행
code 5
//예외가 없는 경우
code 1, num: 1
code 2 - 예외 없음
code 4 - 언제나 실행
/return으로 code5 로 넘어감.

finally 블록의 주요 목적은 try  블록에서 
사용한 시스템 자원(System resource)의 반납처리다.
시스템 자원이란 데이터베이스 접속을 위한 Connection이나 
파일 I/O 를 위한 Stream 등을 들수있다. 
많은 시스템 자원들은 사용시 예외를 발생시킬수 있어서 
try 블록 내에서 사용하게 된다. 
시스템 자원은 유한하므로 사용 후 반납되지 않으면 
장래 리소스 릭(resource leak)이 발생할 수 있다. 
이러한 자원 반납은 애플리케이션이 정상적으로 사용했을 때는 
물론 예외가 발생했을때도 처리되어야 한다. 
다음은 finally 블록을 이용한 리소스 반납 코드의 예이다. 

ex)
package ch09.exception;

import java.io.FileInputStream;
import java.io.IOException;

public class CloseResourceTest {
public static void main(String[] args) {
CloseResourceTest crt = new CloseResourceTest();
System.out.println("--있는 파일(정상적)인 경우");
crt.useStreamOldStyle(".project");
System.out.println("--없는 파일인 경우");
crt.useStreamOldStyle("abc.txt");
}

public void useStreamOldStyle(String file) {
FileInputStream fileInput = null;
try {
fileInput = new FileInputStream(file);
System.out.println("FileInputStream이 생성되었습니다.");
fileInput.read();
} catch (IOException e) {
System.out.println("파일 처리 실패");
finally {
System.out.println("finally 블럭 동작");
if (fileInput != null) {
try {
fileInput.close();
System.out.println("FileInputStream이 종료되었습니다.");
} catch (IOException e) {
System.out.println("FileInputStream 종료 실패");
}
}
}
}



public void useStreamNewStye(String file) {
try (FileInputStream fileInput = new FileInputStream(file)) {
System.out.println("FileInputStream이 생성되었습니다.");
fileInput.read();
} catch (IOException e) {
System.out.println("파일 처리 실패");
}
}
}
//
--있는 파일(정상적)인 경우
FileInputStream이 생성되었습니다.
finally 블럭 동작
FileInputStream이 종료되었습니다.
--없는 파일인 경우
파일 처리 실패
finally 블럭 동작

//17-20
FileInputStream의 생성자에서는 
FileNotFoundException이 발생할수 있고
read() 메서드에서는 IOException이 발생할수 있어서 
try 블록으로 감싸져 있다. 
여기서 생성한 FileInputStream이 나중에 종료해야 하는 시스템 자원이다. 
//
20-21
FileNotFoundException의 조상클래스인 IOException으로 
catch 블록을 구성한다. 
22-32 
finally 블록에서 리소스를 종료해야한다. 
FileInputStream을 종료하기 위해 
fileInput 의 close() 메서드를 호출한다. 



----------------------------------------------------
2.6 try - with - resources 구문 

위의 예제는 안전하고, 완벽하게 시스템 리소스를 사용하는 방법이다.
그런데 finally 블록이 상당히 지저분.
사실 필요한 코드 fileInput.close() 한줄.
그런데 콘솔에 메시지 출력 내용을 빼더라도 8줄의 코드가 
finally 블록을 구성. 상당한 과대포장.
과대포장이 필요한 이유는 2가지.

1) close() 메서드 자체가 IOException을 발생시킬수 있는 코드이다. 
따라서, try~catch로 묶여야 한다. 

2) FileInputStream의 생성자에서 예외가 발생하는 경우 
fileInput 객체가 null이 되므로 try 블록에서 null에 대한 
대응 (fileInput != null 의 코드)도 필요한 것이다. 

이런 불편한 점을 개선하기 위해 자바 7버전에서 새롭게 추가된 기능이 
try~with~resources 구문이다. 
이 구문은 try 문의 선언부에 리소스를 선언하면 관련 
try~catch 블록을 모두 수행한 후 선언된 리소스들을 자동으로 
close 처리 해준다. 

ex)
try(리소스_타입1 res1 = 초기화; 리소스_타입2 res2 = 초기화;...)
{ // 예외 발생 코드
}catch(Exception e) {
// 예외처리코드
}

단 이 리소스들은 반드시 AutoCloseable 인터페이스를 구현해야 한다. 
AutoCloseable에는 close() 메서드가 하나 선언되어 있는데 
try~with~resource 구문을 사용하면 
try~catch 에 대한 처리가 끝난후 AutoCloseable 의 
close() 메서드를 자동으로 호출해준다. 
각종 I/O 작업을 위한 Stream 들이나 통신을 위한 Socket,
데이터베이스를 사용하기 위한 Connection 등은 대부분 AutoCloseable
인터페이스를 구현하고 있다. 

다음은 위의 finally 블록에서 리소스를 종료하는 코드를 
try~with~resource 문의 형태로 변경해서 처리한 예.

ex)
public void useStreamNewStye(String file){
try(FileInputStream fileInput = new FileInputStream(file)){
System.out.println("FileInputStream이 생성되었습니다.");
fileInput.read();
}catch(IOException e){
System.out.println("파일 처리 실패");
}
}

엄청난 코드의 다이어트가 이뤄졌다. 단지, try의 선언문에 
FileInputStream을 선언하고 초기화했을 뿐이다. 
참고로, try 선언문에서 초기화된 객체는 try 블록 내에서 
재생성될수 없다. 

물론 그렇다고 finally 블록이 필요 없다는 이야기는 전혀 아니다. 
finally 블록은 여전히 AutoCloseable을 지원하지 
않는 리소스의 종료에도 사용되고 다른 정리 작업에도 아주 중용하게 사용된다. 

----------------------------------------------------
3. throws 키워드를 통한 처리 위임 

3.1 throws 키워드 

예외 처리의 두번째 방법은 throws 키워드를 통한 위임 또는 전달. 
throws 는 메서드에서 처리해야 할 하나 이상의 예외를 메서드를 
호출한 곳으로 던져버린다. 이런 위임은 처리와는 다르다. 
try~catch에서 catch 블록은 예외를 처리해서 없애 버린다. 
하지만 위임은 예외를 없애지 못하고 단지 호출한 곳으로 예외를 전달할 뿐이다. 
예외를 전달받은 메서드는 다시 예외 처리의 책임이 발생한다. 

다음 예, 
먼저 methodCaller()는 exceptionMethod()를 호출. 
이 메서드는 Exception1, Exception2 등 여러 예외에 대한 
처리가 필요한 상황이었고 그에대한 try~catch 대신 throws 키워드를 
통해 메서드를 호출한 곳으로 예외를 전달한다. 
이제 다시 methodCaller()가 예외를 가지게 되었고 try~catch 를
통해 처리하든지 아니면 다시 어딘가 methodCaller()를 호출했던 곳으로 
다시 throws 처리할수 있다. 

ex)
void exceptionMethod() throws Exception1,Exception2{
//예외발생코드
}

void methodCaller(){
try{
method();
}catch(Exception e){}
}
throws를 통한 예외 전파 

throws를 통해서 예외를 전달할 때에도 다형성을 적용가능.
즉 처리할 예외의 상위 타입으로 throws 처리가 가능하다. 
위의 예에서도 exceptionMethod()가 던진 예외는 
Exception1, Exception2 이지만 처리하는 
methodCaller()는 모든 예외의 상위 타입인 Exception
으로 처리하고 있다. 

----------------------------------------------------
3.2 예외의 타입에 따른 throws 특징 

실제로 어떻게 예외가 전달되는지 과정을 확인해보자.
다음 예제, 꼬리에 꼬리를 물면서 다른 메서드를 호출한다.
마지막 메서드는 예외를 발생시키는 코드를 사용하고 있지만 
처리하지 않고 throws를 이용해 예외를 전달한다.
이 메서드의 호출 흐름(메서드 호출 스택)을 처음 유발한 
main() 메서드에서는 최종적으로 try~catch 문을 
이용해서 예외를 처리해야 한다. 
main()에서도 이 예외를 처리하지 않으면 프로그램은 
비정상 종료된다. 즉 예외 처리 실패다. 

ex)
package ch09.exception;

public class CheckedThrowsTest {
	public static void main(String[] args) {
		CheckedThrowsTest et = new CheckedThrowsTest();
		try {
			et.method1();
		} catch (ClassNotFoundException e) {
			System.out.printf("예외 처리: %s%n",e.getMessage());
			//e.printStackTrace();
		}
		System.out.println("프로그램 종료");
	}

	public void method1() throws ClassNotFoundException {
		method2();
	}

	public void method2() throws ClassNotFoundException {
		Class.forName("Some Class");
	}
}
//
예외 처리: Some Class
프로그램 종료


unchecked exception인 RuntimeException 계열은 
별도로 try~catch 문을 사용하지 않아도 컴파일이 진행되는 특징이
있었다. throws에서도 비슷한 상황인데 RuntimeException 
계열은 try~catch 가 없으면 별도의 throws 절이 없어도 예외의 
전달이 자동으로 진행된다. 하지만, throws는 처리가 아니기 때문에 
언젠가는 try~catch로 처리되어야 함을 명심하자. 

다음은 unchecked exception 계열의 예외가 전달되고 
처리되는 예이다. 정수를 0으로 나눴을때 발생하는 ArithmeticException이
어떻게 처리되는지 살펴보자. 

ex)
package ch09.exception;

public class RuntimeThrowsTest {
	public static void main(String[] args) {
		RuntimeThrowsTest et = new RuntimeThrowsTest();
		try {
			et.method1();
		} catch (ArithmeticException e) {
			System.out.printf("예외 처리: %s%n",e.getMessage());
		}
		System.out.println("프로그램 종료");
	}

	public void method1() {
		method2();
	}

	public void method2() {
		int i = 1/0;
	}
}
//
예외 처리: / by zero
프로그램 종료

1을 0으로 나누기 때문에 runtime exception 계열의 
ArithmeticException이 발생한다.
하지만 별도의 try~catch가 없으므로 자동으로 throws 처리된다.
이제 method2()를 호출한 15행이 예외를 가지고, 역시 별도의 
try~catch 없으므로 method1() 을 호출한 main()으로 예외가 
전달된다. 
최종적으로 main() 메서드에서 ArithmeticException을 처리한다. 

----------------------------------------------------
3.3 로그 분석과 예외의 추적 

Throwable 클래스가 가지는 printStackTrace() 메서드를 
사용하면 예외가 발생하고 전파된 메서드 호출 스택에 대한 정보를 
확인할수 있다. 이 메서드는 최초 호출 메서드에서 부터 예외가 
발생한 메서드까지의 스택 정보를 출력한다. 

CheckedThrowsTest의 catch 블록에 있는 출력문을 
e.printStackTrace()로 변경하고 실행해보자. 

ex)
try{
et.method1();
}catch(ClassNotFoundException e){
//System.out.printf("예외처리:%s%n", e.getMessage());
e.printStackTrace();
}

예외 처리: Some Class
java.lang.ClassNotFoundException: Some Class
at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:583)
at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178)
at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521)
at java.base/java.lang.Class.forName0(Native Method)
at java.base/java.lang.Class.forName(Class.java:315)
at ch09.exception.CheckedThrowsTest.method2(CheckedThrowsTest.java:20)
at ch09.exception.CheckedThrowsTest.method1(CheckedThrowsTest.java:16)
at ch09.exception.CheckedThrowsTest.main(CheckedThrowsTest.java:7)프로그램 종료

API가 연결된 오류 정보는 아주 복잡해 보여서 우리를 당혹스럽게 한다. 
하지만, 길이는 중요치 않다. 로그를 통해서 확인할 정보 3가지다.

1) 어떤 종류의 예외인가? 예외 클래스의 종류를 확인.
java.lang.ClassNotFoundException

2) 예외의 원인은 무엇인가? 예외 객체의 message에 해당하는 내용을 확인. 
Some Class

3) 어디서 발생했는가? 디버깅의 출발점을 확인한다. 
at으로 시작하는 정보들은 메서드의 호출스택을 나타낸다. 
맨위의 메서드가 최초로 예외를 발생시킨 메서드이고 맨 아래가 
그 메서드 호출 스택의 출발점이다. 
매우 많은 메서드가 연관되어 있을수 있지만, 사실 디버깅할수 있는 부분은 
일반적으로 우리가 작성한 소스 부분이다. 
나머지 부분인 시스템 API 부분 또는 외부 라이브러리 부분은 과감히 
건너뛰고 직접 작성한 소스부터 눈여겨 살펴본다. 
따라서 다음의 경우 
at ch09.exception.CheckedThrowsTest.method2
(CheckedThrowsTest.java:20)
가 디버깅 출발점이 된다. 

----------------------------------------------------
3.4 throws의 목적과 API 활용 

앞서 사용했던 FileInputStream의 생성자나 
Class.forName() 메서드와 같은 API 들은 throws를 이용해서 
API를 사용하는 쪽에 예외를 전파하고 있고, 개발자에게는 그 예외를
처리해야 할 책임이 발생한다. 

다음은 FileInputStream의 생성자에 대한 설명문이다. 생성자의 선언부에 
throws 키워드로 FileNotFoundException이 선언되어 있기 때문에 
귀찮지만, 이 생성자를 사용하려면 예외에 대해 책임져야 한다. 
이 생성자의 선언부에는 FileNotFoundException을 throws 하고 
있지만, 설명문 하단을 보면 실제로 throws 하는 항목은 SecurityException
을 포함해서 두가지이다. 
SecurityException은 unchecked exception 계열이므로 
별도의 throws 가 필요 없다. 

여기서 궁금한 점은 왜 이런 API들은 사용자에게 예외 처리를 위임하는 걸까?
설마 try~catch 블록 사용법을 몰라서? 
만약, API 내에서 예외를 처리해버렸다면 throws 같은 내용은 
필요 없었을 것이고 우리도 훨씬 쉽게 프로그래밍이 가능할 것이다. 

만약 예외가 발생하는 API 들이 발생한 예외들을 모두 try~catch로 
처리해버린다면 API를 사용하는 애플리케이션에는 어떤 문제가 발생했는지 
전혀 알수없게 된다. 하지만 개발자에게 예외를 전달함으로써 예외의 처리를 
강요할수 있게 되었고 개발자는 자신이 작성한 애플리케이션에서 
예외 상황에 대한 적절한 처리가 가능해진다. 

예를들어 FileNotFoundException이 발생했을 때 API 내부적으로 
처리를 끝내 버렸다면 개발자의 코드는 파일이 없는 상황에 대해 
어떤 오류가 발생했는지 모르게 되고 애플리케이션은 동작하지 않을 것이다.
하지만 예외를 개발자 코드에게 전파해주면 상황을 인지하고 파일이
없음을 나타내는 경고 메시지를 출력하는 등 적절한 예외 처리를 
할수 있을 것이다. 

Java API :예외발생 - 예외처리 하면, 
개발자코드 : 상황인지못함.

Java API :예외발생 - 예외전파 하면, 
개발자코드 : 상황인지 적절한 예외처리

이처럼 예외는 언제나 try~catch로 처리하는 것만이 능사는 아니다. 
특히, API나 다른 모듈에서 사용되는 기능을 제공하는 경우 예외를 
전달해서 그 예외에 대해 적절히 대응 할수있는 코드를 작성할수 있게 
해줄 필요가 있다. 

throws 가 필요한 상황에 대해 알아보자. 
일반적으로 애플리케이션을 설치할때 인스톨 툴이 사용되는데
일반적으로 3단계를 거친다. 
1단계는 설치에 필요한 파일들을 컴퓨터 임시 파일로 복사한다.
2단계는 설치를 진행하고 
3단계는 설치가 완료되면 임시 파일을 삭제해서 정리한다. 
그런데, 설치 도중 하드 디스크의 용량이 부족하거나 다른 
애플리케이션과 충돌하게 되면 예외가 발생한다. 
이 예외 발생 상황을 인스톨 툴을 사용하는 코드에게 
전달할때 throws 로 처리해서 설치 과정에 문제가 있음을 
알릴수 있다. 

이과정을 프로그래밍으로 전환해보자.
다음의 InstallTool 클래스는 install() 내부에서 
Math의 random() 메서드 값이 0.5 미만인 경우를 문제 
상황으로 간주한다. 이 상황에서 임의로 예외를 발생시켜야 하는데 
JVM이 예외가 발생했을 때, throw라는 키워드를
이용하는 것처럼 코드상에서도 비즈니스 로직상 어떤 문제가 발생하면 
예외 객체 생성후 throw를 이용해 던져버리면 된다. 
예외를 발생시킬 때에는 throw,
전파할 때는 throws 임을 주의 하자. 

ex)
package ch09.exception;

public class InstallTool {
	void copy() {
		System.out.println("파일 복사");
	}

	void install() throws Exception {
		System.out.println("설치");
		if (Math.random() > 0.5) {
			throw new Exception("설치 과정에서 문제 발생");
		}
	}

	void delete() {
		System.out.println("파일 삭제");
	}
}
//
Math.random() 값이 0.5 미만인 경우 throw를 이용해 새로운
예외 객체를 생성한다. 
따라서 11행은 try~catch로 처리해야 하지만, 
통보를 위해 8행처럼 throws를 이용해서 예외를 이 메서드를 
호출한 곳으로 전달한다. 

ex2)
package ch09.exception;

public class UseInstallTool {
	public static void main(String[] args) {
		InstallTool tool = new InstallTool();
		try {
			tool.copy();
			tool.install();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			tool.delete();
		}
		System.out.println("설치 종료");
	}
}
//예외 발생일 경우
파일 복사
설치
java.lang.Exception: 설치 과정에서 문제 발생
	at ch09.exception.InstallTool.install(InstallTool.java:11)
	at ch09.exception.UseInstallTool.main(UseInstallTool.java:8)
파일 삭제
설치 종료

// 예외 발생 안할 경우
파일 복사
설치
파일 삭제
설치 종료

----------------------------------------------------
3.5 메서드 오버라이드 와 throws

앞에 학습했던 메서드 오버라이드 제약 조건의 마지막 항목에 
throws와 연관된 내용이 있다. 
상속의 구조에서 조상클래스 메서드가 예외를 던지고 있고,
자식클래스에서 그 메서드를 오버라이드하는 경우 자식의 메서드는 조상메서드가
던지는 예외보다 부모예외를 던질수없다. 
쉽게 말해서 부모가 치지않은 사고를 자식이 칠수는 없는 것이다. 

다음예는 Parent 클래스를 상속받는 OverridingTest가 
method() 와 method()를 오버라이드 할 때 throws 부분을 
어떻게 처리하는지 보여준다. 

ex)
package ch09.exception;

import java.io.FileNotFoundException;
import java.io.IOException;

class Parent{
	void methodA() throws IOException{}
	void methodB() throws ClassNotFoundException{}
}

public class OverridingTest extends Parent {

	@Override
	void methodA() throws FileNotFoundException {
	}
	/*
	@Override
	void methodB() throws Exception {
	}
	*/
}
// methodA() 오버라이드한다. IOException의 자식 예외인 
FileNotFoundException을 throws 처리가능. 

methodB()를 오버라이드하면서 ClassNotFoundException의 
조상 예외인 Exception을 throws 처리하므로 
제약 사항 위반이 발생한다. 

----------------------------------------------------
4. 사용자 정의 예외

4.1 사용자 정의 예외 작성 

사용자 정의라는 단어가 이책에서 처음 등장. 
사용자 정의라는 것은 기존에 비슷한것이 있는데 
사용자가 원하는 형태로 재정의하는 것을 의미하며 
상속을 통해서 기존 클래스를 확장하는 것이 일반적이다. 

사용자 정의 예외는 API에 정의된 예외 이외에 필요에 따라 
작성한 예외 클래스를 말한다. 
일반적으로 예외의 특성에 따라 Exception 또는  RuntimeException 
클래스를 상속 받아서 작성한다. 

예를들어 로그인 처리하는 기능을 예외처리를 기반으로 고민해보자. 
일반적으로 로그인 메서드는 아이디와 비밀번호를 입력받아서 로그인 기능 여부를 
확인해준다. 이때 리턴타입으로는 어떤형태가 좋을까?

-boolean 
:로그인 성공 여부를 true/false로 잘 나타낼수 있다.
하지만 딱 거기까지다. 추가적인 정보를 전달할수 없다. 
예를들어 로그인이 실패한 원인을 함께 전달하려면 어떻게 해야 할까?
boolean에서는 방법이 없다. 

ex)
public boolean login1(String id, String pass){
return id.equals("hong")&& pass.equals("1234");
}

-String
:문자열에 여러 정보를 포함할수 있다. 
예를들어 '실패: 비밀번호 오류'라는 문자열을 반환하면 
실패 여부와 함께 사유도 알수 있다. 하지만, 이 메시지를 프로그래밍으로 
파악하기 위해서는 문자열을 어떻게 구성할 것인지 사전에 잘 정의된 
약속이 있어야 한다. 
즉, '콜론을 기준으로 앞부분은 성공여부, 뒷부분은 실패 사유를 적는다.'
라고 규칙을 정한 후 이에 맞춰 데이터를 작성해야 한다. 
이런 약속을 프로토콜(protocol)이라고 한다. 
프로토콜을 잘 이해하고 프로그래밍 해야 하며 혹시나 이 프로토콜이 바뀌면
번거로운 상황이 될수있다

ex)
public String login2(String id,String pass){
String msg ="성공";
if(!id.equals("hong")){
msg="실패 : 아이디 확인 필요";
}else if(!pass.equals("1234")){
msg = "실패: 비밀번호 확인 필요";
}
return msg;
}


-사용자 정의 객체 
: 원하는 멤버변수와 메서드를 가진 클래스를 만들고 이 클래스 타입의
객체를 리턴한다. 받는 쪽에서는 객체를 통해 성공/실패에 관한 내용을 쉽게 
파악할수 있다. 따라서 복잡한 내용을 전달하기 위해서는 사용자 정의 
객체가 가장 적절하다. 

ex)
public LoginInfor login3(String id, String pass){
LoginInfo info = new LoginInfo();
if(!id.equals("hong")){
info.setSuccess(false);
info.setMsg("아이디 확인 필요");
}else if(!pass.equals("1234")){
info.setSuccess(false);
info.setMsg("비밀번호 확인 필요");
}
return info;
}

그런데 로그인 메서드가 몇 단계를 거쳐 복잡하게 호출되었다면 어떨까?
중간 과정에서 계속 리턴 값을 다시 전달하는 절차가 있어야 할것이다. 

이제 Exception이 가지는 throws 를 이용한 전파를 사용해보자.
로그인에 실패한 것은 일종의 예외라고 볼수 있다. 
이 예외를 만들어서 throw 시킨다면 throws 메커니즘을 이용해 
메서드를 호출한 곳으로 쉽게 전달할 수 있다. 
게다가 이 예외가 unchecked exception 의 계열이라면 
중간에 throws 하는 절차도 필요 없을 것이다. 

사용자 정의 예외 클래스부터 만들어 보자. 

ex)
package ch09.exception.custom;

public class LoginFailException extends RuntimeException {
	enum ErrorCode{
		INVALID_ID, INVALID_PASS
	}	
	
	private ErrorCode errorCode;

	public LoginFailException(ErrorCode errorCode, String data) {
		super(data);
		this.errorCode = errorCode;
	}

	@Override
	public String getLocalizedMessage() {
		String msg = this.getMessage();
		switch (errorCode) {
		case INVALID_ID:
			msg += ", 아이디를 확인하세요.";
			break;
		case INVALID_PASS:
			msg += ", 비밀번호를 확인하세요.";
			break;
		}
		return msg;
	}
}
//


----------------------------------------------------
4.2 사용자 정의 예외 활용 

예외 클래스가 만들어졌다면 필요한 상황 즉 로그인이 안되는 상황에서 
객체 생성후 throw로 던져버리면 된다. 

ex)
throw new LoginFailException(..., ...);

ex2)
package ch09.exception.custom;

public class UserManagerWithException {
	public boolean login(String id, String pass) {
		if (!id.equals("hong")) {
			throw new LoginFailException(LoginFailException.ErrorCode.INVALID_ID, id);
		} else if (!pass.equals("1234")) {
			throw new LoginFailException(LoginFailException.ErrorCode.INVALID_PASS, pass);
		}
		return true;
	}
	
	public static void main(String[] args) {
		UserManagerWithException userManager = new UserManagerWithException();
		try {
			//boolean result = userManager.login("hong", "1234");
			//boolean result = userManager.login("hong2", "1234");
			boolean result = userManager.login("hong", "5678");
			System.out.printf("로그인 성공 여부: %b%n", result);
		}catch(LoginFailException e) {
			System.out.printf("예외 처리: %s%n",e.getLocalizedMessage());
		}
	}
}
//
로그인 성공 여부: true
//
예외 처리: hong2, 아이디를 확인하세요.
//
예외 처리: 5678, 비밀번호를 확인하세요.

 주석 처리 유무로 확인.
 
LoginFailException이 RuntimeException 계열이므로 
별도의 throws는 필요없다. 

----------------------------------------------------
5. 로깅(logging)과 디버깅(debugging)

5.1 로깅(logging)

사용자의 요처사항을 출력하는 것 이외에 애플리케이션에서 발생하는 
사건들을 기록하는 것을 로깅.
예) 사용자가 1과 2를 입력해서 더하기 결과를 출력하는 애플리케이션
이라면 3이라는 값을 출력하는 것 이외에 1과2라는 파라미터가 제대로 
입력되었는지 확인하는 과정은 로깅이라고 볼수 있다. 

ex)
public void printAddResult(int a , int b){
System.out.printf("파라미터 확인: %d, %d%n", a, b); //로깅 
int result = a+ b;
System.out.println("%d + %d = %d", a, b, result); //정보출력 
}
이제까지 출력을 위해 System.out.println 등 메서드를 통해 콘솔을 이용해 왔다. 
또한 예외 객체의 printStackTrace()와 같은 메서드 역시 콘솔을 통해 메서드 호출 
스택을 출력한다. 하지만 콘솔은 프로그램 사용자와의 인터페이스가 주요 
목적이므로 엄청난 양의 예외 정보가 출력되기에 부적합하다. 
따라서 로깅에는 정보 출력과 구분해서 별도의 전문 로깅 프레임워크 사용을 권장한다. 

java.util.logging 패키지에는 로깅을 위한 클래스들이 제공된다. 
Logger 클래스에는 다양한 레벨로 로깅을 남길 수 있는 메서드가 제공된다. 
로깅의 레벨은 
Level.INFO(정보)->Level.WARNING(경고)->Level.SEVERE(심각)
의 단계로 처리된다. 

java.util.Logging.Logger 의 주요 메서드 

메서드명    :   선언부와 설명 
getLogger() : public static Logger getLogger(String name)
:Logger를 반환하는 static 메서드이다. 일반적으로 클래스 이름을 
파라미터로 전달한다.

log() : public void log(Level level, String msg)
:심각도(level) 에 따라 메시지(msg)를 출력한다. 
level: Level.INFO , Level.WARNING, Level.SEVERE 등 로그의 심각도 설정 
msg: 출력하려는 메시지 

info() : public void info (String msg)
Level.INFO 심각도를 가진 로그를 출력한다
log(Level.INFO , msg)와 동일하다. 

warning() : public void warning(String msg)
Level.WARNING 심각도를 가진 로그를 출력한다.
log(Level.WARNING, msg)와 동일하다. 

severe() : public void severe(String msg)
Level.SEVERE 심각도를 가진 로그를 출력한다. 
log(Level.SEVERE, msg)와 동일하다. 

addHandler() : public void addHandler(Handler handler)
: 로그 메시지를 받을 handler를 추가한다. 

ex)

package ch09.exception.logging;

import java.util.logging.Level;
import java.util.logging.Logger;

public class SimpleLogging {
	private final static Logger logger = Logger.getLogger(SimpleLogging.class.getName());
	public static void main(String[] args) {
		logger.log(Level.INFO, "info log");
		logger.info("method type info log");
		logger.warning("method type warn log");
		logger.severe("method type severe log");
	}
}
//
3월 25, 2019 9:06:29 오전 ch09.exception.logging.SimpleLogging main
INFO: info log
3월 25, 2019 9:06:29 오전 ch09.exception.logging.SimpleLogging main
INFO: method type info log
3월 25, 2019 9:06:29 오전 ch09.exception.logging.SimpleLogging main
WARNING: method type warn log
3월 25, 2019 9:06:29 오전 ch09.exception.logging.SimpleLogging main
SEVERE: method type severe log

실행 결과를 살펴보면 발생 시점과 클래스 및 메서드 이름, 심각도,
메시지 정보가 별 수고 없이 출력됨을 확인가능. 

지금까지 단순한 예제들을 실행해봤기 때문에 출력되는 로그의 양도 
많지 않았다. 하지만, 서버 프로그램 등의 경우 아주 오랫동안 
동작하므로 쏟아지는 로그도 엄청나다. 
콘솔은 자체적인 작은 메모리에 정보를 저장하기 때문에 많은 
로그를 계속 저장할수 없다. 

과거에 발생한 로그를 장기간 저장하기 위해서는 별도의 대상 
(예: 파일)에 출력하는 것이 일반적이다. 
이런경우 Handler를 Logger 에 추가하면 간단히 처리 가능. 
가장 대표적으로 사용되는 Handler는 FileHandler이다. 
FileHandler는 로그 파일 이름의 패턴, 최대 파일의 크기등을 이용해 
생성 가능. 

FileHandler의 생성자 

생성자명   :  선언부와 설명 

FileHandler() : public FileHandler(String pattern , int limit, int count)
throws IOException, SecurityException

FileHandler의 생성자이다. 
pattern : 생성될 로그 파일의 이름패턴 
limit : 생성되는 파일의 최대 크기 (byte)
count : 만들수 있는 파일의 개수로 최소 1

public FileHandler(String pattern) throws IOException, SecurityException
FileHandler의 생성자.
파일의 크기에 제한이 없고 언제나 하나의 파일만 사용된다. 
pattern : 생성될 로그 파일의 이름 패턴 

파일 이름의 패터은 다음의 예약어를 사용할수 있다. 

%t : 시스템 임시 폴더 
%h : 시스템의 user, home 속성 값 
%g : 자동으로 생성되는 일련 번호 
%u : 동일한 파일명이 있을 경우 충돌을 방지하기 위해 생성되는 유일한 값.

ex)

package ch09.exception.logging;

import java.io.IOException;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;

public class SimpleLoggingFile {
	private final static Logger logger = Logger.getLogger(SimpleLoggingFile.class.getName());

	public static void main(String[] args) throws SecurityException, IOException {
		FileHandler fHandler = new FileHandler("mylog_%g.log");
		logger.addHandler(fHandler);
		logger.log(Level.INFO, "info log");
		logger.info("method type info log");
		logger.warning("method type warn log");
		logger.severe("method type severe log");
	}
}

//
콘솔 출력은 이전 예제와 동일 
// workspace에 mylog_0_0.log 파일이 생성되며 
파일의 내용은 콘솔의 로그를 xml 형태로 변경. 

이외에도 logging 패키지에는 다양한 기능을 가지는 클래스들이 
정의되어 있다. 하지만, 실무에서는 아쉽게도 이 클래스들은 
그다지 많이 사용되지 못한다. 
실무에서는 logback 과 같은 별도의 로깅 프레임워크들이 
사용되므로 여기서는 이정도로 마무리.
logback 프레임워크는 부록에서 다룬다. 

----------------------------------------------------
5.2 디버깅(debugging)

프로그램에서 발생하는 로직 상의 오류를 찾아내는 과정을 디버깅이라고 한다. 
기본적으로 프로그램 실행 중간 중간에 앞서 언급했던 로깅 메시지를 
남기거나 예외 발생시 메서드 호출 경로를 분석해서 디버깅하기도 하지만, 
이클립스와 같은 IDE가 제공하는 기능을 이용하면 훨씬 쉽고 편리하게 디버깅 
할수 있다. 

팩토리얼(계승, factorial의 기호로는 '!'을 쓴다. )을 구하는 예제를 만들어보고 
디버깅을 통해 분석해보자. 
5! = 5*4*3*2*1 로 120이다. 

ex)

package ch09.exception.debugging;

public class DifficultLogicTest {
	public DifficultLogicTest() {}
	public long factorial(int num) {
		if(num==1) {
			return 1;
		}else {
			return num * factorial(num-1);
		}
	}
	
	public static void main(String[] args) {
		DifficultLogicTest dlt = new DifficultLogicTest();
		System.out.println(dlt.factorial(5));
	}
}
//120
이런 식으로 함수가 다시 자신을 호출하는 구조를 
재귀함수라고 부른다. 

디버거를 통해서 어떻게 동작하는지 살펴보자.

디버거를 이용할 때에는 맨 먼저 이클립스의 편집 창에서 디버깅을
시작하려는 행 번호 왼쪽의 막대 영역을 더블클릭해서 중단점(break point)
을 설정한다. 

중단점(break point)란 프로그램 동작 중 디버깅을 위해서 
동작을 멈추는 지점이다. 
중단점을 지정해 놓으면 그 전까지 프로그램이 동작하다가 
중단점에 도착하면 사용자의 다음 동작을 기다린다. 
중단점은 필요에 따라 여러개 설정할수 있다. 

14번 행부터 디버깅을 시작해보자. 
더블클릭한 부분에 파란색의 작은 블렛이 표시된다. 
표시된 블렛을 다시 더블클릭하면 중단점 설정이 해제된다. 

디버깅을 위해서는 툴바에서 기존의 실행 버튼 좌측에 있는 벌레 모양의
디버깅 버튼을 클릭. 

처음 디버거를 실행하게 되면 다음과 같은 퍼스펙티브(perspective)변경에 
관한 확인 창이 나온다. 

퍼스펙티브는 이클립스에서 특정 목적의 작업을 위한 뷰들의 모임 또는 
구성 정도로 생각. 위 내용은 디버깅을 위해서 뷰들의 구조를 디버깅에 
유용하게 변경하려고 하는데, 동의하느냐는 내용이다. 
편리하게 해주겠다는데 마다할 필요 없다. 
Remember my decision 에 체크한 후 Yes 를 클릭하면 뷰들의 배치가 변경.

디버그 퍼스펙티브는 다음과 같은 유용한 뷰들로 구성된다. 
-디버그 뷰는 현재 실행준인 스택의 정보가 스레드(thread)별로 표시된다. 
-변수 뷰는 디버깅 과정에서 확인하려는 변수의 값들이 표시된다. 
-소스 뷰를 통해서는 다음 단계에서 실행할 라인이 어딘지 쉽게 파악할수 있다. 

디버거를 이용한 디버깅 과정을 단계별로 알아보자. 

1단계 디버거가 실행되면 처음 만나는 중단점이 설정된 곳에서 실행이 
멈춘다. 위에서 언급한 3가지 뷰에 각각 어떤정보가 표시되는지 살펴보자. 

뷰이름 :  표시내용 
디버그뷰 : main 스레드가 실행하는 main 메서드 14라인에서 멈춰 있음이 표현.
변수 뷰: 이 시점의 로컬변수인 args가 표시 된다. 
소스 뷰 : 14행이 배경색을 통해 강조 된다. 

본격적인 디버깅 진행은 디버그 뷰에 있는 버튼들을 이용한다. 

맨왼쪽 부터 
resume : 중단점에 의해 일시 정지된 프로그램을 다시 실행해서 다음 중단점까지 진행한다. 
suspend : 일시 정지한다. 
terminate : 디버깅을 즉시 종료한다.  
Step Into :한 문장씩 실행한다. 메소드를 만나면 메소드 안으로 진입한다. 
Step Over : 역시 한문씩 실행한다. 하지만 StepInto와 달리 메서드를 만나도 내부로 집입
하지 않는다. 
Step Return : 현재 디버깅 중인 메서드의 리턴 위치로 이동한다. 

2단계 Step Into를 클릭하자. 
이 때 실행되는 다음문장은 
new DifficultLogicTest()이므로 생성자 코드이다. 
따라서 기본 생성자인 4번행으로 실행커서가 이동한다. 

디버그 뷰 : main 스레드의 main 메서드 위에 DifficultLogicTest 생성자(init)가 표시.
변수 뷰: 생성자에서 사용될수 있는 this 변수가 표시된다. 
소스 뷰 : 4행이 배경색을 통해 강조된다. 

3단계 다시 StepInto 를 클릭하면 어떻게 될까?
생성자에서 실행할 다음 행은 생략되었지만, 조상의 생성자를 호출하는 super()이다. 
따라서 Object 클래스의 생성자로 이동한다. 

뷰이름 : 표시 내용 
디버그 뷰 : main 스레드의 생성자(init)위에 Object 의 생성자 (init)가 표시.
변수 뷰 : 생성자에서 사용될수 있는 this 변수가 표시된다. 
소스 뷰: Object 클래스로 이동한다. 

4단계 사실 Object 클래스는 이미 완벽하므로 디버깅 할 필요는 없다.
Step Return을 클릭해서 Object 생성자가 리턴했을 지점인 DifficultLogicTest의
기본 생성자로 이동한다.  다시 디버깅 뷰들의 정보로 2단계로 이동한다. 

5단계 DifficultLogicTest 생성자에서 확인할 내용이 없으므로 Step Over 
를 통해 다음으로 이동한다. 
생성자가 리턴되고 다시 메인 메서드로 이동된다. 디버깅 뷰들의 내용은 
1단계와 같지만 정확한 시점은 4단계에서 생성된 DifficultLogicTest 객체가 
dlt에 할당되는 지점이다. 

디버그 뷰: main 스레드가 실행하는 main() 메서드 14행에서 멈춰 있음이 표현된다. 
변수 뷰 : 이 시점의 로컬 변수인 args가 표시된다. 
소스 뷰 : 14행이 배경색을 통해 강조 된다. 

6단계 Step Over 를 클릭 하면 드디어 14행이 완전히 종료되면서 객체 할당이 끝나고 
다음 실행할 코드는 15행의 println() 메서드의 파라미터인 factorial()메서드 
호출부분이다. 

디버그 뷰: main 스레드가 실행하는 main() 메서드 15행에서 멈춰 있음이 표현된다. 
변수 뷰 : 이 시점의 로컬 변수인 args와 dlt 가 표시된다. 
소스 뷰 : 15행이 배경색을 통해 강조 된다. 

7단계 factorial() 메서드의 동작을 보고 싶기 때문에 Step Into를 선택 한다. 

디버그 뷰: main 스레드의 main() 메서드 위에 factorial 메서드가 표시된다. 
변수 뷰 : 이 시점의 로컬 변수인 this와 num 가 표시된다. (num = 5)
소스 뷰 : 6행이 배경색을 통해 강조 된다. 

8단계 이후 계속해서 Step Into 등을 실행하면서 factorial 메서드의 동작을 
세밀하게 들여다 볼수 있다. 디버깅을 중지하고 싶다면 
terminate를 클릭 한다. 

디버깅 작업을 다 마친 후 원래의 자바 편집 퍼스펙티브로 돌아가려면 
메뉴에서 
Window -> Perspective -> Open Perspective -> Java 를 선택한다. 

오른쪽 상단의 Perspective 바로가기 버튼 그룹을 사용할수도 있다. 


===================================
[자바 해바라기 정리] 10 내부 클래스와 람다식 

1. 내부 클래스

1.1 내부 클래스의 필요성 

객체지향 프로그램의 출발점은 추상화를 거처 현실 세계의 객체를
분석하고 클래스로 만드는 일이다. 
분석 과정에서 관리해야 할 요소들의 성격에 따라 여러 개의 클래스가
도출 될수 있다. 
예) 스마트폰 시스템을 프로그래밍 한다고 생각 해보자.
스마트폰, 전화기능, 배터리,GPS, 와이파이, 과금정보,
대리점, 설치된 앱, OS 등 다양한 요소를 떠올릴수 있다. 
이 중 스마트폰 중심으로만 생각해보자. 
스마트폰은 번호, 통신사, 금액 같은 전화기 고유 정보뿐 
아니라 배터리, 와이파이, GPS 등 다양한 정보로 구성된다. 

이런 속성들을 모두  SmartPhone 클래스 안에 담는 경우 
한 클래스 내부이므로 서로 접근 제한자에 관계없이 편하게
사용가능. 하지만, 모듈화가 되지 않기 때문에 
클래스의 복잡도가 올라가고 유지 보수에도 좋지 않다. 

따라서, Battery, WiFiModule, GpsModule 형태로 여러 
클래스로 분리해서 모듈화하고, 
SmartPhone 클래스에서 이들 클래스를 has-a 관계,
즉 멤버 변수로 관리한다. 

대략 구현하면 다음과 같다. 

ex)
public class SmartPhone {
private Battery battery = new Battery();
private GpsModule gps = new GpsModule(battery);
private WiFiModule wifi = new WiFiModule();
}//SmartPhone 클래스 영역 

class Battery {...}
class GpsModule {...}
class WiFiModule {...}

이제 GpsModule을 설계해보자. 
GpsModule은 동작하면서 배터리를 소모시키는데 
배터리의 잔량이 줄어드는 것을 표현해야 한다. 
같은 클래스에 있다면 상관없겠지만, 클래스가 달라졌기
때문에 Battery에 접근 하기 위해 Battery의 레퍼런스가 필요.
따라서, GpsModule은 다음처럼 구현해볼수 있다. 

ex2)
class GpsModule {
Battery battery;
public GpsModule(Battery battery) {
this.battery = battery;
}
public void useBattery () {
battery.useBattery(5); // 쓸 때마다 Battery의 잔량이 5만큼 줄어든다. 
}
}

결과적으로 Battery를 사용하기 위해서 상당히 복잡한 구조의 
클래스가 완성 되었다.

추가로 한가지 상황을 더 고민한다면, SmartPhone 시스템에서 
GpsModule의 용도이다. 
과연 다른 곳(예, 과금정보, 대리점등)에서 GpsModule을 사용할 일이 
있을까? 아마 SmartPhone을 제외한 클래스에서는 그다지 소용이 없을듯.

이처럼 모듈화를 위해서 분리하기는 하지만, 
has-a  관계에 있는 클래스 내부에서만 사용되는 클래스를 만들 때는 
내부 클래스(inner class)를 활용하는 것을 고려할 만하다.

내부 클래스(inner class) 는 다른 클래스 내부에 작성되는 클래스다.
내부 클래스를 작성하게 되면 내부 클래스에서는 외부 클래스의 멤버에 
접근 제한자와 무관하게 접근 할수 있고 다른 곳에서는 사용되지 않는 
클래스를 내부에 감춤으로써 프로그램의 복잡도를 감소시킬수 있다.
내부 클래스는 다른 말로 중첩 클래스(nested class)라고도 한다. 

이제 WiFiModule을 내부 클래스로 작성 해보자.

ex3)
public class SmartPhone {
private Battery battery = new Battery();
private GpsModule gps = new GpsModule(battery);
private WiFiModule wifi = new WiFiModule();

//내부클래스
class WiFiModule {
public void useBattery() {
battery.useBattery(3);
}
}
} // SmartPhone 클래스 영역 , 외부클래스

class GpsModule {...} //외부클래스

WiFiModule은 분명 별도의 class 키워드가 사용된 클래스이지만 
SmartPhone의 내부에 선언되어 있다. 더군다나 SmartPhone의 
private 멤버변수 battery를 마치 자신의 멤버변수 처럼 사용하고 있다. 

내부클래스는 클래스 내부에 다른 클래스를 정의하는 것이지 
하나의 파일에 두 개의 클래스를 정의하는 것이 아니다. 
즉, 위의 가상 코드가 하나의 SmartPhone.java 파일에 
선언된 경우 GpsModule이나 SmartPhone은 모두 외부 클래스들이다. 
WiFiModule처럼 외부클래스 내부에 선언된 클래스를 내부클래스라고 한다. 

내부클래스는 선언되는 위치와 형태에 따라 다음과 같은 4가지로 
구분된다. 

내부클래스의 종류 

선언위치 : 종류 : 특징 

멤버영역 : 인스턴스 내부클래스 : static이 없는 내부클래스
외부클래스의 멤버변수처럼 사용됨 
주로 외부클래스의 인스턴스 멤버들과 관련된 작업 수행.

멤버영역 : 클래스 내부클래스 : static이 붙은 내부 클래스 
주로 외부 클래스의 static 멤버들과 관련된 작업 수행 

로컬영역 : 로컬 내부클래스 : 외부클래스의 메서드나 초기화블록,
생성자등에서 선언됨.
선언된 영역 내부에서만 사용가능 

로컬영역 : 익명의 내부클래스 : 이름이 없으며 클래스 선언과 
객체 생성을 동시에 처리하는 형태 주로 객체를 재사용하지 않고 
한 번만 사용할때.

4가지 형태의 내부클래스의 특징을 보자. 

----------------------------------------------------
1.2 인스턴스 내부 클래스 

작성시 주의사항.

(1) 인스턴스 내부클래스는 외부클래스의 멤버변수 선언 위치에 
static 키워드 없이 선언된 클래스를 말함. 

(2) 내부클래스에서 외부 클래스의 멤버에 접근할 때 private 를 
포함한 모든 멤버에 대해 자유롭게 참조할 수 있다.

(3) 인스턴스 내부 클래스는 static 멤버를 가질수 없다. 
단, static final 멤버는 상수로 취급되므로 예외로 사용가능

만들어진 인스턴스 내부클래스도 당연히 객체화 해야 사용가능.
객체를 생성할 때는 static 메서드 영역과 인스턴스 메서드 영역에서의 
방법이 다른데 이는 기본적으로 인스턴스 멤버와 static 멤버의 
사용법과 매우 유사하다. 

(1) static 영역에서 인스턴스 내부클래스의 객체를 만들때는 먼저 
외부클래스의 객체를 만들고 이를 통해서 내부클래스의 객체를 생성한다. 

(2) static이 아닌 영역에서 객체를 만들때는 바로 객체의 생성이 가능하다. 

ex)
package ch10.nested;

public class InstanceInnerTest {
   class Inner {
      int innerMember = 10;
      //static int staticMember = 10;
      static final int finalStaticMember = 20;
   
// 인스턴스 내부 클래스에 일반 멤버를 선언할 수 있지만, 
// static 멤버는 선언할수 없다. 단, static final 형태는 가능. 
   
   // 내부클래스에서 외부클래스의 private 멤버변수인 outerMember를 마치 
   // 자신의 멤버 변수인 것처럼 사용할 수 있다. 
   
      private void innerMethod() { 
         System.out.println("om : " + outerMember+ ", im : " + innerMember);
         sOuterMember = 0;
      }
   }
   
   private int outerMember = 1;
   private static int sOuterMember = 0;
   
   // 인스턴스 메서드 영역에서 객체 생성 
   // static 이 아닌 인스턴스 메서드 에서 내부클래스의 객체를 생성한다.
   // 내부클래스 객체 생성 후 그 멤버에 접근하는 것은 일반클래스와 다른 
   // 점이 없다. 
   private void outerMethod() {
      Inner inner = new Inner();
      inner.innerMember = 100;
      inner.innerMethod();
   }

   // 클래스 메서드 영역에서 객체 생성 
   // static 영역에서 인스턴스 내부클래스의 객체를 생성하기 위해서 
   // 먼저 외부클래스의 객체를 생성 후 그 참조 값을 이용해서 내부클래스
   // 객체를 생성할수 있다. 
   public static void main(String[] args) {
      InstanceInnerTest iit = new InstanceInnerTest();
      Inner inner = iit.new Inner(); // 생성자를 호출하는 코드.
      inner.innerMethod();           // 외부 객체의 레퍼런스를 통해야 한다. 
   }
}
//
om : 1, im : 10

내부클래스를 사용하다 보면 가끔 내부클래스의 멤버와 외부클래스의 
멤버간의 이름 충돌로 인해 정확히 소속을 밝혀야 할 경우가 있다.
내부클래스에서 내부클래스의 멤버를 참조할때 this를 쓴다면 
외부클래스의 멤버를 참조할때는 외부클래스.this를 사용한다. 

ex2)
package ch10.nested;

public class DuplicatedNameTest {
   private int num = 100;
   
   class InnerClass{
      private int num = 200;// 이름 충돌
      
      public void method() {
         System.out.println(num);
         System.out.println(this.num);
         System.out.println(DuplicatedNameTest.this.num);
      }
   }
   
   public static void main(String[] args) {
      DuplicatedNameTest dnt = new DuplicatedNameTest();
      InnerClass ic = dnt.new InnerClass();
      ic.method();
   }
}
//
200
200
100

내부클래스는 컴파일 결과물도 일반클래스와 약간다르다.
위 코드의 실행 결과로 생성되는 클래스는 
InstanceInnerTest와 함께 
InstanceInnerTest$Inner 이다. 
즉, 내부클래스는 외부클래스$내부클래스의 이름으로 
.class가 생성된다. 

전혀 별개의 클래스에서 인스턴스 내부 클래스를 생성할 때는 
마치 멤버 변수에 대한 접근과 동일하게 
먼저 외부클래스의 레퍼런스를 확보하고, 이 레퍼런스를 
통해서 내부클래스를 생성해야 한다. 

하나 주의사항은 내부클래스에 대한 패키지 정보가 필요하다.

다음 형태는 Inner 클래스를 import 한 후 
instanceInnerTest()에서 내부클래스인 Inner의 객체를 생성한다. 
InstanceInnerTest 와 OtherClass는 같은 패키지임에도 불구하고 
import 문이 필요하다. 

ex)
import ch10.nested.InstanceInnerTest.Inner;

public class OtherClass {
public void instanceInnerTest() {
// 외부클래스의 객체를 먼저 생성 후 내부클래스 객체 생성 
InstanceInnerTest iit = new InstanceInnerTest();
Inner inner = iit.new Inner();
}
}

다음은 별도의 import 없이 외부클래스를 포함한 전체 이름을 
사용한다. 

ex2)
public class OtherClass {
public void instanceInnerTest() {
InstanceInnerTest iit = new InstanceInnerTest();

//이 부분 외부클래스를 포함한 전체이름 사용.
InstanceInnerTest.Inner inner2 = iit.new Inner();
}
}
// 외부클래스의 객체를 먼저 생성 후 내부클래스 객체 생성 

----------------------------------------------------
1.3 클래스 내부 클래스 

특징 
(1) 클래스 내부클래스는 static 키워드가 붙은 내부클래스이다.
(일반클래스는 클래스를 선언할때 static 키워드를 사용할수 없다.)
따라서 외부 클래스의 객체 생성과 무관하게 사용될수 있다.

(2) 내부클래스에서 외부클래스의 멤버에 접근할때 private를
포함한 모든 멤버에 대해 자유롭게 참조할수 있다. 
물론, 외부 클래스의 참조 값이 있을 때만 사용할수 있다. 
외부클래스는 static이 아니기 때문이다. 

(3)인스턴스 내부클래스와 달리 static 멤버를 가질수 있다. 

객체를 생성할때의 특징도 static 키워드의 특징을 떠올리면 
쉽게 이해할수 있다. static 키워드는 특정한 객체외는 무관하게
동작한다. 따라서 클래스 내부클래스를 생성하기 위해 외부클래스의 
참조값은 필요없다. 단지 클래스가 어디에 있는지만 표시 
해주면 된다. 

ex) 
package ch10.nested;

public class StaticInnerTest {
//class 선언부에 static 키워드가 사용된 클래스 내부클래스
   static class StaticInner {
      private int iMember = 10;
      
      //일반 멤버 변수는 물론 static 키워드가 추가된 멤버도 가질수있다.
      private static int sMember = 0;
      
      private void innerMethod() {
   
//외부클래스의 멤버를 사용할 때는 먼저 외부클래스 객체를
//만들고 그 객체를 통해서 접근한다. 이때 접근 제한자는 무관함.
         StaticInnerTest sit = new StaticInnerTest();
         System.out.println("om: "+sit.oMember+", im: "+iMember);
      }
   }

   private int oMember = 1;

   private void outerMethod() {
   
   //non-static 영역에서의 객체 생성
      StaticInner inner = new StaticInner();
      inner.iMember = 100;
      inner.innerMethod();
   }

   //외부클래스에서 클래스 내부클래스의 객체를 만들때는 외부클래스의
   //참조값 없이 바로 객체 생성이 가능하다.
   public static void main(String[] args) {
   //static 영역에서의 객체 생성 
      StaticInner inner = new StaticInner();
      inner.innerMethod();
   }
}
//
om: 1, im: 10

별개의 클래스에서 클래스 내부클래스의 객체를 생성할때도 외부클래스에 
대한 레퍼런스 없이 바로 생성할수 있다. 단, 외부클래스 이름을 
패키지로 간주한다는 점은 인스턴스 내부클래스와 동일하다. 

ex)
import ch10.nested.StaticInnerTest.StaticInner;

public class OtherClass {
public void staticInnerTest() {
StaticInner sinner = new StaticInner();
}
}

----------------------------------------------------
1.4 로컬 내부 클래스 

특징 
(1) 클래스 영역이 아닌 메서드나 생성자 또는 초기화 
블록의 내부에 선언된 클래스.

(2) static 변수는 가질수 없지만, final static 변수는 가질수 있다.

(3) 내부클래스에서 외부클래스의 멤버에 접근하는 것은 
전혀 제약이 없고 호출할때 외부의 객체에 대한 참조도 필요없다. 

(4) 내부클래스가 선언된 로컬영역의 변수에 접근할때 주의사항
a. 자바7까지는 final로 선언된 변수만 사용 가능하다. 
b. 자바8부터는 final 이외의 변수도 사용가능하다. 
단, final로 간주되므로 새로운 값을 할당할수는 없다. 

마지막 조건이 조금 복잡한데 메모리에서의 라이프사이클
(life cycle)이 다르기 때문이다. 
다음 코드는 method() 내부에 LocalInner 클래스가 선언된 
로컬 내부클래스 형태이다. 
LocalInner 내부의 innerMethod() 메서드에서는 외부메서드인 
method()의 로컬변수 localVar이 사용되고 있다. 

ex)
public void method() {
int localVar = 10;
class LocalInner {
void innerMethod() {
System.out.println(localVar);
}
}
LocalInner inner = new LocalInner();
}

이때 메모리 호출 스택은 다음과 같다. 

스택 
method
inner 0x100 ---> 힙 0x100 : LocalInner
localVar  10 -----힙 localVar 사용중. //언젠가 G.C 될때까지 존재 
//메서드 종료시 즉시 삭제 

그런데 만약 여기서 method()가 종료되면 어떤 일이 발생할까?
메서드 호출 스택은 메서드 종료 즉시 메모리에서 삭제된다. 
여기에는 localVar도 포함되어 있다. 
하지만, 이 변수는 힙에 구성된 객체의 메서드에서 사용되고 
있고 언젠가 G.C가 동작해서 inner가 없어질 때까지는 있어야 한다. 
즉 메모리에 훨씬 더 오래 남아 있을수도있다. 
이런 이유로 자바 7까지는 바로 사라지는 로컬변수를 로컬 내부클래스에서 
사용할수 없었다. 

final이 붙은 변수는 일반 로컬변수와 달리 상수풀(constant pool)에
계속 보관되기 때문에 메서드가 종료되더라도 inner 객체에서 
계속 참조가 가능하다. 
자바 8버전 이후에는 final이 없는 로컬변수도 사용할수 있지만, 
값을 변경할수는 없다. 
내부적으로 컴파일러가 final 키워드를 변수에 추가하는 형태로 
동작하기 때문이다. 

로컬 내부클래스의 객체를 만들기 위해서는 로컬 내부클래스가 
선언된 메서드 등을 호출하고 그 내부에서 객체가 생성된다. 
별개의 클래스에서는 메서드 내부를 볼수없기 때문에 당연히 
로컬 내부클래스 객체 생성이 불가능하다. 

ex)

package ch10.nested;

public class LocalInnerTest {
   int iMember = 1;
   static int cMember = 2;
   
   void method(){
      int localVar = 3;
      
      class LocalInner{
         int innerLocalVar = 4;
         void innerMethod(){
            System.out.println("외부 인스턴스 멤버 변수: "+iMember);
            System.out.println("외부 클래스 멤버 변수: "+cMember);
            System.out.println("외부 로컬 변수: "+localVar);   // JDK 8 이후 가능
            System.out.println("내부 인스턴스 멤버 변수: "+innerLocalVar);
            
            iMember++;
            cMember++;
            //localVar++;               // 여전히 편집은 불가능
            innerLocalVar ++;
         }
      }
      // 내부에서만 객체 생성 가능 
      LocalInner lInner = new LocalInner();
      lInner.innerMethod();
   }
   
   public static void main(String[] args) {
      LocalInnerTest lit = new LocalInnerTest();
      lit.method();
   }
}
//
외부 인스턴스 멤버 변수: 1
외부 클래스 멤버 변수: 2
외부 로컬 변수: 3
내부 인스턴스 멤버 변수: 4

위 코드를 컴파일하면 LocalInnerTest와 LocalInnerTest$1LocalInner 
인 두개의 클래스 파일이 생성된다. 
LocalInnerTest 내부에 여러개의 로컬 내부클래스가 같은 이름으로 
선언될 수 있으므로 숫자가 내부클래스 앞에 접두사로 추가되는 것.


----------------------------------------------------
1.5 익명의 내부 클래스

로컬 내부 클래스의 한 종류로 기본 특성은 동일하다. 
차이점, 부를수 있는 이름이 없다는 점이다. 
이름이 없기 때문에 다른 곳에서 이 클래스를 이용해 
새로운 객체를 만들수 없고 선언과 동시에 바로 클래스를 
구성하고 객체를 생성한다.
따라서 주로 일회용으로 더이상 재사용하지 않는 경우 
적합하다. 익명의 내부클래스는 abstract 클래스나 
인터페이스 구현에 많이 사용된다. 

익명의 내부클래스를 사용하는 예 
SomeSpeaker 와 이 인터페이스를 파라미터로 받는 
useSpeaker()로 구성된 클래스가 구성되어 있다. 

ex)
interface SomeSpeaker {
void sayHello();
}

public class AnonymousInnerTest {
public void useSpeaker(SomeSpeaker speaker) {
speaker.sayHello();
}
}

useSpeaker()에 SomeSpeaker를 구현한 클래스를 만들고 
객체를 넣는 다양한 방법이 떠오를수 있다.
그런데 전제조건으로 이 객체의 sayHello() 메서드가 사용되는 곳에서 
매번 다르게 동작한다고 생각해보자. 즉, 한번만 사용하고 
버리는 상황이다. 

AnonymousInnerTest 내에서만 특색 있게 한번만 사용될 것이므로 
외부에 별도의 클래스를 만들기에는 번거롭다. 
AnonymousInnerTest 내에서 조차 메서드별로 다른 인스턴스 내부클래스나 
클래스 내부클래스를 만드는 것도 재사용할 일이 없으므로 번거롭다. 

마지막으로 로컬 내부클래스 형태로 만들어보자. 

ex)
public void useSpeakerTest() {

//로컬 내부클래스
class KorSpeaker implements SomeSpeaker {
@Override
public void sayHello() {
System.out.println("안녕");
}
}
useSpeaker(new KorSpeaker());<------ 로컬 내부클래스

//로컬 내부클래스
class EngSpeaker implements SomeSpeaker {
@Override
public void sayHello() {
System.out.println("Hello");
}
}
useSpeaker(new EngSpeaker()); <------ 로컬 내부클래스
}

로컬 내부클래스에 따라 한국어와 영어로 메시지가 출력된다. 
여기서 아쉬운 점은 한번 파라미터로 넣어서 사용하기에 
코드가 과하다는 점. 여기서 핵심은 SomeSpeaker를 
구현한 객체를 넣는 것이고, 이 객체는 sayHello()를 
재정의 해야하는 것이다. 즉, 
KorSpeaker나 EngSpeaker와 같은 이름은 사실 중요치 않다. 
어차피 다시 불려서 객체로 만들 가능성은 없기 때문이다. 
이 코드를 익명의 내부클래스로 변경해보자. 
익명의 내부클래스를 만드는 방법은 간단한데 좀 어색하다. 
다음 코드를 살펴보자.

ex)
useSpeaker(

//익명의 내부클래스
new SomeSpeaker() { //new [XXClass_name implements] SomeSpeaker
@Override
public void sayHello() {
System.out.println("안녕");
}
}
);

useSpeaker()의 파라미터로 new 키워드와 함께 생성자가
호출되었나 싶지만, 사실 SomeSpeaker는 인터페이스이기 때문에 
생성자가 아니다. 어찌보면 

new [XXClass_name implements] SomeSpeaker 처럼 
사이에 클래스 이름이 생략된 형태이다. 

그래서 익명의 내부클래스이다. 인터페이스를 바로 객체로 
만들지 못하는 이유는 abstract 상태의 메서드가 있기때문이다. 
익명의 내부클래스는 객체를 생성하면서 바로 abstract 메서드를 
재정의해서 이 문제를 해결한다. 이 클래스는 이름이 없기 때문에 
다른 곳에서 부를수도, 재활용할 수도 없이 딱 일회용이다. 

참고,
익명의 내부클래스를 한줄 한줄 작성하기는 중괄호가 매우 복잡해 보임.
이클립스의 자동완성 기능을 이용하면 쉽게 익명의 내부클래스를 
작성할 수 있다. 익명의 내부클래스를 작성할 메서드의 파라미터 영역
내에서 new 키워드 후 삽입할 클래스의 상위 인터페이스 이름을 
작성 후 ctrl+space 를 입력하면 삽입할 내부 클래스가 
팝업되는데 이 클래스를 선택하면 기본코드가 제공된다. 
여기서 필요한 메서드만 재정의하면 어렵지 않게 작성이 가능하다. 
!

기본적인 익명의 내부클래스 사용방법 예제 

ex)
package ch10.nested;

interface SomeInterface {
   void printInfo();
}

public class AnonymousInnerTest {
   int iMember = 1;
   static int cMember = 2;

   void method(SomeInterface si) {
      si.printInfo();
   }

   public static void main(String[] args) {
      AnonymousInnerTest lit = new AnonymousInnerTest();
      int localVar = 3;
      lit.method(new SomeInterface() {
         @Override
         public void printInfo() {
            //System.out.println("외부 인스턴스 멤버 변수: " + iMember);
            System.out.println("외부 클래스 멤버 변수: " + cMember);
            System.out.println("외부 로컬 변수: " + localVar); // JDK 8 이후 가능

            cMember++;
            //localVar++; // 여전히 편집은 불가능
         }
      });
   }
}
//
외부 클래스 멤버 변수: 2
외부 로컬 변수: 3

method()를 호출하면서 SomeInterface 타입 객체를 익명의 
내부클래스 형태로 넘겨준다. 클래스 내부에서는 추상 메서드인 
printInfo()를 구현한다. 
printInfo()는 static인 main() 내부에 있기 때문에 21행처럼 
인스턴스 멤버를 바로 사용할수는 없다. 
22행처럼 클래스 멤버나 23행처럼 로컬변수를 참조하는 것은 가능하다.
하지만, 26행처럼 로컬 변수를 수정할수는 없고 읽기 전용으로만 
사용가능. 

위의 예를 컴파일한 결과로 AnonymousInnerTest와 AnonymousInnerTest$1
이라는 두개의 클래스가 생성된다. 즉 익명의 내부클래스는 정확한 
이름도 없다. 

이제까지의 내용을 바탕으로 클래스를 만들고 참조 값을 전달하는 
다양한 방식에 대해 하나의 예를 통해 알아보자. 

ex)
package ch10.nested;

interface InfoPrintable {
   public void printInfo();
}

public class VariousInnerClassTest {
   public void useInnerClass(InfoPrintable inner) {
      inner.printInfo();
   }

   public void useSpeakerTest() {
      useInnerClass(new InfoPrintable() {
         @Override
         public void printInfo() {
            System.out.println("익명의 내부 클래스");
         }
      });
      class EngSpeaker implements InfoPrintable {
         @Override
         public void printInfo() {
            System.out.println("로컬 내부 클래스");
         }
      }
      useInnerClass(new EngSpeaker());
      useInnerClass(new InstanceInnerClass());
   }

   class InstanceInnerClass implements InfoPrintable {

      @Override
      public void printInfo() {
         System.out.println("인스턴스 내부 클래스 이용");
      }
   }
}

class SomeClass implements InfoPrintable {

   @Override
   public void printInfo() {
      System.out.println("같은 파일에 있을 뿐 일반 클래스");
   }
}
//
외부 클래스 멤버 변수: 2
외부 로컬 변수: 3

전반적으로 별개의 클래스 -> 인스턴스(클래스) 내부클래스->
로컬 내부클래스 -> 익명의 내부클래스로 갈수록 복잡도가 
줄어드는 것 알수 있다. 
하지만, 그만큼 재활용성은 떨어진다. 
원하는 목적에 따라 적절한 방식의 선택이 중요한 이유이다. 


----------------------------------------------------
2. 람다식

2.1 람다식이란?

람다식(Lambda Expression : λ)은 자바 8에 추가된 가장 큰 특징의 
하나로 자바에서 함수형 프로그래밍 형태를 받아들인 결과이다. 
먼저, 함수형 프로그래밍에 대해 알아보자. 

1990년대부터 가장 대중적인 프로그래밍의 형태로 인기를 끌고 있는 
객체지향 프로그래밍과 함께 최근에 주목받고 있는 프로그래밍 방식은 
함수형 프로그래밍이다. 
사실 함수형 프로그래밍은 1950년대부터 있었으므로 객체지향보다 
역사가 오래되었다. 
함수형 프로그래밍 자체를 설명하기는 이 책의 범위에 한계이므로,
여기서는 '기능 위주의 프로그래밍 기법' 이라고만 정의하자.
객체지향 프로그래밍은 클래스 속성과 기능을 정의한다. 
즉, 기능은 객체에 포함된 개념이다. 하지만,
함수형 프로그래밍에서 기능, 즉 함수가 따로 존재한다. 

참고.
메서드 vs 함수?
객체지향 개념을 설명하면서 객체가 가지는 기능을 메서드 또는 
함수(function)이라고 지칭했다.
맞는 말인데 함수형 프로그래밍을 설명하다 보면 미묘한 차이가 
발생한다. 이제부터 나오는 설명에서 메서드는 특정 객체가 
수행하는 기능, 함수는 특정 객체에 속하지 않는 기능으로 
구별하자. 

예) 배열의 정렬이라는 주제에 관해 이야기해보자.
Arrays 클래스가 제공하는 sort() 메서드를 이용하면 
배열의 요소를 정렬할 수 있다.

String [] strs = {"this", "is", "java", "world"};
System.out.println(Arrays.toString(strs)); 
// 정렬 전: [this, is, java, world]
Arrays.sort(strs);
System.out.println(Arrays.toString(strs));
// 정렬 후 : [ is, java, this, world]

이 코드를 실행하면 알파벳 오름차순으로 정렬된  결과를 
볼수있다. Arrays 의 sort(String[]) 메서드는 문자열을 
비교할때 다음과 같은 Comparator의 compare() 메서드를 
사용한다. 정렬에 관한 내용이 생각나지 않는다면 5장 으로.

public int compare(String o1 , String o2) {
return o1.compareTo(o2);
}

compare() 내부에서는 String의 compareTo()를 이용하는데 
두 문자열을 알파벳 순으로 비교해서 o1이 크면 
(사전순으로 뒤에 나오면) 양수, 작으면 음수, 같으면 0을
리턴한다. 그래서 compare()의 결과 양수가 반환되면 
두 문자열은 자리를 바꾼다. 

그런데 원하는 정렬의 기준을 알파벳 내림차순 또는 글자수를
기준으로 오름차순등 기존에 제공하지 않는 방식으로 
처리하려면 어떻게 해야 할까?
실제로 윈도우 탐색기를 보면 다양한 형태의 정렬 기준을 
사용가능. 

sort()가 가지는 기본 정렬 방식을 사용하지 않으려면 
새로운 정렬 방식을 적용해 주어야한다. 

이를 위해 필요한 새로운 기능을 만들고 Arrays.sort()에
전달하면 되는데 자바에서는 기능, 즉 함수만을 전달할수는없다.
자바에서 전달 할수있는것은 오로지 객체이다. 
그래서, 기능을 가지는 클래스를 만들고 그 클래스의 객체를
전달한다. 많은 경우 이런 정렬방식은 해당 클래스에서만 
유요한 경우가 많다. 

이제 머리에 떠오르는 것은 내부클래스 일것이다 .
특히, 일회용의 정렬 기능 작성을 위해서는 익명의 내부클래스
만한 것이 없다. 다음은 익명의 내부클래스를 이용해 내림차순
정렬을 위한 Comparator를 작성하고 전달하는 코드이다. 

ex)
Arrays.sort(strs, new Comparator<String>() {
@Override
public int compare(String o1, String o2) {
return o1.compareTo(o2)* -1;
}
}); // -1 을 곱해서 내림차순으로 정렬한다
System.out.println(Arrays.toString(strs));
//내림차순 정렬후 :[world, this, java, is]

위 코드는 잘 동작함. 여기서 주목할 내용은 정렬을 위해 
필요했던 '기능은 Comparator가 아니라 사실 compare()라는 
점에 주목할 필요가 있다. compare()만 있으면 되지만, 
자바 언어의 한계 또는 특성으로 인해 익명의 내부클래스를 
만들고 객체화해서 전달하고 있다. 

자바8 부터 등장한 람다식은 이런 번거로움을 없애준다. 
위 코드를 람다식으로 표현하면 다음과 같다. 

ex)
Arrays.sort(strs, (o1,o2) -> { return o1.compareTo(o2) * -1;});
System.out.println(Arrays.toString(strs));
//정렬 후 :[world, this, java, is]

한눈에 보아도 분명 코드가 간결해진 것을 알수있다. 
람다식은 객체가 필요한 자리에 단순히 코드 블록만을 전달한다. 
이 람다식이 바로 함수라고 볼수있다. 
람다식은 런타임에 익명의 내부클래스로 변경돼서 처리되므로 
동작은 동일하다. 

(1) 함수형 인터페이스(functional interface) 
또는 타겟 타입(target type) 
람다식은 단순히 파라미터와 메서드의 구현부로 구성된다. 
즉 기능에만 초첨을 맞춰서 작성한다. 
그리고 이 표현식은 앞서 이야기했듯이 익명의 내부클래스로 
변환되어 참조값 형태로 전달된다. 
위의 코드를 약간 풀어서 써보면 다음과 같다. 

ex)
Comparator<String> strComp = (o1, o2) -> {
return o1.compareTo(o2)* -1; // 람다식의 리턴 타입은 함수형 인터페이스
};
Arrays.sort(strs, strComp);
System.out.println(Arrays.toString(strs));

이처럼 람다식은 결과적으로 인터페이스 타입의 클래스를 
손쉽게 구현하는 방법이다. 이런 인터페이스를 함수형 
인터페이스 또는 타겟 타입이라고 한다. 

함수형 인터페이스에는 반드시 하나의 abstract 메서드만 
존재 해야한다. 만약, abstract 메서드가 없거나 두개이상 
존재한다면 람다식으로 대체할수없다. 

함수형 인터페이스에는 일반적으로 @FunctionalInterface
애노테이션이 선언된다. 이 애노테이션은 필수요소는 
아니지만 컴파일러에게 '이 인터페이스는 람다식에서 사용할 
함수형 인터페이스이므로 abstract 메서드가 하나만 있는지를 
검사하라'고 요청한다. 
따라서 하나 이상의 abstract 메서드를 작성하면 오류가 발생. 
즉 안정적인 프로그래밍을 위한 옵션이다. 
다음은 위에서 살펴봤던 Comparator 인터페이스의 소스 일부이다. 

ex)
@FunctionalInterface
public interface Comparator<T> {
int compare( T o1, T o2);
...
}

한가지 신기한 점은 람다식을 사용할때 어떤 타입도 선언된 적이 
없는데 알아서 잘 적용이 된다는 점이다. 컴파일러는 메서드에 
선언된 타입을 보고 필요한 메서드 선언부가 작성된 람다식을 보면 
해당 타입의 익명 내부클래스로 변경해서 할당한다. 

람다식과 타입 추정 

함수형 인터페이스 타입 
Arrays.sort(strs, [Comparator 필요]);

① 
@FunctionalInterface
public interface Comparator<T> {
int compare(T o1, T o2);
...
}

② T 타입 변수 2개를 받아서 int 를 반환하는 메서드가 
하나 있군. 

(o1, o2) -> {return o1.compareTo(o2)*-1;}

③
Comparator 타입으로 인정. 

----------------------------------------------------
2.2 다양한 형태의 람다식 

람다식은 파라미터 및 리턴타입에 따라 다양한 형태로 작성된다. 
람다식은 축약형이 많은데 이때 형태가 기존의 코드와 사뭇 다르기 
때문에 작성법을 많이 연습해야 손에 익는다. 

(1) 기본 람다식 
람다식은 소괄호로 묶인 파라미터 그룹과 람다 연산자(->),
중괄호로 묶인 실행문으로 구성된다. 

ex)
(type variable_name [,...]) -> {실행문;}
   파라미터        람다연산자  메서드구현 
   
이 표현식의 의미는 '선언된 파라미터들을 이용해서 실행문을 
실행하라!' 정도이다.
파라미터 부분은 실행문 블록에서 사용하기 위한 값을 제공하는
일반적인 메서드의 파라미터 선언과 동일하다. 

ex2)
(String msg) -> {System.out.println(msg);}
이때 파라미터 선언부의 파라미터 타입은 런타임시 대입되는 값에 
따라 자동 인식되므로 일반적으로 생략한다. 

ex3)
(msg) -> {System.out.println(msg); }

파라미터가 하나일 경우 소괄호를 생략가능.
실행문장이 한문장일 경우 중괄호 역시 생략가능.
이때, 실행문의 마지막을 의미하는 ';' 역시 생략가능.

ex4)
msg -> System.out.println(msg)

하지만, 파라미터가 하나도 없는 경우는 소괄호를 생략할수 없다.

ex5)
() -> System.out.println("Hello")

리턴이 필요한 경우 일반적인 함수의 구현처럼 return 키워드를
이용해서 리턴한다. 

ex6)
(msg) -> {
System.out.println(msg);
return msg;
}

실행문이 단순히 리턴문 하나로만 구성되는 경우 중괄호와
함께 return 키워드도 생략 할수 있다. 
하지만 중괄호를 생략하고 return 문을 사용할수는 없다. 

(msg) -> "Hello" + msg 
// msg -> return "Hello" + msg // 오류 

실제로 함수형 인터페이스를 작성하고 다양한 형태의 
람다식의 사용 예를 살펴보자. 

(2) 파라미터와 리터 타입이 없는 경우의 예 

리턴타입과 파라미터가 없는 메서드를 갖는 함수형 인터페이스를 
만들고 람다식을 이용해서 사용해봦.

ex)
package ch10.lambda;

@FunctionalInterface
interface FunctionalInterface1 {
   void methodA();
   // void methodB();//Invalid '@FunctionalInterface' annotation;
   FunctionalInterface1 is not a functional interface
}

public class LambdaEx1 {
   public static void useFIMethod(FunctionalInterface1 fi) {
      fi.methodA();
   }

   public static void main(String[] args) {
      useFIMethod(new FunctionalInterface1() {
         @Override
         public void methodA() {
            System.out.println("익명의 내부 클래스 형태");
         }
      });
      useFIMethod(() -> {
         System.out.println("람다 표현식 이용 1");
      });
      useFIMethod(() -> System.out.println("람다 표현식 이용 2"));
   }
}
//
익명의 내부 클래스 형태
람다 표현식 이용 1
람다 표현식 이용 2

(3) 파라미터가 있는 람다식 

ex)
package ch10.lambda;

@FunctionalInterface
interface FunctionalInterface2 {
   void methodB(String msg);
}

public class LambdaEx2 {
   public static void useFIMethod(FunctionalInterface2 fi) {
      fi.methodB("홍길동");
   }

   public static void main(String[] args) {
      useFIMethod((String msg) -> {
         System.out.println("람다 표현식 이용 1: " + msg);
      });
      useFIMethod(msg -> System.out.println("람다 표현식 이용 2: " + msg));
   }
}
//
람다 표현식 이용 1
람다 표현식 이용 2

(4)리턴 타입이 있는 람다식 

package ch10.lambda;

@FunctionalInterface
interface FunctionalInterface3 {
   String methodB(String msg) throws Exception;
}

public class LambdaEx3 {
   public static void useFIMethod(FunctionalInterface3 fi) {
      try {
         System.out.println(fi.methodB("홍길동"));
      } catch (Exception e) {
         e.printStackTrace();
      }
   }

   public static void main(String[] args) {
      useFIMethod((String msg) -> {
         return "람다 표현식 이용 1: " + msg;
      });
      useFIMethod(msg -> "람다 표현식 이용 2: " + msg);
      //파라미터 타입이 생략. 파라미터의 갯수가 하나이므로 소괄호가 
      //필요없고, 리턴문장 하나만 존재하므로 return 키워드및 
      //중괄호도 필요없다.
   }
}
//
람다 표현식 이용 1: 홍길동
람다 표현식 이용 2: 홍길동

(5) 람다의 실행 블록에서 변수 참조 
람다식은 컴파일러에 의해 익명의 내부클래스로 처리되기 
때문에 변수에 대한 참조 규칙도 동일하다. 

a. 외부클래스의 멤버를 자유롭게 사용할수 있다. 
b. 자바 8부터는 일반 로컬변수도 사용할수 있는데 final 키워드가 
적용된 것처럼 새로운 값을 할당할수는 없다. 

하지만, this를 사용하는 방법은 약간 다르다. 
람다식에서 this는 타겟 인터페이스가 아닌 외부클래스를
나타낸다. 따라서 람다식 내에서 this와 
외부클래스.this는 동일한 객체를 나타낸다. 

ex)
package ch10.lambda;

@FunctionalInterface
interface FunctionalInterface4 {
   String methodB(String msg);
}

public class VariableUseTest {
   private int instanceMember = 10;

   public void useFIMethod(FunctionalInterface4 fi) {
      System.out.println(fi.methodB("홍길동"));
   }
   
   public void lambdaTestMethod() {
      int localVar = 20;
      
      useFIMethod((String msg) -> {
         System.out.println("this: " + this);
         System.out.println("외부클래스.this: " + VariableUseTest.this);
         System.out.println("변수 참조: " + localVar + " : " + instanceMember);
         // localVar++;   // 로컬 변수 수정은 불가
         return "람다 표현식 이용 : " + msg + ", " + (instanceMember++);
      });

      useFIMethod(new FunctionalInterface4() {
         @Override
         public String methodB(String msg) {
            System.out.println("this: " + this);
            System.out.println("외부클래스.this: " + VariableUseTest.this);
            System.out.println("변수 참조: " + localVar + " : " + instanceMember);
            // localVar++;   // 로컬 변수 수정은 불가
            return "익명의 내부 클래스 이용 : " + msg + (instanceMember++);
         }
      });
   }

   public static void main(String[] args) {
      VariableUseTest vut = new VariableUseTest();
      vut.lambdaTestMethod();
   }
}
//
this: ch10.lambda.VariableUseTest@7cef4e59
외부클래스.this: ch10.lambda.VariableUseTest@7cef4e59
변수 참조: 20 : 10
람다 표현식 이용 : 홍길동, 10
this: ch10.lambda.VariableUseTest$1@2db0f6b2
외부클래스.this: ch10.lambda.VariableUseTest@7cef4e59
변수 참조: 20 : 11
익명의 내부 클래스 이용 : 홍길동11

----------------------------------------------------
3. 람다식을 이용한 함수형 프로그래밍

객체지향 언어로서의 자바 프로그래밍에서는 메서드의 구조와 이름이 
중요하다. 이름을 통해서 기능을 호출하기 때문이다. 

ex)
Arrays.sort(strs, new Comparator<String>(){
@Override
public int compare(String o1, String o2) {
return o1.compareTo(o2);
//Comparator의 compare 가 사용됨. 
}
})

하지만, 함수형 프로그래밍에서는 함수의 타입이 구조적이며 필요한 곳에 
바로 전달되므로 이름은 불필요하다. 

ex2)
Arrays.sort(strs, (o1, o2) -> { return o1.compareTo(o2)*-1;});

함수의 타입이 구조적이라는 표현은 자주 쓰는 패턴이 정해져 있다는 말이다. 
일반적으로 함수는 파라미터가 없거나 하나, 많으면 두개이다. 
반환 값은 있거나 없다. 
달라지는 것은 이를 이용한 구현부이다. 
따라서, 몇개 안되는 함수의 형태는 함수형 인터페이스로 정의하고 
달라지는 구현부는 람다식을 이용해서 작성한다. 

자바 8에서는 빈번히 사용되는 함수형 인터페이스들을 
java.util.function 패키지를 통해 제공한다. 
이 패키지에 선언된 함수형 인터페이스들은 메서드나 
생성자의 파라미터로 제공되는 타겟 인터페이스 사용된다. 

다음은 java.util.function 패키지에서 제공되는 기본 API의 종류들이다. 

종류 : abstract method 특징 
종류 : 파라미터 : 리턴: 메서드 : 비고 
(1) Consumer 계열 : O : X : void accept(T) : 소비자
(2) Supplier 계열: X : O : T get() : 공급자 
(3) Function 계열 : O : O :T apply(R) : 주로 파라미터를 리턴으로 매핑 
(4) Operation 계열 : O :O : T xxx(R) : 주로 파라미터를 연산해서 리턴 
(5) Predicate 계열 : O : boolean : boolean test(T) : 파라미터를 이용해서 return 결정. 

----------------------------------------------------
3.1 Consumer 계열

Consumer 계열은 소비자이다. 무엇을 소비할까? 바로 파라미터이다. 
Consumer 는 전달받은 파라미터를 받아서 소비하는 소비자이며 
리턴하지는 않는다. 

파라미터 -> Consumer :파라미터 소비 

다음은 Consumer 계열의 함수형 인터페이스 종류.

인터페이스명 : 메서드 : 설명 
(1) Consumer<T> : void accept (T t) : T 타입 객체 t를 받아서 소비 

(2)BiConsumer<T, U> : void accept( T t , U u) 
: T 타입과 U 타입 객체를 받아서 소비 

(3)P*Consumer : void accept(p# value)
 : p# 타입의 값을 받아서 소비 

 (4)ObjP*Consumer<T> : void accept(T t, p# value) 
: 객체 타입 T와 p# 값을 받아서 소비 

P* : Int, Long, Double를 의미하고, 
p# : int , long , double 을 나타낸다. 

P*와 p#에 해당하는 값들을 대입해보면 총 8가지가 존재하지만, 
매우 직관적인 이름 규칙을 가지고 있기 때문에 어렵지 않게 
이해할 수 있다. 이 규들은 다른 함수형 인터페이스에도 비슷하게 
적용되니 잘 기억하자. 

먼저, Consumer<T> 는 객체 하나를 받아서 소비한다. 
파라미터 두개를 받는 경우 Bi 접두사가 붙는다. 
BiConsumer<T, U>는 T와 U 두개를 파라미터로 받는다. 

객체를 처리하지 않고 기본형을 처리하는 경우 double, long, int 
값을 처리할수 있다. 
이때, 인터페이스에는 각 타입의 첫 글자를 대문자로 바꿔서 접두사로 추가해준다. 
(DoubleConsumer, LongConsumer, IntConsumer)

객체와 함께 기본형을 받는 경우 다시 위 인터페이스 이름 앞에 Obj가 추가된다. 
(ObjDoubleConsumer<T>, ObjLongConsumer<T>, ObjIntConsumer<T>)

물론, int 값을 처리하기 위해 Consumer<Integer>를 이용한다면 
IntConsumer를 사용하지 않아도 좋다. 
하지만, 내부적으로 오토박싱(auto boxing)이 일어나기 때문에 성능상 
좋지는 않다. 될수 있으면 타입에 특화된 버전을 사용하는 것이 좋다. 

간단히 Consumer<T> 를 사용해보자. 
다음 예는 문자열 하나를 파라미터로 받아서 출력한다. 
따라서, 콘솔에 Hello 가 출력된다. 

ex)
Consumer<String> consumer = x -> System.out.println(x);
consumer.accept("Hello");

다음은 객체인 String 과 int 를 받아서 처리하는 ObjIntConsumer의 사용 예.

ex2)
ObjIntConsumer<String> consumer2 = (name, repeat) -> {
for (int i =0; i < repeat; i++){
System.out.println(name);
}
};
consumer2.accept("홍길동",2);

Student 타입의 객체를 다양한 방식으로 출력 해보자. 

ex3)
package ch10.lambda.functional;

import java.util.function.Consumer;

public class ConsumerTest {
   public static void printStudent(Student student, Consumer<Student> printer) {
   
   //Student 타입 객체와 Student를 소비하는 Consumer인 printer를 갖는 
   //printStudent()를 정의한다. 
   
      printer.accept(student);
   }

   public static void main(String[] args) {
      Student student = new Student("홍길동", 80);

      printStudent(student, s -> System.out.println(s.name));
      printStudent(student, s -> s.score *= 1.5);
      printStudent(student, s -> System.out.println(s.name + ": " + s.score));
   }
}

class Student {
   public String name;
   public double score;

   Student(String name, double score) {
      this.name = name;
      this.score = score;
   }
}
//
홍길동
홍길동: 120.0



----------------------------------------------------
3.2 Supplier 계열

Supplier는 리턴값을 공급해주는 공급자다. 
이 계열은 파라미터를 받지 않으며 자체적으로 리턴할 값을 생산한다. 

동작 방식 
리턴 값 생산  Supplier---> return

Supplier 계열의 인터페이스

인터페이스명 : 메서드 : 설명 

(1) Supplier<T> : T get() : T 타입 객체 리턴 
(2) P*Supplier : p# getAsP*() : p# 타입의 값 리턴 

P* : Int, Long, Double를 의미하고, 
p# : int , long , double 을 나타낸다. 

Supplier 계열은 파라미터가 없기 때문에 Bi가 붙는 형태는 없다. 

ex)
Supplier<String> supplier = () -> { return "Hello";};
System.out.println(supplier.get());

IntSupplier supplier2 = () -> {
Random random = new Random();
return random.nexInt(6);
};
System.out.println(supplier2.getAsInt());

ex2)
package ch10.lambda.functional;

import java.util.function.Supplier;

public class SupplierTest {

   public void useSupplier(Supplier<String> sup) {
      System.out.println(sup.get());
   }

   public static void main(String[] args) {
      SupplierTest supT = new SupplierTest();
      Supplier<String> sup = () -> {
         return "Hello";
      };
      supT.useSupplier(sup);

      supT.useSupplier(() -> {
         return "Lambda";
      });
      supT.useSupplier(() -> "World");
      //인라인 형태로 Supplier를 useSupplier()의 파라미터로 전달한다. 
      // 이때, return 문 하나로만 구성되므로 중괄호와 return 키워드는 생략되었다. 
   }
}
//
Hello
Lambda
World

----------------------------------------------------
3.3 Function 계열

Consumer 계열과 Supplier 계열이 각각 파라미터, 리턴값만을 설정하는 
형태여서 활용에 어려움이 있었다면 Function 계열을 사용할수 있다. 
Function 계열은 파라미터를 받고 리턴도 존재한다. 

파라미터 -> Function -> return 
  파라미터 활용 ----> 리턴값 생성  
  
다음은 Function 계열의 함수형 인터페이스 종류이다. 

인터페이스 명 : 메서드 : 설명 
(1) Function<T, R> : R apply (T t) : T 타입의 파라미터를 받고 R 타입을 리턴 

(2) BiFunction<T, U, R> : R apply (T t, U u)
: T와 U 타입의 파라미터를 받고 R 타입을 리턴

(3) P*Function<R> : R apply (p# value) 
: p# 타입의 값을 받아서 R 타입으로 리턴 

(4)P*toQfunction : q applyAsQ(p# value) 
:p* 타입의 값을 받아서 q 타입으로 리턴 

(5) ToP*Function<T> : p# applyAsP*(T t)
:p# 타입의 값을 받아서 R 타입으로 리턴 

(6) ToP*BiFunction<T> : p# applyAsP*(T t, U u)
:T와 U 타입의 값을 받아서 p# 타입으로 리턴


P* , Q : Int, Long, Double를 의미하고, 
p# , q : int , long , double 을 나타낸다. 

Function 계열은 가장 다양한 형태의 인터페이스들이 제공되지만, 
Consumer와 Supplier 의 이름 적용 방법을 잘 학습했다면 
어렵지 않게 내용을 파악가능.

ex)
Function<String, Integer> function = (src) -> { return src.length();};
System.out.println(function.apply("Hello"));

ToIntBiFunction<String, String> function2 = (src1,src2) ->{
return Integer.parseInt(src1) + Integer.parseInt(src2);
};
System.out.println(function2.applyAsInt("4","5"));

다음은 Function 인터페이스를 이용하는 예.

ex2) 
package ch10.lambda.functional;

import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.ToIntFunction;

public class FunctionTest {
   private Person person;

   //String 과 Integer 두 개의 파라미터를 받고 Person을 리턴하는 
   //BiFunction 타입에 String, Integer를 받는 메서드 apply()가 있다. 
   //apply()에 name 과 age를 넘겨주면 Person이 리턴된다. 
   
   public void addPerson(BiFunction<String, Integer, Person> function, String name, Integer age) {
      person = function.apply(name, age);
   }

   // String을 파라미터로 받고 String을 리턴하는 Function 타입과 String을 파라미터
   // 로 받는 메서드이다. function의 apply()에 name을 넘겨주면 String이 리턴된다. 
   
   public void printPerson(Function<String, String> function, String name) {
      System.out.println(function.apply(name));
   }

   // String을 파라미터로 받아 int를 리턴하는 ToIntFunction 타입과 String을 파라미터
   //로 받는 메서드이다. function은 applyAsInt()에 name 을 넘겨주면 int 를 리턴한다. 
   
   public void printAge(ToIntFunction<String> function, String name) {
      System.out.println(name + "의 나이: " + function.applyAsInt(name));
   }

   public static void main(String[] args) {
      FunctionTest ft = new FunctionTest();
      
      //addPerson()을 호출하면서 람다식을 이용해 BiFunction 타입 인터페이스를 
      //넘긴다. 구현부에서는 Person 객체를 생성후 리턴한다. 
      
      ft.addPerson((name, age) -> {
         return new Person(name, age);
      }, "홍길동", 10);

      // printPerson()을 호출하면서 람다식을 이용해 Function 타입 인터페이스를 넘긴다. 
      // 구현부에서는 Person 객체의 name이 파라미터인 홍길동과 같으면 객체의 
      // toString() 을 리턴하고 그렇지 않으면 unknown user를 리턴한다. 
      ft.printPerson((name) -> {
         if (ft.person.name.equals(name)) {
            return ft.person.toString();
         } else {
            return "unknown user";
         }
      }, "홍길동");

      // printAge()을 호출하면서 람다식을 이용해 ToIntFunction 타입 인터페이스를 넘긴다. 
      // 구현부에서는 Person 객체의 name이 홍길동과 같으면 객체의 age 값을, 
      // 그렇지 않으면 0을 리턴한다.       
      ft.printAge((name) -> {
         if (ft.person.name.equals(name)) {
            return ft.person.age;
         } else {
            return 0;
         }
      }, "홍길동");
   }
}

class Person {
   String name;
   int age;

   Person(String name, int age) {
      this.name = name;
      this.age = age;
   }

   @Override
   public String toString() {
      return "Person [name=" + name + ", age=" + age + "]";
   }
}
//
Person [name=홍길동, age=10]
홍길동의 나이: 10

----------------------------------------------------
3.4 Operator 계열

Operator 계열은 Function 계열과 유사하게 파라미터와 리턴 타입을 
모두 갖는다. 다만, 차이점은 Function 계열은 파라미터와 리턴타입이 
무관하지만, Operator 계열은 파라미터를 이용해 어떤 연산을 수행한 후 
파라미터와 같은 타입이 린턴된다. 

동작방식
파라미터 -> Operator ->return
 파라미터활용 -> 파라미터 리턴 

다음은 Operator 계열의 함수형 인터페이스 종류이다. 

인터페이스 명 : 메서드 : 설명 
(1)UnaryOperator<T> : T apply(T t) 
: T 타입의 파라미터를 받고 T 타입을 리턴 

(2) BinaryOperator<T> : T apply(T t1, T t2)
: T와 T 타입의 파라미터를 받고 T 타입을 리턴.

(3) P*UnaryOperator : P* appAsP*(p# value) :
P* 타입의 값을 받아서 p# 타입으로 리턴 

(4) P*BinaryOperator: P* appAsP*(p# value1, p# value2)
: P* 타입의 값을 두개를 받아서 p# 타입 리턴 

P*는 Int, Long, Double을 의미.
p# 는 int, long, double

Operator 계열은 여러모로 Function 계열을 닮았다. 
실제로 UnaryOperator<T>는 Function<T,T>를 
상속받았고 BinaryOperator<T>는 BiFunction<T, T, T>
를 상속받았다. 

ex)
UnaryOperator<Double> operator = (x) -> { return Math.pow(x,2);};
System.out.println(operator.apply(10,0));

DoubleBinaryOperator operator2 = (x,y) -> { return Math.max(x,y);};
System.out.println(operator2.applyAsDouble(100,200));


----------------------------------------------------
3.5 Predicate 계열

Predicate 계열은 파라미터와 리턴 타입을 갖는데 리턴타입이
boolean으로 고정되어 있다. 

동작방식 
parameter-> Predicate -> boolean
                 파라미터로 판단
              
다음은 Predicate 계열의 함수형 인터페이스 종류이다. 

인터페이스명 : 메서드 : 설명 

(1) Predicate<T> : boolean test (T t)
:T 타입의 파라미터를 받고 boolean을 리턴.

(2) BiPredicate<T> : boolean test( T t, U u)
: T와 U 타이의 파라미터를 받고 boolean을 리턴 

(3) P*Predicate : boolean test(P* value)
:P* 타입의 값을 받아서 boolean으로 리턴 

P*는 Int, Long, Double을 의미.

ex)
Predicate<String> predicate = (name) -> { return name.contains("Java");};
System.out.println(predicate.test("JavaScript");

DoublePredicate predicate2 = (num) -> { return num > 0.5;};
System.out.println(predicate2.test(Math.random()));

다음은 int의 배열에서 원하는 형태의 데이터만 추출하는 예제.

ex2)
package ch10.lambda.functional;

import java.util.function.IntPredicate;

public class PredicateTest {
   static int[] nums = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
   
   public static void printSome(IntPredicate pred) {
      for (int num : nums) {
         if (pred.test(num)) {
            System.out.print(num + "\t");
         }
      }
      System.out.println();
   }

   public static void main(String[] args) {
      printSome((num) -> {
         return num % 3 == 0;
      });
      printSome(num -> num > 5);
   }
}
//
3   6   9   
6   7   8   9   10   

----------------------------------------------------
3.6 표준 함수형 인터페이스의 메서드

이제까지 소개했던 java.util.function 패키지의 인터페이스들은 모두 
하나 이상의 default 또는 static 메서드를 포함하고 있는데 
이들 메서드를 이용해서 동일한 계열의 여러 동작을 연결해서 
사용할수 있다. 

(1) andThen() 과 compose() 
andThen()과 compose()는 Consumer, Function, Operator 계열에 선언된 
default 메서드로 두개의 함수형 인터페이스를 순차적으로 연결한다. 
이때 첫번째 함수의 연산의 결과를 두번째 함수의 파라미터로 제공해서 
최종 결과 값을 도출한다. 최종값의 타입은 당연히 두번째 함수의 리턴타입이다.

이 두메서드의 차이점은 적용순서이다. 먼저, andThen()을 살펴보자. 

A 인터페이스에 선언된 andThen()을 사용해서 B 인터페이스를 연결할 때는 
A.andThen(B)와 같이 작성한다. 그럼 두개의 인터페이스가 결합된 AB 인터페이스를 
사용할수 있고 최종 결과는 AB 인터페이스를 통해서 확인할수 있다. 
이 때 A의 결과는 B의 파라미터로 활용되고 B가 리턴하는 값이 AB가 
리턴하는 값과 동일하다. 

andThen() 의 동작 방식. 

(1) //(3)의 리턴 값 받음. 
AB = A.andThen(B)
AB.method(param) 

(2) //(1)이 파라미터 값 (3)으로 리턴
A 
(lambda ex) 

(3) //(2)의 리턴값이 파라미터로 그리고  (1)으로 리턴
B 
(lambda ex)

(1) = (2) ->  (3)

compose() 는 A와 B의 적용순서가 반대이다. 
A 인터페이스에 선언된 compose()를 사용해서 B 인터페이스
를 연결할 때는 A.compose(B) 와 같이 작성한다. 
역시 두개의 인터페이스가 결합된 AB 인터페이스를 사용할수 있고,
최종 결과는 AB 인터페이스를 통해서 확인할수 있다. 
이때 B가 먼저 동작해서 B의 리턴이 A의 파라미터로 사용되고 
A의 리턴은 최종적인 AB 의 리턴과 동일하다. 

andThen() 의 동작 방식. 

(1) //(2)의 리턴 값 받음. 
AB = A.andThen(B)
AB.method(param) 

(2) //(3)의 리턴값을  파라미터 값으로
A 
(lambda ex) 

(3) //(1)의 리턴값이 파라미터로 그리고  (2)으로 리턴
B 
(lambda ex)

(1) = (2) <- (3)

다음 표는 인터페이스별로 andThen()과 compose() 지원 여부를 나타낸다. 

인터페이스 명 : andThen() : compose

Consumer<T> : O : X 
BiConsumer <T, U> : O : X 
P*Consumer : O :X 
Function<T, R> : O : O 
BiFunction<T, U, R> : O : X
BinaryOperator<T> : O : X 
P*UnaryOperator : O : O 

-Compose 계열에서의 연결 
Compose 계열은 리턴값이 존재하지 않는다. 따라서 최초의 파라미터가 
그대로 두번째 인터페이스의 파라미터가 되고 처음 인터페이스의 동작은 
두번째 인터페이스의 동작에 영향을 주지 않는다. 

ex) 
DoubleConsumer con1 = num -> System.out.println(Math.pow(num,2));
DoubleConsumer con2 = num -> System.out.println(num + num);

DoubleConsumer andThen = con1.andThen(con2);
andThen.accept(10);

위 코드의 실행 결과는 먼저 con1 의 실행결과로 100.0이 출력되고 
이어서 con2의 결과로 20.0이 출력된다. 

andThen = con1   andThen con2 : 최초 파라미터가 그대로 전달. 
accept(10)   100.0                  20.0

-Function 계열의 연결 
Function<T, R> 계열에서는 andThen()과 compose()를 모두 사용가능. 
andThen()과 compose()를 이용해 FUnction 을 연결하는 간단한 예를 보자. 

ex)
Function<String, String> func1 = name -> "Hello" + name;
Function<String, String> func2 = data -> "returned : " + data;

Function<String, String> func3 = func1.andThen(func2);
System.out.println(func3.apply("홍길동")); // returned : Hello 홍길동 

Function<String, String> func4 = func1.compose(func2);
System.out.println(func4.apply("장길산")); // Hello returned : 장길산 

func3는 func1.andThen(func2)로 구성된다. func3.apply()의 파라미터로 
공급된 "홍길동"은 처음 인터페이스인 func1의 파라미터로 사용돼서 
"Hello 홍길동"을 리턴한다. 
이 값은 다시 두번째 인터페이스인 func2의 파라미터가 되서 최종 결과물은 
"returned: Hello 홍길동"이 된다. 

func3 = func1   andThen   func2 
apply("홍길동") 의 파라미터가 func1의 파라미터로 
func1의 리턴값 Hello 홍길동은 다시 func2의 파라미터가 
되서 최종 결과물은 
"returned: Hello 홍길동"이 된다. 

func4는 func1.compose(func2)로 구성되므로 
func4.apply()의 파라미터로 공급된 "장길산"은 
먼저 func2의 파라미터로 사용돼서 " returned : 장길산"을 리턴한다. 
이값은 다시 첫번째 인터페이스인 func1의 파라미터가 돼서 
최종 리턴값은 "Hello returned : 장길산"이 된다. 

(2) and() , or(), negate(), isEqual()
Predicate 계열은 디폴트 메서드로 and(), or(), negate()를 가지고 클래스 
메서드로는 isEqual()을 갖는다. 
이들 메서드는 서로 다른 두개의 Predicate를 연결하거나 기존의 
Predicate를 이용해 새로운 Predicate를 반환한다. 

먼저, 디폴트 메서드에 대해 알아보자. 

a. and()는 두개의 Predicate를 연결하며 && 연산자와 동일하게 동작한다. 
즉, 두개의 Predicate가 모두 true 일 때 test()의 결과가 true 인 새로운 
Predicate를 리턴한다. 

b. or()는 두개의 Predicate를 연결하며 || 연산자와 동일하게 동작한다. 
즉, 두개의 Predicate 중 하나라도 true 이면 test() 결과 true인지 새로운 
Predicate를 리턴한다. 

c. negate() 기존의 Predicate에 대해 !(부정)으로 동작한다. 
즉 기존의 test() 결과가 true 이면, false , false 이면 true를 리턴하는 Predicate를
생성한다. 

ex)
package ch10.lambda.composing;

import java.util.function.IntPredicate;

public class PredicateComposeTest {

   public static void main(String[] args) {
      int [] nums = {1,2,3,4,5,6,7,8,9,10};
      IntPredicate ip1 = (num) ->{return num%2==0;};// 2의 배수인지 확인
      IntPredicate ip2 = (num) ->{return num%3==0;};// 3의 배수인지 확인

      IntPredicate ip3 = ip1.and(ip2);
      for(int num: nums) {
         if(ip3.test(num)) {
            System.out.println("2와 3의 공배수: "+num);
         }
         if(ip1.negate().test(num)){
            System.out.println("2의 배수가 아닌 수: "+num);
         }
      }
   }
}
//
2의 배수가 아닌 수: 1
2의 배수가 아닌 수: 3
2의 배수가 아닌 수: 5
2와 3의 공배수: 6
2의 배수가 아닌 수: 7
2의 배수가 아닌 수: 9

다음으로 클래스 메서드인 isEqual()에 대해 알아보자. 

isEqual()은 클래스 메서드이므로 바로 인터페이스 이름을 통해 호출하고 
메서드 파라미터로 비교될 기준 값을 넘겨주면 Predicate 객체가 리턴된다. 
이때 Predicate의 람다식은 내부적으로 java.util.Objects.equals()를 이용해서 
대상 객체와 기준 객체를 비교하도록 작성된다. 

다음은 java.util.Objects.equals() 메서드이다. 

public static boolean equals(Object a, Object b) {
return (a == b) || (a != null && a.equals(b));
}
위 코드에서 a가 Predicate의 소스가 되고 b는 test()의 파라미터가 전달된다. 

Predicate<String> strPredicate = Predicate.isEqual("Hello");
System.out.println(strPredicate.test("Hello")); // true 

(3) 
minBy(), maxBy()

minBy()와 maxBy()는 BinaryOperator에서 제공되는 클래스 메서드들이다. 
이 두메서드는 Comparator<T>를 파라미터로 받아서 각각 최소값과 최대값 
을 구하는 BinaryOperator<T>를 리턴한다. 
Comparator<T> 자체도 함수형 인터페이스이기 때문에 람다식을 이용해서 
비교 방법을 설정한다. 

BinaryOperator<String> bo = BinaryOperator.minBy((o1, o2)) -> {
return o1.compareTo(o2);
});
System.out.println(bo.apply("Hello", "Hi")); //Hello

BinaryOperator<Integer> bo2 = BinaryOperator.maxBy((i1, i2) -> {
return i1.compareTo(i2);
});
System.out.println(bo2.apply(10, 5)); //10

----------------------------------------------------
3.7 메서드 와 생성자 참조 

람다식을 이용해 프로그래밍하다 보면 다른 코드에 전달하려는 동작을 
수행하는 메서드가 이미 있는 경우가 있다. 
예) 문자열의 정렬할때 함수형 인터페이스로 Comparator 타입이 필요하고 
Comparator 의 compare()메서드에서 사용할 기능을 전달하는데 
이때 String 의 compareTo()가 사용된다. 
ex)
String[] langs = {"Phython", "C", "JAVA"};

Arrays.sort(langs, (o1,o2) -> {
return o1.compareTo(o2);
});

이처럼 단순히 기준에 사용된 코드를 재사용하는 경우 
:: 연산자 (더블콜론연산자)를 이용해 기존 메서드를 
참조할수 있다. 이 특수한 연산자를 사용하면 내부클래스를 줄이는 
람다식을 다시 더 줄일수 있다. 
람다식이 메서드 구현부를 간략하게 작성하는 방법이라면, 
:: 연산자는 이름만으로 메서드를 참조할수 있게 한다. 

:: 연산자는 메서드 이름과 클래스 이름 또는 객체 이름을 분리하며 
다음과 같은 3가지 형태로 구분할수 있다. 

- 클래스::인스턴스_메서드 
- 클래스::클래스_메서드
- 객체::인스턴스_메서드

(1) 클래스::인스턴스_메서드

클래스::인스턴스_메서드 형태는 인스턴스 메서드를 참조하는 형태로 
람다식에 하나 이상의 파라미터가 전달되는 형태를 대체한다. 
이때, 첫번째 파라미터의 클래스가 메서드의 소속이 되고 나머지 
파라미터들은 메서드 호출시 메서드의 파라미터로 전달된다. 

예를 들어 문자열의 정렬에는 String 클래스의 compareTo()가 사용된다. 
이 메서드를 이용해서 String[] 정렬하려면 다음과 같이 쓸수 있다. 

String[] langs = { "Phython", "C", "java", "JavaScript"};
Arrays.sort(langs, String ::compareTo);

즉, 람다식에 전달된 o1의 타입인 String 클래스가 가지는 compareTo()
메서드에 두번째 파라미터 o2가 전달된다. 

(2) 클래스::클래스_메서드
클래스 :: 클래스_메서드 형태는 클래스에 속한 클래스 메서드를 사용하는 기법으로 
메서드의 소속이 이미 나와 있기 때문에 람다식에 전달된 모든 파라미터가 
클래스_메서드의 파라미터로 전달된다. 

ex)
package ch10.lambda.ref;

import java.util.function.Function;

public class MethodReference2 {

   public static void main(String[] args) {
      Function<String, Integer> f0 = (str) -> {return Integer.parseInt(str);};
      System.out.println(f0.apply("100"));
      
      //최대한 축약한 람다식. 파라미터가 하나이므로 ()가 생략되고 구현부가 
      //return 한 문장이므로 {} 와 return 키워드는 생략될수 있다. 
      
      Function<String, Integer> f1 = str -> Integer.parseInt(str);
      System.out.println(f1.apply("200"));

      // ::연산자를 이용해 메서드를 직접 참조함으로써 가장 간단한 형태로 작성되었다. 
      // 이때 전달되는 파라미터인 "300" 은 Integer.parseInt() 의 파라미터로 전달된다. 
      
      Function<String, Integer> f2 = Integer::parseInt;
      System.out.println(f2.apply("300"));
   }
}
//
100
200
300

(3) 
객체 :: 인스턴스_메서드의 형태 
객체::  인스턴스_메서드의 형태는 주어진 객체의 메서드가 호출되면
람다식에 전달된 파라미터는 메서드에 그대로 전달된다. 

ex)
package ch10.lambda.ref;

import java.util.function.Consumer;
import java.util.function.Function;

public class MethodReference3 {

   public static void main(String[] args) {
      String base = "Lambda";
      Function<String, Boolean> f = (str) -> base.equals(str);
      System.out.println(f.apply("Lambda"));

      //메서드 참조형식으로 변경해서 구현이 간단해졌다. 
      //apply를 통해서 전달된 파라미터는 base.equals()의 파라미터로 전달된다. 
      
      Function<String, Boolean> f2 = base::equals;
      System.out.println(f2.apply("Lambda"));

      // Consumer<T>에서 메서드 참조를 사용한 예로 System.out 객체가 
      // 가진 println 메서드를 참조해서 "Lambda"를 출력한다. 
      
      Consumer<String> c = System.out::println;
      c.accept("Lambda");
   }
}
//
true
true
Lambda

(4)
클래스:: new 
마지막 참조 형태는 생성자 참조이다. 
클래스::new 형태의 코드는 클래스 타입의 새로운 객체를 생성한다. 
호출되는 생성자는 전달되는 파라미터의 타입과 개수에 근거해서 
결정된다. 
만약 매칭되는 생성자가 없을 경우는 당연히 컴파일 에러가 발생한다. 

클래스::new 를 통한 생성자 참조는 배열을 만들때도 사용할수 있다. 
이때 넘기는 파라미터는 배열의 길이를 의미한다. 

ex)
IntFunction<String []> function = String[]::new;
String [] strs1 = function.apply(10); // length = 10;
String [] strs2 = function.apply(5); // length = 5;

다음 예제는 생성자 참조를 이용해서 다양한 형태의 StringBuffer의 
생성자를 호출하는 방식을 보여준다. 

ex)
package ch10.lambda.ref;

import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.IntFunction;
import java.util.function.Supplier;

public class ConstructorReference {

   public static void main(String[] args) {
   
   // StringBuffer를 파라미터로 받아서 capacity()와 length()를 출력하도록 
   // Consumer<T>를 작성한다. 
   
      Consumer<StringBuffer> cons = (src) ->{
         System.out.println(src.capacity()+" : "+src.length());
      };

        //Supplier<T> 를 이용해서 기본적인 StringBuffer를 생성한다. 
      //이때 넘기는 파라미터가 없으므로 StringBuffer() 기본 생성자가 호출. 
      
      Supplier<StringBuffer> s1 = StringBuffer::new;
      StringBuffer sb1 = s1.get();  //파라미터 없음
      cons.accept(sb1);
      
      //Function<T,R>을 이용해서 String을 파라미터로 받는 StringBuffer(String src)
      //생성자를 호출한다. 
      
      Function<String, StringBuffer> f1 = StringBuffer::new;
      StringBuffer sb2 = f1.apply("Hello"); //문자열 파라미터 1개
      cons.accept(sb2);
      
      //IntFunction<R>을 이용해서 int 를 파라미터로 받는 StringBuffer(int capacity)
      //생성자를 호출한다. 
      
      IntFunction<StringBuffer> f2 = StringBuffer::new;
      StringBuffer sb3 = f2.apply(10); // 숫자형 파라미터 1개
      cons.accept(sb3);
   }
}
//
16 : 0
21 : 5
10 : 0

===================================
[자바 해바라기 정리] 11 java.lang 패키지

1. Object 클래스 

이제까지 자바의 객체지향적인 특성을 이해했다면 본격적인
프로그래밍이 가능하다. 추가로 효율적인 자바 프로그래밍을 하기 
위해서는 자바가 제공해주는 다양한 API(Application Programming Interface
:미리 만들어진 클래스들의 모임)를 잘 사용하는 것이 매우 중요하다. 
예) 배열의 크기가 고정적이라는 답답함을 개선하기 위해 스스로 
크기를 늘릴수 있는 자료 구조를 반복문과 제어문을 이용해 밤새 
작성했는데 다음날 다른 사람은 java.util에 있는 ArrayList 라는 
클래스를 이용해 단 한줄에 동일한 목적을 달성했다면 누가 좋은 
프로그래머 일까?

java.lang 패키지는 이름대로 자바 언어에서 가장 기본적이며 자주 
사용되는 클래스들의 모임이다. 따라서 별도로 import 하지 않아도 바로 사용할수 
있다. 이번 장에서는 java.lang 패키지의 대표적인 클래스들에 대해 알아보자. 

1. Object 클래스 
Object 클래스는 앞서 살펴봤듯이 가장 최상위 클래스로 모든 클래스의 
조상 클래스이다. 
따라서, Object 의 멤버는 모든 클래스의 멤버가 된다. 
Object 클래스에는 toString(), equals(), hashCode(), getClass() 등 다양한 메서드들이 
선언되어 있다. 

Object : toString(), equals(), hashCode(), getClass()...
System, Exception , Math , Person
Exception - RuntimeException 
Person <---SpiderMan---toString()

앞서 toString()의 경우에서 살펴봤듯이 Object에 있는 메서드들은 기본에는 
충실하지만, 자식 입장에서는 만족스러운 기능을 하지 못하기 때문에 
많은 경우 오버라이딩이 필요하다. 
하지만, 그렇다고 해서 Object에서 toString()을 제외하면 println()과 
같은 메서드를 통해 객체를 출력하기가 매우 힘들어 질것이다. 

ex) 
System.out.println(new Person()); // Object의 toString 사용 
System.out.println(new SpdierMan()); // SpdierMan의 toString 사용. 

다음은 Object 클래스에 선언된 메서드.

메서드 명 : 선언부와 설명 

getClass() : public final native Class<?> getClass()
현재 객체의 실제 Class 객체를 리턴한다. 

hashCode() : public native int hashCode()
현재 객체의 해시 코드 값을 리턴한다. 

equals(): public String toString()
객체의 문자열로 변환 후 리턴한다. 

clone() : protected native Object clone() throws CloneNotSupportedException
현재 객체를 복제해서 동일한 내용의 새로운 객체를 리턴한다. 

finalize() : protected void finalize() throws Throwable
객체가 G.C(Garbage Collection)되기 직전에 호출되는 메서드로 
자바 9에서 @Deprecated 선언됨.

Object 메서드에는 native 키워드가 사용된 메서드들이 다수 존재한다. 
대표적인 Object의 메서드들에 대해서 알아보자. 
native란 자바가 아닌 다른 언어(C, C++등)로 작성된 기능을 자바에서 
사용할 때 이용하는 키워드이다. 


----------------------------------------------------
1.1 equals() 메서드

equals 메서드는 이름대로 비교 대상인 두개의 객체가 같은지 등가비교 
(==을 이용)해서 같으면 true, 다르면 false를 리턴한다. 

ex)
public boolean equals(Object obj) {
return (this == obj);
}

객체들은 참조변수에 할당되기 때문에 여기서 같다는 말은 참조하는 값이 
같은지, 즉 같은 객체인지를 확인한다. 
다음 obj1 과 obj2 에 각각 새로 생성한 객체의 참조를 할당하고 
obj3에는 obj2의 참조 값을 할당한 후 equals 와 '=='을 이용해서 비교한 결과.

ex2)
Object obj1 = new Object();
Object obj2 = new Object();
Object obj3 = obj2;
System.out.printf("obj1 == obj2 : %b%n", obj1 == obj2); // false
System.out.printf("obj1 equals obj2 : %b%n", obj1.equals(obj2)); // false
System.out.printf("obj2 == obj3 : %b%n", obj2 == obj3); // true
System.out.printf("obj2 equals obj3 : %b%n", obj2.equals(obj3); // true

결과를 보면 '=='과 equals 메서드의 결과가 같음알수 있다. 
Object 의 equals 메서드가 '=='으로 구현되어 참조값 자체를 비교하기 때문에 
당연한 결과이다. 

ex)
obj1 -> 0x100
obj2 -> 0x200 
obj3 -> 0x200 

그런데 이결과가 정말 우리가 필요한 결과일까? 만약 "Hello" 라는 내용을 
가지는 두개의 String 객체가 있을때 우리는 두 객체를 같다고 할것인가?
다르다고 할것인가? 이 세상의 모든 핸드폰은 고유의 전화번호를 갖는다.
만약, 두 HandPhone 객체가 있는데 번호가 같다면 우리는 이 두 
HandPhone 을 같다고 할것인가? 다르다고 할것인가? 

물론, 두 객체의 주소값을 비교해서 같은 객체인지를 파악할수도 있겠지만, 
실생활에서 '같다'라는 표현은 주소값보다는 내용을 기준으로 하는 경우가 많다. 
따라서 이런 경우도 Object 가 물려준 equals 를 그대로 쓰기보다는 내용을 
비교하도록 오버라이딩 해서 사용할 필요가있다. 
String과 같은 API는 미리 equals 메서드를 내용을 비교하도록 
오버라이딩 해놓았다. 
주소값을 비교하고 싶을 경우는 '==' 을사용하고,
내용을 비교하고 싶을 때는 equals를 사용한다. 

ex)
package ch11.object;

class Phone {
	String number = "전화번호";

	public Phone(String number) {
		this.number = number;
	}

	@Override
	public boolean equals(Object obj) {
		if (obj != null && obj instanceof Phone) {
			Phone casted = (Phone) obj;
			return number.equals(casted.number);
		}
		return false;
	}
}

public class EqualsTest {
	private static void testString() {
		String s1 = new String("Hello");
		String s2 = new String("Hello");
		System.out.println("String: "+(s1 == s2) + " : " + s1.equals(s2));
	}

	private static void testPhone() {
		Phone p1 = new Phone("0100000000");
		Phone p2 = new Phone("0100000000");
		System.out.println("Phone: "+(p1 == p2) + " : " + p1.equals(p2));
	}
	//둘은 다른 객체, '==' 결과 false ,
	// equals()가 주석 처리되면 ,Phone이 가지는 equals()는 Object의 것이다. 
	//따라서 내용을 비교하지 않고 단순히 '=='의 결과와 동일한다. 
	// 주석을 해제하고 다시 실행하면 내용을 비교하게 된다. 

	public static void main(String[] args) {
		testString();
		testPhone();
	}
}
//
주석 해제 전 오버라이딩 
String: false : true
Phone: false : false

주석 해제후 오버라이딩
String: false : true
Phone: false : true


----------------------------------------------------
1.2 hashCode() 메서드

객체의 해시코드(hash code) 란 시스템에서 객체를 구별하기 위해 사용되는 
정수값으로 프로그램 내에서 객체마다 유일한 값이기 때문에 그냥 주소값이라고 
이해해도 괜찮다. 
이값은 Object의 hashCode() 메서드를 통해 리턴 받을수 있다. 
이 메서드는 native로 선언되어 있기 때문에 구현을 알아볼수는 없다. 

ex)
public native int hashCode();

이 hashCode()는 뒤에서 HashSet이나 HashMap 등에서 객체를 구별하기 위한 
일종의 키값으로 사용한다. java.util 패키지에 있는 HashSet은 데이터를 저장하는 
자료구조의 하나인데 동일한 데이터는 중복해서 저장하지 않는 특성이 있다. 
중요한 것은 동일한 데이터를 판단하는 기준이다. 

Object 클래스에는 다음 내용이 있다. 

-애플리케이션 실행 중에 같은 객체의 hashCode()를 여러번 호출할때 
equals()에서 사용하는 값들이 변경되지 않으면 언제나 동일한 값이 반환되어야 한다. 

- equals() 메서드가 같다고 판단한 두 객체의 hashCode() 값은 언제나 같아야 한다. 

- equals() 메서드가 다르다고 판단한 두 객체의 hashCode()는 항상 같을 필요는 없지만 
다른 값이 나올때 해시 테이블의 속도가 향상된다. 

즉 equals() 메서드를 사용해 두 개의 객체가 내용을 기준으로 같은지 비교하도록 
오버라이딩 해봤는데 이것으로는 부족하고 추가로 hashCode() 메서드도 오버라이딩 
해야한다는 것이다. String이나 Number와 같은 클래스들은 이미 
equals() 와 hashCode()를 오버라이딩 하고 있기 때문에 
Set 계열의 자료 구조에 저장하면 하나의 객체만 관리된다. 

ex)  
              add
String s1 = new String("Hello") -> Set 
String s2 = new String("Hello") -> Set 
-> {s1} 하나만 관리 
Set --  s1.equals(s2) && s1.hashCode() == s2.hashCode()

객체마다 유일한 hashCode()를 리턴하도록 메서드를 오버라이딩하는 것은 
쉽지 않다. 
일반적으로 멤버변수들이 가진 hashCode()를 조합해서 사용하면 쉽게 
오버라이딩이 가능하다. 

ex)
package ch11.object;

import java.util.HashSet;
import java.util.Set;

class Product {
	String sn;

	public Product(String sn) {
		this.sn = sn;
	}

	@Override
	public boolean equals(Object obj) {
		if (obj != null && obj instanceof Product) {
			Product casted = (Product) obj;
			return sn.equals(casted.sn);
		}
		return false;
	}

	@Override
	public String toString() {
		return "Product [sn=" + sn + "]";
	}
	
	@Override
	public int hashCode() {
		return sn.hashCode();
	}
}
//String 타입의 sn 을 멤버 변수로 가지는 Product 클래스를 정의한다. 
equals()메서드와 toString() 메서드가 구현되어 있으며 
hashCode()는 주석 처리되어 있다. hashCode() 함수는 간단하게 
sn의 hashCode()를 그대로 재사용한다. 
equals()에서 비교 조건에 사용되는 멤버가 단지 sn이기 때문이다. 


public class HashCodeTest {
	public static void testString() {
		Set<String> set = new HashSet<>();
		set.add(new String("Hello"));
		set.add(new String("Hello"));
		System.out.printf("set의 내용: %s%n", set);
	}
	// HashSet 타입의 객체를 만들고 두개의 String 객체를 추가한다. 
	//출력 결과는 언제나 Hello 하나의 문자열만 출력된다. 
	// 나머지 하나는 중복 데이터로 간주하기 때문이다. 
	
	public static void testProduct() {
		Set<Product> set = new HashSet<>();
		set.add(new Product("98765432109876543210"));
		set.add(new Product("98765432109876543210"));
		System.out.printf("set의 내용: %s%n", set);
	}
	// HashSet에 Product 타입의 객체 두개를 추가한다. 
	// 이 두객체는 같은 sn을 갖기 때문에 equals() 메서드의 결과는 true를 리턴한다. 
	//하지만 주석된 상태에서 실행해보면 두개의 Product가 추가된다. 
	// 주석해제후 실행하면 하나의 Product 정보만을 확인 할수 있다. 
	
	public static void main(String[] args) {
		testString();
		testProduct();
	}
}
// 
주석 해제 전 
set의 내용: [Hello]
set의 내용: [Product [sn=98765432109876543210], Product [sn=98765432109876543210]]


주석 해제 후
set의 내용: [Hello]
set의 내용: [Product [sn=98765432109876543210]]

이처럼 hashCode() 와 equals()는 언제나 상호 보완적으로 동작해야 한다. 
약간 귀찮을수 있는 이 두메서드의 오버라이딩은 
eclipse의 기능을 사용하면 아주 손쉽게 처리할수 있다. 

이클립스의 편집창에서 마우스 오른쪽 버튼을 클릭하여 표시되는 단축메뉴에서 
source-> generated hashCode() and equals() 메뉴를 클릭하면 
두 메서드를 자동으로 오버라이딩 해서 생성. 

----------------------------------------------------
1.3 clone() 메서드 

clone() 은 자신을 복제해서 새로운 객체를 생성하는 메서드이다. 
배열 같은 객체를 clone() 하게 되면 기존 객체를 그대로 둔 체 동일한 
구성의 객체를 하나 더 만들기 때문에 원본을 훼손하지 않고 다양한 
테스트를 진행할 수 있다. 

ex)
int [] intArr1 = {1, 2, 3, 4, 5};
int [] cloned = intArr1.clone();
for(int i : cloned) {
System.out.printf("%d\t", i); // 1 2 3 4 5 
}

clone() 메서드를 사용하기 위해서는 두가지 사실을 염두에 두어야 한다. 

먼저, Object에 있는 clone() 메서드는 protected 접근 제한자를 사용하기 때문에 
오버라이딩 하지 않고는 외부에서 호출할수는 없다. 
외부호출을 위해서는 clone()을 오버라이딩 하면서 public 으로 접근 제한자를 변경한다. 

ex)
protected native Object clone() throws CloneNotSupportedException;

둘째 clone()을 하기 위해서는 대상 객체가 Cloneable 인터페이스를 
구현하고 있어야 한다. 그렇지 않으면 
ClassNotSupportedException 이 던져진다. 
Cloneable은 별다른 메서드가 선언되어 있지 않기 때문에 단순히 
implements만해도 충분하다. 
이런 인터페이스를 마커 인터페이스라고 한다. 

ex)
package ch11.object;

import java.util.Arrays;

class Person implements Cloneable {
	String name;
	int age;
	int[] score;

	public Person(String name, int age, int[] score) {
		this.name = name;
		this.age = age;
		this.score = score;
	}

	@Override
	public String toString() {
		return "[name=" + name + ", age=" + age + ", score=" + Arrays.toString(score) + "]"+System.identityHashCode(name);
	}

	// String 과 int, int[] 멤버변수로 갖는 Person을 작성.
	// 이 클래스는 Clonable 인터페이스를 implements 하고 있음을 눈여겨보자. 
	//Person은 toString()과 clone()  메서드를 오버라이딩 하고 있다. 
	//Arrays 가 가진 toString() 메서드를 이용하면 배열을 문자열로 변환해서 
	//쉽게 내용을 출력가능. 
		
	@Override
	public Object clone() throws CloneNotSupportedException {
		Person cloned =  (Person)super.clone();
		cloned.score = this.score.clone();
		cloned.name = new String(this.name);
		return cloned;
	}
}

public class CustomCloneTest {
	public static void main(String[] args) throws CloneNotSupportedException {
		Person original = new Person("홍길동", 20, new int[] { 100, 90 });
		System.out.printf("원본: %s%n", original);
		Object cloned = original.clone();
		System.out.printf("복제품: %s%n", cloned);
		original.score[0] = 80;
		System.out.printf("복제품: %s%n", cloned);
		System.out.println(System.identityHashCode(original) + " : " + System.identityHashCode(cloned));
// Person 타입의 객체 original 을 생성 후 clone()메서드로 복제한다. 
//복제한 객체를 출력하면 최초 만들었던 original과 같은 내용으로 출력된다. 
// 두 객체의 해시코드를 출력해보면 다름을 알수있다. 
//참고로 Object의 hashCode()는 오버라이딩으로 변경이 가능하지만, 
//System의 identityHashCode()는 언제나 객체 고유의 해시 코드를 반환한다. 

		}
}

//
원본: [name=홍길동, age=20, score=[100, 90]]457233904
복제품: [name=홍길동, age=20, score=[100, 90]]245672235
복제품: [name=홍길동, age=20, score=[100, 90]]245672235
1012570586 : 1207140081

복제가 이뤄질때는 객체의 내용을 복사하는데 여기에는 얕은 복사(shallow copy)
와 깊은 복사(deep copy)가 있다. 얕은 복사는 단순히 객체가 가지는 기본형의 
값과 객체의 참조값만을 복사해서 복제본을 만든다. 
기본적으로 clone에서 사용하는 복사방식은 얕은 복사다. 
반면, 깊은 복사는 객체가 참조하는 객체의 내용까지 복사하는 것이다. 

ex2) 수정. 
package ch11.object;

import java.util.Arrays;

class Person implements Cloneable {
	String name;
	int age;
	int[] score;

	public Person(String name, int age, int[] score) {
		this.name = name;
		this.age = age;
		this.score = score;
	}

	@Override
	public String toString() {
		return "[name=" + name + ", age=" + age + ", score=" + Arrays.toString(score) + "]"+System.identityHashCode(name);
	}

	@Override
	public Object clone() throws CloneNotSupportedException {
return super.clone();
		//		Person cloned =  (Person)super.clone();
//		cloned.score = this.score.clone();
//		cloned.name = new String(this.name);
//		return cloned;
	}
}

public class CustomCloneTest {
	public static void main(String[] args) throws CloneNotSupportedException {
		Person original = new Person("홍길동", 20, new int[] { 100, 90 });
		System.out.printf("원본: %s%n", original);
		Object cloned = original.clone();
		System.out.printf("복제품1: %s%n", cloned);
		original.score[0] = 80;
		System.out.printf("복제품2: %s%n", cloned);
		System.out.println(System.identityHashCode(original) + " : " + System.identityHashCode(cloned));
	}
}
//
원본: [name=홍길동, age=20, score=[100, 90]]457233904
복제품1: [name=홍길동, age=20, score=[100, 90]]457233904
복제품2: [name=홍길동, age=20, score=[80, 90]]457233904
245672235 : 1012570586

달라진 내용은 원본인 original의 첫번째 score 항목을 80으로 변경하고 
다시 복제품을 출력하도록 33,34 행이 추가 되었다. 
그런데 결과로 출력된 복제품의 score의 첫 번째 항목이 80으로 
변경되었다. 바로 얕은 복사의 결과로 단순히 원본 객체에 대한 
레퍼런스 값만을 복사했기 때문이다. 

깊은 복사를 하려면 직접 객체의 내용을 복사해줘야 한다. 
위 예제의 clone 메서드를 깉은 복사를 이용하도록 오버라이딩 .

@Override
	public Object clone() throws CloneNotSupportedException {
		Person cloned =  (Person)super.clone();
		cloned.score = this.score.clone();
		cloned.name = new String(this.name);
	return cloned;
	}
실행 결과 
원본: [name=홍길동, age=20, score=[100, 90]]457233904
복제품1: [name=홍길동, age=20, score=[100, 90]]245672235
복제품2: [name=홍길동, age=20, score=[100, 90]]245672235
1012570586 : 1207140081

이제 출력 결과를 보면 원본의 score 를 변경하더라도 복제품의 
score 값이 변경되지 않았다. 

1.4 getClass() 메서드 
자바 애플리케이션이 실행될 때 JVM은 클래스 로더(class loader)
라는 것을 이용해서 '.class' 파일을 메모리에 읽어 들인 후 
'Class 타입의 객체'로 관리한다. 이 객체는 '.class' 별로 하나씩 
존재하는 메모리상의 원판이 된다. 
이후 new 키워드를 이용해서 객체를 만들 때 이 Class를 이용한다. 

ex) 
A.java ->(compile)-> A.class -> (class loader) -> 
(메모리공간) -> A Class   ,  A  a  = new A();

getClass() 메서드는 객체의 원판 Class에 대한 정보를 얻기 위한 메서드이다. 
Class를 통해서는 리플렉션(reflection) API를 사용할 수 있다. 
리플렉션 API는 일반 객체를 통해서 원본 객체의 정보를 획득하고, 
추가로 필요한 정보를 조회하는 과정을 지원하는 API이다. 
리플렉션 API는 자동화 툴이나 프레임워크의 내부를 작성할 때 주로 
사용되는데 자세한 내용은 자바 튜토리얼 문서 를 활용하고,
이 책에서는 자세한 설명은 생략. 

Class 타입 객체를 얻을때는 getClass() 메서드뿐만 아니라 Class 의 
static 속성인 class 를 이용할수도 있다. 

ex)
Class gctClass = gct.getClass();
Class gctClass2 = GetClassTest.class;

ex2)
package ch11.object;

public class GetClassTest {

	public void sayHello() {
		System.out.println("Hello");
	}
	
	public static void main(String[] args) throws Exception{
		GetClassTest gct = new GetClassTest();
		Class gctClass = gct.getClass();
		//getClass() 메서드를 이용해 gct의 원본 Class에 대한 객체를 얻는다. 
	
		System.out.println("이름: "+ gctClass.getName());
		System.out.println("메서드 개수: "+gctClass.getDeclaredMethods().length);
		
		Class gctClass2 = GetClassTest.class;
		gctClass.getDeclaredMethod("sayHello").invoke(gct);
		// Class가 제공하는 다양한 메서드를 이용해서 원본의 정보를 획득한다. 
		// getName()은 클래스 이름을 패키지 명을 포함해서 리턴. 
		//getDeclaredMethods()는 클래스에 선언된 모든 메서드의 정보를 
		//Method[] 타입으로 반환한다.
		// getDeclaredMethod()를 통해서 특정 이름의 메서드르 얻을수 있으며
		// Methhod가 제공하는 invoke 메서드를 이용해 호출할수 있다. 
	}
}

//
이름: ch11.object.GetClassTest
메서드 개수: 2
Hello

----------------------------------------------------
2. System 클래스 

System 클래스는 JVM이 실행되고 있는 운영체제(OS)와 소통을 
위한 클래스로 다양한 정적(static) 메서드를 제공한다. 

System 클래스의 주요 속성 

속성 명 : 선언부와 설명 
err : public static final PrintStream err 
에러를 출력하기 위한 표준출력 스트림 객체이다. 

in : public static final InputStream in
입력을 위한 표준 입력 스트림 

out : public static final PrintStream out 
출력을 위한 표준 출력 스트림 

System 클래스의 주요 메서드

arraycopy() : public static native void arraycopy(Object src, int srcPos,
Object dest, int desPos, int length)
src 배열의 srcPos부터 length 만큼을 dest 배열의 destPos 에 복사한다. 

currentTimeMillis() : public static native long currentTimeMillis()
시스템의 현재 시간을 ms 단위로 리턴한다. 

exit() : public static void exit(int status)
status 상태로 애플리케이션을 종료시킨다.

gc() : public static void gc()
G.C 의 동작을 요청한다. 

getenv() : public static java.util.Map<String,String> getenv()
:환경변수의 목록을 Map 타입으로 리턴한다.

public static String getenv(String name)
name에 해당하는 환경변수 값을 String으로 리턴한다. 

getProperties() : public static Properties getProperties()
시스템 속성을 Properties 타입으로 리턴한다. 

getProperty() : public static String getProperty(String key)
key 에 해당하는 시스템 속성의 값을 문자열로 리턴한다. 
만약 해당 값이 없으면 null을 리턴한다. 

public static String getProperty(String key, String def)
key에 해당하는 시스템 속성의 값을 문자열로 리턴한다. 
만약 해당 값이 없으면 def를 리턴한다. 

identityHashCode() : public static native int identityHashCode(Object x)
x 고유의 해시 코드 값을 리턴한다. 

lineSeparator() : public static String lineSeparator()
시스템 종속적인 행 구분자를 리턴한다. 유닉스 계열은 \n을,
윈도우 계열은 \r\n을 리턴한다. 

nanoTime() : public static native long nanoTime()
현재 시스템 시간을 나노초(1/10^9 초) 단위로 리턴한다.

setProperties() : public static void setProperties(Properties props)
props 로 시스템 속성을 설정한다.

setProperty() : public static String setProperty(String key, String value)
key에 해당하는 시스템 속성을 value로 설정한다. 

System 클래스의 API는 대략 5가지 부류로 구분할수 있다. 

----------------------------------------------------
2.1 시스템 I-O 사용 

System 클래스에서 제공되는 in 과 out 속성은 각각 
java.io.InputStream과 java.io.PrintStream 타입이다. 
InputStream은 키보드에서 사용자가 입력한 값을 받아들인다.
하지만, 직접 InputStream을 제어하기는 번거롭기 때문에
앞서 학습한 Scanner 를 이용하는 것이 일반적이다.
물론 Scanner를 생성할때 InputStream을 파라미터로 사용한다. 
PrintStream은 출력하고자 하는 내용을 콘솔을 통해 출력한다. 
출력을 위한 스트림으로 out 과 함께 err도 제공되는데 
err 는 주로 에러를 출력할때 사용되며 이클립스 콘솔에서 
빨간색으로 표시된다.

ex)
package ch11.system;

import java.util.Scanner;

public class BasicIO {

	public static void main(String[] args) {
		try (Scanner scanner = new Scanner(System.in)) {
			String str = scanner.nextLine();
			System.out.println("일반 출력: " + str);
			System.err.println("오류 출력: " + str);
		}
	}
}
// System.in 을 이용해서 Scanner를 생성한다. 
//Scanner 를 사용하고 close()를 호출하지 않으면 리소스 릭 
//(resource leak : 자원을 반납하지 않고 계속 점유해서 지속적으로 
//사용하다 보면 나중에 부족 현상이 발생함)이 발생한다. 
//try ~ with resource 문은 Closeable 인터페이스가 적용된 리소스에 
대해 사용 후 자동으로 close를 호출한다. 

//
서준아 안녕
오류 출력: 서준아 안녕  //빨간색으로 표시 
일반 출력: 서준아 안녕 // 하얀색으로 표시 

대부분 콘솔을 통한 출력을 제외하고는 System의 in 과 out
등을 직접 다루지 않고 다양한 I/O의 클래스들을 이용하는데 
이 부분은 후에 학습한다. 

----------------------------------------------------
2.2 프로그래밍의 종료와 G.C 권고 

System의 exit() 메서드는 JVM을 강제로 종료시키는 메서드이다.
이 메서드는 파라미터로 종료 상태를 나타내는 int 값을 받는데 관습적으로 
정상으로 종료할때는 0, 나머지 경우에 다른 정수를 사용한다. 

gc()는 시스템에게 G.C를 요청하는 메서드이다. 하지만 
이 메서드가 호출된다고 해서 쭉 G.C가 일어난다는 보장은 없다. 
사실 G.C는 JVM이 시스템 상황에 맞춰 자동으로 이뤄지기 때문에 
대부분 경우 프로그램에서 직접 호출할 일은 없다.
하지만 폭발적으로 가비지가 생기는 경우 등에서 명시적으로 호출을 
요청함으로써 빠른 메모리 회복을 유도할수 있다. 

ex)

package ch11.system;

import java.util.Scanner;

class Dummy {
	public Dummy() {
		System.out.println("dummy 객체 생성됨");
	}
	@Override
	protected void finalize() throws Throwable {
		System.out.println("dummy 객체 소멸됨");
	}
}

public class ProcessManageTest {
	public static void main(String[] args) {
		try (Scanner scanner = new Scanner(System.in)) {
			while (true) {
				System.out.println("명령을 입력하세요: C, G, X");
				String readLine = scanner.nextLine();
				if(readLine.equals("C")) {
					new Dummy();
				}else if(readLine.equals("G")) {
					System.gc();
				}else if(readLine.equals("X")) {
					System.exit(0);
				}
			}
		}
	}
}

//
명령을 입력하세요: C, G, X
C
dummy 객체 생성됨
명령을 입력하세요: C, G, X
G
명령을 입력하세요: C, G, X
dummy 객체 소멸됨
X


----------------------------------------------------
2.3 현재의 시각 정보 획득 

종종 작성한 애플리케이션의 성능을 체크하기 위해 소요시간을 
계산할 필요가 있다. System이 제공하는 currentTimeMillis()는 
현재 시각을 밀리세컨드(1/1000초) 단위의 long 값으로 리턴한다. 
nanoTime()는 현재 시각을 나노세컨드(1/10^9초) 단위의 long 값
으로 리턴한다. 

ex)

package ch11.system;

public class SystemClockTest {
	public static void main(String[] args) {
		long start = System.nanoTime();
		int num = 20;
		long result = getFactorial(num);
		System.out.println(num+"!은 "+result+"입니다.");
		long end = System.nanoTime();
		System.out.println("총 소요 시간(nanosec): "+(end - start));
	}
	public static long getFactorial(long num) {
		if(num==1) {
			return num;
		}else {
			return num * getFactorial(num-1);
		}
	}
}
//
20!은 2432902008176640000입니다.
총 소요 시간(nanosec): 436600

----------------------------------------------------
2.4 시스템 속성 및 환경변수 참조 

시스템 속성(System Property)은 JVM이 시작할때 OS로 부터 얻어오는 값이다.
여기에는 OS 종류, JDK 설치경로, 사용자 계정, 사용자 임시 디렉터리 경로 
등의 정보가 들어있다. 
이 시스템 속성이 중요한 이유는 OS의 종류를 가리지 않는 플랫폼 독립적인 
프로그램을 작성하기 위해서이다.
예) 임시 경로에 파일을 저장하도록 프로그램을 작성한다고 했을때 ,
경로명 "C:\Users\andy\AppData\Local\Temp\" 를 하드코딩(소스코드에
그대로 적음)하면 리눅스 시스템에서는 오동작할 것이다. 
리눅스에서는 '/tmp' 가 기본값으로 사용되는 임시경로이다. 
이런 값을 System 속성을 통해서 가져온다면(java.io.tmpdir)
OS가 바뀌더라도 OS가 제공해주는 값을 사용할수 있다.

자주 사용되는 시스템 속성은 다음과 같다. 

속성 명(키) : 설명 : 값예시 (windows 10 기준)
user.country : OS 로케일 정보 : KR 

java.io.tmpdir : 임시경로 : c:\Users\사용자_명AppData\Local\Temp\

line.separator : 행 분리 구분자 : \n\r 

user.home : 사용자 홈 경로 : c:\Users\사용자_명 

file.separator : 파일 경로 구분자 : \

System이 제공하는 getProperties() 메서드는 모든 시스템 속성들을
키-값의 쌍으로 데이터를 저장하는 java.util.Properties 형태로 
반환한다. 또는 getProperty() 메서드에 속성 이름 즉 키를 넘겨주면 
해당하는 값을 반환한다. 

환경변수는 OS에 설치된 프로그램들에게 제공할 목적으로 설정하는 값이다.
Windows 의 경우 [제어판]-[시스템]-[고급 시스템 설정]-[환경변수]-[시스템변수]
에서 확인/추가/수정/삭제 할수있다.

환경변수를 사용하는 방법은 시스템 속성을 사용하는 방법과 아주 유사하다.
일단 getenv() 메서드는 java.util.Map 타입을 반환한다. 
Map 은 Property와 유사하게 키-값 형태의 쌍으로 데이터를 저장한다.
또한 getenv()에 파라미터로 키를 전달하면 연결된 값을 반환한다. 

ex)
package ch11.system;

import java.util.Map;
import java.util.Properties;
import java.util.Set;

public class PropertyTest {

	public static void main(String[] args) {
		Properties props = System.getProperties();
		Set<Object> keys = props.keySet();
		for(Object key: keys) {
			System.out.printf("key: %s, value: %s%n", key, props.get(key));
		}
		String ls = System.getProperty("java.io.tmpdir");
		System.out.println("사용자 임시 디렉토리 경로: "+ls);
		
		Map<String, String> envs = System.getenv();
		Set<String> envKeys = envs.keySet();
		for(String key: envKeys) {
			System.out.printf("key: %s, value: %s%n", key, envs.get(key));
		}
		String userName = System.getenv("USERNAME");
		System.out.println("사용자 명: "+userName);
	}
}
//
key: sun.desktop, value: windows
key: awt.toolkit, value: sun.awt.windows.WToolkit
key: java.specification.version, value: 11
key: sun.cpu.isalist, value: amd64
key: sun.jnu.encoding, value: MS949
key: java.class.path, value: C:\Users\pc\git\java-kame\target\classes
key: java.vm.vendor, value: Oracle Corporation
key: sun.arch.data.model, value: 64
key: user.variant, value: 
key: java.vendor.url, value: http://java.oracle.com/
key: user.timezone, value: 
key: os.name, value: Windows 10
key: java.vm.specification.version, value: 11
key: sun.java.launcher, value: SUN_STANDARD
key: user.country, value: KR
key: sun.boot.library.path, value: C:\Program Files\Java\jdk-11.0.2\bin
key: sun.java.command, value: ch11.system.PropertyTest
key: jdk.debug, value: release
key: sun.cpu.endian, value: little
key: user.home, value: C:\Users\pc
key: user.language, value: ko
key: java.specification.vendor, value: Oracle Corporation
key: java.version.date, value: 2019-01-15
key: java.home, value: C:\Program Files\Java\jdk-11.0.2
key: file.separator, value: \
key: java.vm.compressedOopsMode, value: Zero based
key: line.separator, value: 

key: java.specification.name, value: Java Platform API Specification
key: java.vm.specification.vendor, value: Oracle Corporation
key: java.awt.graphicsenv, value: sun.awt.Win32GraphicsEnvironment
key: user.script, value: 
key: sun.management.compiler, value: HotSpot 64-Bit Tiered Compilers
key: java.runtime.version, value: 11.0.2+9-LTS
key: user.name, value: pc
key: path.separator, value: ;
key: os.version, value: 10.0
key: java.runtime.name, value: Java(TM) SE Runtime Environment
key: file.encoding, value: UTF-8
key: java.vm.name, value: Java HotSpot(TM) 64-Bit Server VM
key: java.vendor.version, value: 18.9
key: java.vendor.url.bug, value: http://bugreport.java.com/bugreport/
key: java.io.tmpdir, value: C:\Users\pc\AppData\Local\Temp\
key: java.version, value: 11.0.2
key: user.dir, value: C:\Users\pc\git\java-kame
key: os.arch, value: amd64
key: java.vm.specification.name, value: Java Virtual Machine Specification
key: java.awt.printerjob, value: sun.awt.windows.WPrinterJob
key: sun.os.patch.level, value: 
key: java.library.path, value: C:\Program Files\Java\jdk-11.0.2\bin;C:\WINDOWS\Sun\Java\bin;C:\WINDOWS\system32;C:\WINDOWS;C:/Program Files/Java/jre1.8.0_60/bin/server;C:/Program Files/Java/jre1.8.0_60/bin;C:/Program Files/Java/jre1.8.0_60/lib/amd64;C:\Program Files (x86)\NetSarang\Xshell 6\;C:\Program Files\Java\jdk-11.0.2\bin;C:\ProgramData\Oracle\Java\javapath;C:\NewGen\Rebirth\Dll;C:\Program Files (x86)\Intel\iCLS Client\;C:\Program Files\Intel\iCLS Client\;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;C:\WINDOWS\System32\WindowsPowerShell\v1.0\;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\IPT;C:\Program Files\Intel\Intel(R) Management Engine Components\IPT;C:\WINDOWS\System32\OpenSSH\;C:\Program Files\PuTTY\;C:\Program Files\TortoiseGit\bin;C:\Program Files\Git\cmd;C:\Users\pc\AppData\Local\Microsoft\WindowsApps;C:\Program Files\Bandizip\;C:\Users\pc\Desktop;;.
key: java.vendor, value: Oracle Corporation
key: java.vm.info, value: mixed mode
key: java.vm.version, value: 11.0.2+9-LTS
key: sun.io.unicode.encoding, value: UnicodeLittle
key: java.class.version, value: 55.0
사용자 임시 디렉토리 경로: C:\Users\pc\AppData\Local\Temp\
key: configsetroot, value: C:\WINDOWS\ConfigSetRoot
key: USERDOMAIN_ROAMINGPROFILE, value: DESKTOP-DTHLEPU
key: LOCALAPPDATA, value: C:\Users\pc\AppData\Local
key: PROCESSOR_LEVEL, value: 6
key: USERDOMAIN, value: DESKTOP-DTHLEPU
key: FPS_BROWSER_APP_PROFILE_String, value: Internet Explorer
key: LOGONSERVER, value: \\DESKTOP-DTHLEPU
key: JAVA_HOME, value: C:\Program Files\Java\jdk-11.0.2
key: SESSIONNAME, value: Console
key: ALLUSERSPROFILE, value: C:\ProgramData
key: PROCESSOR_ARCHITECTURE, value: AMD64
key: PSModulePath, value: C:\Program Files\WindowsPowerShell\Modules;C:\WINDOWS\system32\WindowsPowerShell\v1.0\Modules;C:\Program Files\Intel\
key: SystemDrive, value: C:
key: OneDrive, value: C:\Users\pc\OneDrive
key: APPDATA, value: C:\Users\pc\AppData\Roaming
key: USERNAME, value: pc
key: ProgramFiles(x86), value: C:\Program Files (x86)
key: VBOX_MSI_INSTALL_PATH, value: C:\Program Files\Oracle\VirtualBox\
key: CommonProgramFiles, value: C:\Program Files\Common Files
key: Path, value: C:/Program Files/Java/jre1.8.0_60/bin/server;C:/Program Files/Java/jre1.8.0_60/bin;C:/Program Files/Java/jre1.8.0_60/lib/amd64;C:\Program Files (x86)\NetSarang\Xshell 6\;C:\Program Files\Java\jdk-11.0.2\bin;C:\ProgramData\Oracle\Java\javapath;C:\NewGen\Rebirth\Dll;C:\Program Files (x86)\Intel\iCLS Client\;C:\Program Files\Intel\iCLS Client\;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;C:\WINDOWS\System32\WindowsPowerShell\v1.0\;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\IPT;C:\Program Files\Intel\Intel(R) Management Engine Components\IPT;C:\WINDOWS\System32\OpenSSH\;C:\Program Files\PuTTY\;C:\Program Files\TortoiseGit\bin;C:\Program Files\Git\cmd;C:\Users\pc\AppData\Local\Microsoft\WindowsApps;C:\Program Files\Bandizip\;C:\Users\pc\Desktop;
key: FPS_BROWSER_USER_PROFILE_String, value: Default
key: PATHEXT, value: .COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC
key: DriverData, value: C:\Windows\System32\Drivers\DriverData
key: OS, value: Windows_NT
key: COMPUTERNAME, value: DESKTOP-DTHLEPU
key: CATALINA_HOME, value: C:\apache-tomcat-8.0.48
key: PROCESSOR_REVISION, value: 9e09
key: CLASSPATH, value: C:\Program Files\Java\jdk-11.0.2\lib;.;
key: CommonProgramW6432, value: C:\Program Files\Common Files
key: ComSpec, value: C:\WINDOWS\system32\cmd.exe
key: ProgramData, value: C:\ProgramData
key: ProgramW6432, value: C:\Program Files
key: HOMEPATH, value: \Users\pc
key: SystemRoot, value: C:\WINDOWS
key: TEMP, value: C:\Users\pc\AppData\Local\Temp
key: HOMEDRIVE, value: C:
key: PROCESSOR_IDENTIFIER, value: Intel64 Family 6 Model 158 Stepping 9, GenuineIntel
key: USERPROFILE, value: C:\Users\pc
key: TMP, value: C:\Users\pc\AppData\Local\Temp
key: CommonProgramFiles(x86), value: C:\Program Files (x86)\Common Files
key: ProgramFiles, value: C:\Program Files
key: PUBLIC, value: C:\Users\Public
key: NUMBER_OF_PROCESSORS, value: 4
key: windir, value: C:\WINDOWS
key: =::, value: ::\
사용자 명: pc


----------------------------------------------------
3. String 클래스 

3.1 String 클래스의 특징과 객체 생성 

String 클래스는 아마도 프로그램을 작성하면서 가장 많이 사용되는 
클래스일 것이다. 그만큼 정확한 사용법을 숙지하는 것이 중요하다.

다음은 String이 갖는 기본적인 특징.

(1) String은 final 클래스이다. 따라서 상속을 받아서 수정할수 없다. 
(2) String은 내부적으로 char[] 배열을 만들어 데이터를 저장한다. 
우리가 직접 배열을 만들고 사용하기는 번거롭기 때문에 
String이라는 클래스를 만들어서 편하게 쓸수 있게 해주었다. 
(3) String은 생성자를 사용하지 않고 바로 ""로 둘러싼 문자열을 
할당할 수 있다. 

String 타입의 객체를 만들때 new 키워드를 이용할수도 있고 단순히 
문자열을 할당할수도 있다. 두가지 방법은 메모리 차원에서 상당히 
큰 차이가 있다. 
new 를 이용했을때는 글자 그대로 힙(heap) 공간에 새로운 문자열을 
만든다. 하지만, new 를 사용하지 않았을 때는 상수 저장공간에
(Constant Pool)에 저장한다.

상수 저장공간에 문자열을 만들때는 먼저 상수 저장공간에 같은 
내용의 문자열이 있는지 확인하여, 같은 문자열이 있다면 
해당 문자열을 반환하고 , 같은 문자열이 없다면 새로 만든다. 
따라서 특수한 목적이 아니라면 가급적 new 키워드 없이 만드는 것이
메모리 절약에 유리하다. 

ex)
package ch11.String;

public class NewStringTest {
	public static void main(String[] args) {
	    String s1 = "Hello";
	    String s2 = "Hello";
	    System.out.println("== 연산 결과 : "+(s1==s2?"==같음":"다름"));
	    System.out.println("equals 연산 결과 : "+(s1.equals(s2)?"같음":"다름"));

		//new 키워드를 사용하지 않고 두개의 문자열을 사용한다. String 클래스는 
		//문자열의 내용을 비교하도록 equals() 메서드가 오버라이딩 되어 있기때문에 
		//equals()는 물론 참조값을 비교하는 == 연산의 결과까지 true로 판단된다. 
		
	    String s3 = new String("Hello");
	    String s4 = new String("Hello");
	    System.out.println("== 연산 결과 : "+(s3==s4?"==같음":"다름"));
	    System.out.println("equals 연산 결과 : "+(s3.equals(s4)?"같음":"다름"));
		// new 키워드를 사용해서 두개의 문자열을 생성한다. equals()는 true를 
		// 반환하지만 , == 연산의 결과는 false이다. 새로운 객체이기 때문이다.
	}
}
//
== 연산 결과 : ==같음
equals 연산 결과 : 같음
== 연산 결과 : 다름
equals 연산 결과 : 같음

String의 또하나 중요한 특징은 불변성(Immutable) 클래스이다.
이 말은 일단 생성 후 변경이 불가능하다는 이야기다. 우리는 이제까지 
문자열을 출력할 때 '+' 연산자를 이용해서 문자열을 결합해왔다. 
다음 문장 

ex)
String a = "Hello" + "Java" + "World!";

결과로 a에 할당된 문자열은 "HelloJavaWorld!"이다. 하지만,
이 과정에서 최초에 "Hello"라는 문자열이 있었고 여기에 
"Java"가 더해지는 것이 아니라 " Hello"와 "Java" 는 그대로 있고 
"HelloJava"가 새로 생성된다. 
물론 여기에 "World"가 더해지는 과정도 마찬가지다.
결과적으로 메모리에 생성된 문자열은 "Hello","Java","HelloJava",
"World", "HelloJavaWorld!"로 5개이다. 
무심코 연결한 문자열이 메모리를 심각하게 낭비할수 있다는 점을 주의하자.
맨 마지막에 사용되는 문자열 "HelloJavaWorld!" 이외의 나머지 4개는 
G.C의 대상이다. 

ex)
0x100 : Hello , 0x200 : Java 
0x300 : HelloJava
0x400 : World
0x500 : HelloJavaWorld
a --> 0x500 

ex2)
 package ch11.String;

public class ImmutableClass {

	public static void main(String[] args) {
		String a = "a";
		System.out.println(System.identityHashCode(a));
		a = a + "b";
		System.out.println(System.identityHashCode(a));
		System.out.println(a);
	}
}
// 출력값은 실행시 마다 달라짐 
125130493
914504136
ab

따라서 문자열의 결합 연산에는 가급적 String 보다는 뒤에 
언급할 StringBuffer 나 StringBuilder 를 활용하는 것이 좋다. 

----------------------------------------------------
3.2 주요 메서드

String 클래스에는 검색, 분리, 추출, 변환, 비교 등 다양한 메서드를 
가지고 있다. 그중 자주 사용되는 메서드를 알아보자. 
String의 메서드 들은 인덱스(index)를 자주 사용한다. 
앞서 String은 char[]로 데이터를 저장한다고 했는데 바로 그 배열에서의 
인덱스이다.
따라서 인덱스의 범위는 0부터 문자열의 길이 -1 까지만 사용할수 있다.

String 클래스의 주요 메서드

메서드 명 : 선언부 와 설명 

length() : public int length()
주어진 문자열의 길이를 리턴한다.

charAt() : public char charAt(int index)
index에 해당하는 문자를 리턴한다.

indexOf() : public int indexOf(int ch)
문자열 내에서 ch의 index를 리턴한다. 없을 경우는 -1을 리턴한다.

equals() : public boolean equals(Object abObject)
abObject와 문자열의 내용을 비교해서 결과를 리턴한다.

equalsIgnoreCase() : public boolean equalsIgnoreCase(String anotherString)
대소문자의 구별 없이 anotherString과 문자열의 내용이 같은지 리턴한다. 

replace() : public String replace(char oldChar, char newChar)
문자열에서 oldChar를 찾아서 newChar로 변경된 새로운 문자열을 리턴한다.

subString() : public String subString(int beginindex, int endindex)
문자열의 beginindex에서 endindex 앞까지 잘라서 리턴한다

split() : public String[] split(String regex)
문자열을 주어진 정규표현식으로 나눈 후 배열에 담아서 리턴한다

(1) 문자열의 길이 
length()는 문자열의 길이를 리턴한다. 이 길이는 내부적으로 문자열을 
저장하는 char[]의 length이다. 

ex)
String str = "Hello";
System.out.println(str.length());

(2) 특정 인덱스의 문자 또는 특정 문자의 위치 조회 
charAt(int index)은 특정 위치 즉 index에 있는 문자를 리턴한다.
이때 index 의 범위는 ' 0 <= index <= 문자열의 길이 -1' 이다. 
이 범위를 벗어나는 경우 IndexOutOfBoundsException이 발생한다.

indexOf(char ch)는 특정 문자가 처음 등장하는 위치를 반환하는데 
만약 String에 원하는 문자가 포함되지 않은 경우는 -1을 리턴한다. 

주민등록번호에서 남성과 여성을 파악하거나 이메일 주소에서 
'@'와 '.'의 위치를 파악해서 형식에 맞는지 확인해보자.

ex)
package ch11.String;

public class UseIndex {
	public static void main(String[] args) {
		String ssn = "000518-3111111";
		char gender = ssn.charAt(7);	// -다음의 문자 추출
		if(gender=='1' || gender=='3') {
			System.out.println("남성입니다.");
		}else if(gender=='2' || gender=='4') {
			System.out.println("여성입니다.");
		}else {
			System.out.println("주민등록번호의 형식이 잘못되었습니다.");
		}
		
		String email = "abc@gmail,com";
		if(email.indexOf('@')<0 || email.indexOf('.')<0){
			System.out.println("잘못된 이메일 형식입니다.");
		}
	}
}
//
남성입니다.
잘못된 이메일 형식입니다.

(3)문자열의 내용 비교 
String은 문자열의 내용을 비교하도록 equals()를 오버라이딩해 놓았다.
추가로 equalsIgnoreCase() 대소문자의 구분 없이 내용이 같은지를 비교한다. 

ex)
package ch11.String;

public class EqualsTest {
	public static void main(String[] args) {
		String str = "Hello";
		System.out.println("hello".equals(str));
		System.out.println("hello".equalsIgnoreCase(str));
		
		String nullStr = null;
		//System.out.println(nullStr.equals("some")); // NullPointerException 발생 가능
		System.out.println("some".equals(nullStr)); // NullPointerException 발생 없음
	}
}
//
false
true
false

위 소스 코드를 보면 "hello".equals()와 같은 형식의 코드가 약간 
낯설다. String 클래스의 메서드를 사용할 때 자주 사용되는 패턴으로 
NullPointerException 을 미리 예방할수있는 작은 패턴이다.

ex)
System.out.println(nullStr.equals("some")); // NullPointerException 발생 가능
System.out.println("some".equals(nullStr)); // NullPointerException 발생 없음

(4)문자열 대체와 추출 
replace()는 기존 문자열에서 특정 문자열을 찾아 원하는 문자열로 대체해서 
리턴한다. String은 불변성을 가지고 있으므로 변경된 문자열은 기존 문자열과는
다른 새로운 문자열일 것이다. subString()은 인덱스를 이용해 문자열의 
특정 부분을 잘라내서 리턴한다.

전화번호의 맨 뒤의 4자리를 '*'로 대체해서 출력해보자. 

ex)
package ch11.String;

public class MaskingTest {
	public static void main(String[] args) {
		String hp = "010-1234-5678";
		String last4 = hp.subString(9, hp.length());
		System.out.println("추출된 문자열: "+last4);
		String masked = hp.replace(last4, "****");
		System.out.println(masked);
	}
}
//
추출된 문자열: 5678
010-1234-****

(5)문자열 앞뒤의 공백 제거
사용자로부터 입력받은 문자열을 비교하다 보면 우연히 추가된 공백 
때문에 다른 문자로 파악되는 경우가 종종 있다. 
이때 trim() 메서드를 사용하면 문자열 앞, 뒤의 공백을 제거해준다.
이때 제거되는 공백은 단순히 스페이스 바에 의한 공백뿐만 아니라 탭 문자 
(\t)나 줄 바꿈 문자(\n)를 포함한다. 

ex)

package ch11.String;

public class TrimTest {
	public static void main(String[] args) {
		String helloWithWhiteSpace="\tHello \n";
		System.out.println("Hello".equals(helloWithWhiteSpace));
		System.out.println("Hello".equals(helloWithWhiteSpace.trim()));
	}
}
//
false
true

(6)정규표현식의 활용 
정규표현식(regular expression)이란 특정한 규칙을 갖는 문자열의 집합을 
표현하는데 사용되는 형식 언어이다. 예를들어 이메일이나 전화번호가 형식에 
맞는지, 비밀번호의 복잡도는 원하는 수준인지 등을 파악할때 정규표현식이 
사용된다. 정규표현식에 대한 내용은 12장에서 다룬다. 

정규표현식을 사용하는 대표적인 메서드들은  split()이나 matches()가 있다. 
두함수 모두 정규표현식을 파라미터로 받는다. 
split()이나 matches()가 있다. 두함수 모두 정규표현식을 파라미터로 받는다.
split()는 정규표현식에 해당하는 문자들을 구분자로 해서 원본 문자열을 쪼개고 
배열로 리턴한다. matches()는 원본 문자열이 정규표현식에 부합하는지를 
리턴한다.

ex)
package ch11.String;

public class RegexpTest {

	public static void main(String[] args) {
		String str =  "Hello Java World";
		String [] splitResult = str.split("[a ]");
		
		//split()에 사용된 정규표현식 [a ]는 a 또는 공백을 의미한다. 
		// 따라서 이 split()은 원본인 str에서 a 또는 공백을 만나면 
		// 그 자리에서 문자열을 쪼개서 배열의 원소로 만든후 배열을 
		// 리턴한다. 
		
		for(int i=0; i<splitResult.length; i++) {
			System.out.println(i+" : "+splitResult[i]);
		}
		String nameRule = "[a-zA-Z가-힣]{2,5}";
		// 알파벳 대/소문자와 한글을 포함해서 2~5글자가 있어야 한다는 의미.
		
		System.out.println("Hello Java".matches(nameRule));
		//공백 있어서 탈락
		
		System.out.println("홍길동".matches(nameRule));
		System.out.println("홍길동2".matches(nameRule));
		// 숫자가 들어가서 탈락
	}
}
//
0 : Hello
1 : J
2 : v
3 : 
4 : World
false
true
false


----------------------------------------------------
4. StringBuffer 와 StringBuilder 클래스 

4.1 특징과 객체 생성 

String 클래스는 불변성 클래스이기 때문에 생성하고 읽고 
사용하는 용도로 문자열을 이용한 연산에는 제약이 많다. 
문자열을 이용한 연산에 적합한 클래스는 StringBuffer 나 
StringBuffer가 있다. 

이 두 클래스의 특성은 다음과 같다. 

(1)String 과는 상속 관계가 없다.
(2)내부적으로 버퍼(buffer : 데이터를 임시로 저장하는 공간으로 배열)에 
문자열을 저장하고 그 안에서 추가/수정/삭제 작업을 가능하게 한다. 
(3)연산 과정에서 새로운 객체를 생성하지 않는다. 
(4) toString() 메서드는 내용 문자열을 출력하도록 오버라이딩 되었다. 
(5) equals() 메서드는 오버라이딩되지 않아서 Object의 equals를 
그대로 사용한다. 

두가지 클래스의 사용법은 거의 유사하며 차이점은 StringBuffer는 
멀티스레드에서 안전하므로 무겁고, StringBuilder는 반대다. 
멀티스레드 관련된 내용은 14장에서 다룬다. 
예제에서는 StringBuilder를 이용해보자. 

StringBuilder는 다양한 생성자를 갖는데 생성되는 기본 버퍼의 
크기를 설정하는 방식이 각각 다르다. 

StringBuilder의 생성자 목록 

생성자 명 : 선언부와 설명 

StringBuilder()

(1)public StringBuilder()
capacity 가 16인 용량의 버퍼를 가진 StringBuilder를 생성한다. 

(2)public StringBuilder(int capacity)
capacity 만큼 용량의 버퍼를 가진 StringBuilder를 생성한다. 

(3)public StringBuilder(String str)
초기에 str을 포함한 StringBuilder를 생성한다.
이 객체는 str.length() + 16만큼 크기를 갖는 버퍼를 내장한다. 

(4)public StringBuilder(CharSequence seq)
초기에 seq을 포함한 StringBuilder를 생성한다. 
이 객체는 seq.length() + 16 만큼 크기를 갖는 버퍼를 내장한다. 

버퍼는 배열이기 때문에 한번 크기가 정해지면 더 많은 데이터를 
저장하기 위해서는 새로운 배열을 만들고 기존 값을 복사한 후 
사용해야 한다. StringBuffer나 StringBuilder는 내부적으로
System.arraycopy() 메서드를 사용한다. 
버퍼의 크기를 너무 작게 가져가면 데이터가 늘어날때 자주 
arraycopy() 를 수행해야 하므로 프로세스가 바빠진다.
반면, 버퍼를 미리 너무 크게 가져가면 사용하지 않는 메모리 
공간이 그만큼 늘어난다.

ex)
public StringBuilder() {
super(16);
}
public StringBuilder(int capacity) {
super(capacity);
}
public StringBuilder(String str) {
super(str.length() + 16);
append(str);
}

위의 예에서 기본생성자를 통해서 만드는 버퍼의 크기는 16이다.
또는 2번째 생성자처럼 초기 버퍼의 크기를 capacity를 통해 
지정할수 있다. 3번째 생성자는 문자열을 넘겨주면 문자열의 
길이 + 16만큼의 크기로 버퍼를 잡는다. 이후 처리할 문자열의 
길이가 버퍼의 길이를 넘어갈 때 마다 ( 기존 크기 * 2 + 1)의 
크기로 새로운 버퍼를 만들고 
System.arraycopy()로 기존 값을 복제해서 사용한다.
따라서 문자열의 길이를 예상할수 있다면 2번째 생성자처럼 
크기를 미리 지정하고 사용하는 것이 좋다. 

ex)
package ch11.Stringbuilder;

public class StringBuilderTest {

	public static void main(String[] args) {
		StringBuilder builder = new StringBuilder("Hello");
		//문자열 "Hello"를 이용해 StringBuilder를 생성한다.
		// '문자열 길이'+ 16의 크기만큼의 버퍼를 가지는 
		// StringBuilder가 생성된다. 
		
		System.out.println("buffer 크기: "+builder.capacity());
		// capacity는 버퍼의 크기를 리턴한다. 6행의 결과로 21이 출력.
		
		System.out.println("문자열 길이: "+builder.length());
		// length 는 순수한 문자열의 길이를 리턴한다.
	}
}
//
buffer 크기: 21
문자열 길이: 5


----------------------------------------------------
4.2 문자열 편집을 위한 주요 메서드

StringBuilder 또는 StringBuffer에는 문자열을 편집할수 있는 다양한 메서드를 
제공한다. 

StringBuilder의 주요 메서드 

메서드 명 : 선언부와설명

indexOf() : public int indexOf(String str)
StringBuilder의 버퍼에서 str의 시작 인덱스를 반환한다.

append() : public StringBuilder append(P# param)
현재 버퍼의 맨 뒤에 param을 추가한 후 리턴한다. 

delete() : public StringBuffer delete(int start , int end)
버퍼에서 start에서 end 사이의 인덱스에 있는 값을 삭제 후 리턴한다. 

deleteCharAt() : public StringBuilder deleteCharAt(int index)
버퍼에서 index에 있는 문자를 삭제 후 리턴한다. 

insert() : public StringBuilder insert(int offset, P# param)
버퍼의 offset 위치에 param을 추가한후 리턴한다.

replace() : public StringBuilder replace(int start , int end, String str)
버퍼의 start <= x < end 사이의 값을 str로 변경한 후 리턴한다. 

toString() : public String toString()
버퍼의 내용을 문자열로 리턴한다. 

참고 
P# : Object, String, StringBuffer, CharSequence, Char[], boolean
, char, int, long, float, double 이 올수 있다. 

ex) 
StringBuilder alphabet = new StringBuilder("A");
alphabet.append("B");
alphabet.append("C");

alphabet.append("D").append("E");

"B" , "C" 를 추가하는 코드보다는 "D" , "E"를 추가하는 코드가 
훨씬 편리하다. 이런식으로 메서드의 리턴 타입이 자기 자신을 리턴하고,
계속 연결해서 다음 메서드를 호출하는 형태의 프로그래밍 방식을 
빌더 패턴(Builder Pattern)이라고 한다. 

다음은 지하철 노선을 작성하는 과정이다. 
최종 결과물은 '사봉-용산-사가정-용마산'이다. 
어떤 과정을 거쳐 값을 수정하는지 살펴보자. 

ex)

package ch11.Stringbuilder;

public class StringBuiderMethodTest {
	public static void main(String[] args) {
		StringBuilder builder = new StringBuilder("사봉-용산-사가정-용마산");
		builder.append("-중곡");	// 맨 뒤에 -중곡 추가
		System.out.println(builder);
		builder.insert(3, "면목-");	// 사봉-뒤에 면목-추가
		System.out.println(builder);
		builder.delete(5, 8);		// -용산 삭제
		System.out.println(builder);
		builder.replace(0, 1, "상");// 사를 상으로 변경
		System.out.println(builder);	
	}
}
//
사봉-용산-사가정-용마산-중곡
사봉-면목-용산-사가정-용마산-중곡
사봉-면목-사가정-용마산-중곡
상봉-면목-사가정-용마산-중곡


----------------------------------------------------
5. Math 클래스

5.1 특징 

Math 클래스는 수학 계산에 필요한 메서드를 가지는 클래스로 
String 클래스와 마찬가지로 final 클래스이다. 
따라서 상속을 받거나 메서드를 오버라이딩 할수없다.
또한, 클래스의 모든 멤버가 static으로 선언되어 있으므로
사용을 위해 별도로 객체를 만들 필요가 없다.

----------------------------------------------------
5.2 주요 메서드

Math에는 우리가 이제까지 배웠던 대부분의 수학 공식들이 
포함되어 있다. 

메서드명 : 선언부와 설명 
abs() : public static double abs(p# a)
숫자형 타입 a에 대해 절대값을 리턴한다.

ceil() : public static double ceil(double a)
a 의 올림 값을 double로 리턴한다

floor() : public static double floor(double a)
a 의 올림 값을 double로 리턴한다

max() : public static float max(p# a, p# b)
a와 b 중 큰 값을 리턴한다

min() : public static int min(p# a, p# b)
a와 b 중 작은 값을 리턴한다

random() : public static double random()
0.0 <= x < 1.0 사이의 double 값을 무작위로 리턴한다.

round() : public static long round(double a)
소수점 첫째 자리에서 반올림한 정수값을 리턴한다.

addExact() : public static int addExact(int x, int y)
x와 y의 정확한 합을 리턴한다. 만약 오버플로가 발생할 경우
ArithmeticException이 발생한다.

subtractExact() : public static int subtractExact(int x, int y)
x와 y의 정확한 차를 리턴한다. 만약 오버플로가 발생할 경우
ArithmeticException이 발생한다.

multiplyExact() : public static int multiplyExact(int x, int y)
x와 y의 정확한 곱을 리턴한다. 만약 오버플로가 발생할 경우
ArithmeticException이 발생한다.

p# 는 int, long, float, double을 의미한다

대부분 수학 연산자의 의미는 수학 공식 그대로 이므로 
사용법은 생략.
대신 활용도가 높은 random() 과 round()는 예제를 통해 자세히 
알아보자. 

(1) random()

random() 은 0 <= x <1 인 무작위의 double 값을 반환한다.
주사위를 던져서 무작위의 수가 나오는 경우를 생각해보자.
주사위는 1~6 까지의 정수가 표시되는데 random() 함수를 이용해서 
어떻게 주사위의 숫자를 표현 할수 있을까?

방법은 간단. 숫자를 만들어가면 된다. random()에 6을 곱하면 
0 <= x <6 인 double 값이 나올 것이다. 이 숫자를 정수로 형변환 하면 
0 <= x <= 5인 정수이다. 여기에 마지막으로 1을 더하면 원하는
1 <= x <= 6인 정수가 된다. 

ex)
package ch11.math;

import java.util.Random;

class MyDice {
	public int nextNum() {
		return (int) (Math.random() * 6) + 1;
		// Math.random() 함수를 이용해 1<= x <= 6 인 정수를 생성하고 
		// 리턴한다
	}
}
public class MyDiceTest {
	public static void main(String[] args) {
		MyDice dice = new MyDice();
		System.out.println(dice.nextNum());
	}
}

class YourDice{
	public int nextNum() {
		Random random = new Random();
		return random.nextInt(6)+1;
	}
}
// 실행할 때마다 다른 값이 된다. 

3

이런 과정이 약간 번거로운데 java.util.Random 클래스를 사용하면 
훨씬 손쉽게 처리할수 있다. Random 클래스가 제공하는 nextInt(int bound)
는 0부터 bound 까지의 무작위 정수를 리턴한다.
따라서 주사위를 만든다면 nextInt(6) + 1을 사용할수 있다.

import java.util.Random;

class YourDice{
	public int nextNum() {
		Random random = new Random();
		return random.nextInt(6)+1;
	}
}

(2) round()
round()는 숫자를 반올림하는 함수이다. Math 의 round()는 
double 타입의 파라미터를 소수점 첫째 자리에서 반올림해서 정수로 
리턴한다. 즉 '소수점 둘째 자리에서 반올림하라'와 같은 
요청사항을 처리할수 없다. 원하는 자리에서 반올림 처리하기 위해서는
반올림할 자릿수가 소수점 첫째 자리가 되도록 10^n 숫자를 곱해서 
반올림한 후 다시 10^n.0 으로 나누어야한다. 

다음 예 10.45를 소수점 둘째 자리에서 반올림해서 소수점 한자리로 
결과를 만드는 과정이다. 

ex)
package ch11.math;

public class RoundTest {
	public static void main(String[] args) {
		// 소숫점 둘째 자리에서 반올림하시오.
		double source=10.45;
		double num = source * 10;
		long rounded = Math.round(num);
		System.out.println("최종: "+(rounded / 10.0));
	}
}
//
최종: 10.5

(3) 오버플로 방지를 위한 연산 
정수 연산의 문제점은 오버플로에 있고 문제는 이 상황이 오류가 
아님을 설명한 바 있다.
하지만, 드디어 자바 8부터 추가된 XXExact() 메서드들은 
오버플로가 발생할 때 ArithmeticException이 발생해서 
안전한 연산이 가능하게 되었다.

다음 예는 더하기 연산을 위해 addExact() 메서드를 
사용하는 예이다.

ex)

package ch11.math;

public class ExactCalcTest {
	public static void main(String[] args) {
		int i = Integer.MAX_VALUE;
		int i2 = i + 1;
		System.out.println(i2);
		try {
			int i3 = Math.addExact(i, 1);
			System.out.println(i3);
		} catch (ArithmeticException e) {
			System.out.println("예외 발생: " + e.getMessage());
		}
	}
}
//
-2147483648
예외 발생: integer overflow


----------------------------------------------------
6. Wrapper 클래스

6.1 특징 

Wrapper 클래스는 특정 클래스를 말하는 것이 아니라 부류를 말한다. 
Wrapper 클래스는 8종류의 기본형을 객체로 만들기 위한 클래스들을 
이야기한다. 기본형마다 그에 상응하는 Wrapper 클래스가 존재한다. 

기본형과 Wrapper 클래스

기본형 : Wrapper 클래스

byte : Byte 
char : Character
short : Short 
int : Integer
long : Long 
float : Float 
double : Double
boolean : Boolean

기본형을 Wrapper 클래스로 만드는 방법은 각각의 생성자에 기본형을 
파라미터로 전달하거나 valueOf()를 호출하면서 기본형 값을 
전달한다. 

ex)
Boolean b1 = new Boolean(true);
Boolean b2 = Boolean.valueOf(true);

Wrapper 클래스는 왜 필요할까? 중국집에서는 음식을 배달할 때 
배달통을 사용한다. 이 배달통에는 모든 타입의 음식이 들어갈 수 
있는데 조건이 있다. 통에 넣기 전에 음식을 랩(wrap)으로 감싸야 한다. 

자바에서도 모든 것을 담을 수 있는 통이 있는데 바로 Object이다. 
특히나 Object를 담을수 있는 배열을 만든다면 다양한 종류의 객체들을 
담을 수 있게 된다. 
단, 기본형은 제외다. 기본형은 Object를 상속 받지 않았기 
때문에 저장할수 없다. 이때, 기본형 데이터를 살짝 
감싸서 객체로 만들어 주는 것이 Wrapper 클래스이다. 

ex)
package ch11.wrapper;

public class WrapperTest {

	public static void main(String[] args) {
		Object [] objs = new Object[2];
		objs[0] = "Hello";
		objs[1] = new Integer(100);
		
		if(objs[1] instanceof Integer) {
			int num = ((Integer)objs[1]).intValue();
			
			// intValue() 생략하고, 앞에 소괄호 없애도 됨.
			
			System.out.println("값: "+num);
		}
	}
}
//
값: 100

(1)오토박싱(auto boxing)과 언박싱(unboxing)

위와 같은 과정으로 기본형을 참조형으로 형변환하여 데이터를 관리 
할수 있었다. 그런데 상당히 귀찮다. 
자바 5부터 이런 과정을 자동화 해주는 오토박싱과 언박싱 기능이 
추가 되었다. 오토박싱은 자동으로 박스를 만들어주는 것, 즉 자동으로
Wrapper 클래스의 객체로 변경해준다. 다음 코드를 보면 기본형 int 
타입을 바로 객체형인 Integer에 할당하고 있다. 
언박싱은 그 반대 개념으로 객체형인 Integer 를 바로 기본형처럼 
사용할 수 있다. 

ex)
int i = 10;
Integer wrapped = i; // autoboxing 
int b = i + wrapped; // unboxing
System.out.println(b);

따라서 앞서 살펴보았던 WrapperTest 예제에서도 100을 
배열에 넣을때 다음과 같이 간략하게 사용할수 있다. 

ex)
objs[1] = 100;

하지만 값을 뺄 때는 쉽사리 언박싱을 적용하기 어렵다.
왜냐하면 objs[1] 번째 항목이 Integer인지 아직 확실하지 
않기 때문에 형변환 과정이 필요하기 때문이다. 
이 부분에 대한 간소화는 뒤에 배울 제너릭을 통해서 처리 
할수 있다. 

(2) Wrapper 타입의 비교 
Wrapper 타입의 객체들은 기본형이 아니다. 따라서 객체들이 
갖는 내부 값들을 비교하기 위해 ==이나 !=와 같은 연산자를 사용 
할수 없다. 이들은 순수하게 참조값만을 비교한다. 
다행히 Wrapper 클래스는 내부 값들을 비교하기 위해 equals 메서드를 
오버라이딩하고 있다. 하지만, 한가지 또 주의할점이 있는데 
참조형과 기본형을 직접 비교할때는 언박싱으로 인해 기본형의 
값을 가지고 비교하게 된다. 

ex)
package ch11.wrapper;

public class EqualsTest {

	public static void main(String[] args) {
		Integer iObj1 = new Integer(1000);
		Integer iObj2 = new Integer(1000);
		System.out.println(iObj1==iObj2);
		System.out.println(iObj1.equals(iObj2));
		System.out.println(iObj1==1000);
	}
}
//
false
true
true


----------------------------------------------------
6.2 기본형의 다양한 형변환

Wrapper 클래스의 기본 목적이 기본형과 참조형 간의 
형변환인데 그것만큼이나 많이 사용되는 것이 
문자열과 기본형 간의 형변환이다. 

(1)문자열에서 기본형으로 변환 메서드 
5장에서 살펴봤듯이 main() 메서드의 경우 String[] 배열만을 
파라미터로 받을수있고, 이 문자열을 다시 기본형으로 변경하기 
위해 Character 를 제외한 Wrapper 클래스들은 문자열을 
반환할수 있는 static 메서드들을 제공한다. 메서드 이름은 클래스별로
'parse + 기본형'의 형태를 갖는다. 또한, 변환할 수 없는 값이 
파라미터로 들어오면 java.lang.NumberFormatException을 발생시킨다.

ex)

String strNum = "1000.0";
try {
int i = Integer.parseInt(strNum);
System.out.println(i);
}catch (NumberFormatException e){
System.out.println("int 로 형변환할 수 없습니다.");
}

(2)문자열에서 Wrapper 타입으로 변환 

문자열을 Wrapper 타입으로 변경할 때에는 각 Wrapper 클래스들이 
제공하는 valueOf 메서드나 생성자를 이용한다. 

ex)
Integer intObj = Integer.valueOf("100");
Integer intObj2 = new Integer("100");

이 과정에서도 역시 형변환할수 없는 형태의 문자열이 파라미터로 
들어온다면 NumberFormatException 이 발생한다. 

이제까지 나왔던 형변환 방식을 정리하면 다음 그림과 같다. 

ex)
기본형 --> String : 기본형 + ""


기본형 --> Wrapper : valueOf() 또는 생성자 이용 
ex)
Boolean b1 = new Boolean(true);
Boolean b2 = Boolean.valueOf(true);

문자열 --> 기본형 : parseXX()
ex)
int i = Integer.parseInt(strNum);

문자열 --> Wrapper : valueOf() 또는 생성자 이용 
ex)
Integer intObj = Integer.valueOf("100");
Integer intObj2 = new Integer("100");

Wrapper --> 기본형 :
ex)
int b = i + wrapped; // unboxing

Wrapper --> String : toString()

===================================
[자바 해바라기 정리] 12 유용한 클래스들 

이 장에서는 프로그래밍 과정에서 java.lang 패키지의 클래스들 
다음으로 많이 사용되는 클래스들을 모아서 알아본다.
이 장에서는 java.util을 중심으로 java.time , java.text , 
java.math 등 다양한 패키지의 클래스들을 소개한다. 
java.lang 패키지에 대해 다루었던 11장과 마찬가지로 많은 파라미터와
메서드들이 소개되지만, 전체를 설명할수는 없고 자주 사용되는 것들을 
위주로 설명. 따라서 가능하다면, 프로그래밍할 때 자바에서 제공되는 
API를 참조하는 습관을 들이는 것이 좋다. 


1. Objects를 통한 Object 관리 

java.util.Objects 는 객체에 필요한 기능성 메서드들을 정적 메서드로 정의해 
놓은 클래스이다. 

Objects의 static 메서드들 

메서드명 : 선언부와 설명 

equals() : public static boolean equals(Object a, Object b)
두 객체 a 와 b의 동등성을 검사하는 점은 Object 의 equals와 동일하지만
두 객체가 모두 null 인 경우도 비교가 가능하며 이때 return 값은 true이다. 

deepEquals() : public static boolean deepEquals(Object a , Object b)
역시 두 객체 a와 b의 동등성을 검사하는데 만약 배열인 경우 Arrays. 
deepEquals0를 이용해 배열의 내용까지 비교한다. 

toString() : public static String toString(Object o)
o 가 null 이 아닌 경우는 o의 toString()을 이용해 객체를 출력한다. 
단, null인 경우는 "null" 을 출력한다.

public static String toString(Object o, String nullDefault)
o 가 null 이 아닌 경우는 o의 toString()을 이용해 객체를 출력한다. 
단 null 인 경우는 nullDefault를 리턴한다. 

compare() : public static <T> int compare (T a , T b , Comparator < ? super T> c)
Comparator를 이용해서 a와 b를 비교한다. 

requireNonNull() : public static <T> requireNonNull( T obj)
obj가 null 이면 NullPointerException이 발생한다. null이 아니면 
객체를 리턴한다. 

public static <T> T requireNonNull(T obj, String message)
obj가 null 이면 NullPointerException이 발생한다. 이 때 예외객체의 
메시지로 message가 사용된다. obj가 null이 아닌 경우 obj가 리턴된다. 

public static <T> T requireNonNull(T obj, Supplier<String> messageSupplier)
obj가 null이면 NullPointerException 이 발생하는데 이때 예외 객체의 
메시지는 messageSupplier를 통해 공급받는다. obj가 null이 아닌 경우 obj가
그대로 리턴된다. 

isNull() : public static boolean isNull(Object obj)
obj가 null 이면 true, 아니면 false를 리턴한다.

nonNull() : public static boolean nonNull(Object obj)
isNull과 반대로 obj가 null 이면 false, 아니면 true 를 리턴한다. 


1.1 equals() 와 deepEquals()

equals() 와 deepEquals()는 Object에 있는 equals()를 제삼자의 
입장에서 볼수 있게 한다. Object의 equals()는 자신이 null인 경우는 
NullPointerException이 발생하므로 사용할수 없다. 

하지만, Objects 의 equals()는 null 여부와 관계없이 두 객체를 비교한다. 
심지어는 비교하는 두 객체 모두 null인 경우에도 비교가 가능하고 
이때 결과는 true 이다. 

deepEquals() 는 특히 배열의 동등성을 확인할때 아주 유용한데 비교하는 
두 요소가 모두 배열이면 배열이 가지는 요소들을 모두 비교해서 결과를 
반환한다.

ex)
package ch12.objects;

import java.util.Objects;

public class EqualsTest {

	public static void main(String[] args) {
		System.out.println(Objects.equals("Hello", "Hi"));
		System.out.println(Objects.equals(null, null));

		int [] ints1 = {1,2};
		int [] ints2 = {1,2};
		System.out.println(Objects.equals(ints1, ints2));
		System.out.println(Objects.deepEquals(ints1, ints2));
	}
}
//
false
true
false
true


----------------------------------------------------
1.2 toString()

Objects의 toString()은 객체가 null 이 아닌 경우는 객체의 toString()
의 결과를 리턴한다. 하지만, null이면 NullPointerException 대신 
"null"이 출력되고 필요하다면 nullDefault를 리턴할수도 있다. 

ex)
Object obj1 = null;
//System.out.println(obj1.toString());--NullPointerException
System.out.println(Objects.toString(obj1)); // null
System.out.println(Objects.toString(obj1, "널")); // 널 


----------------------------------------------------
1.3 compare()

compare()는 두 객체를 Comparator에 의거해 비교한다. 결과는 주로 
정렬 등에 사용될수 있다. Comparator는 compare 메서드 하나를 
가지는 인터페이스이다. compare()의 리턴타입은 정수로 a가 b보다 
작으면 음수(-1) , 같으면 0, 크면 양수(+1)를 리턴하도록 구현한다. 

ex)
package ch12.objects;

import java.util.Comparator;
import java.util.Objects;

class StringLengthComparator implements Comparator<String>{
	@Override
	public int compare(String o1, String o2) {
		int o1Length = o1.length();
		int o2Length = o2.length();
		if(o1Length> o2Length) {
			return 1;
		}else if(o1Length==o2Length) {
			return 0;
		}else {
			return -1;
		}
	}
}

public class CompareTest {

	public static void main(String[] args) {
		String a = "Hello";
		String b = "Java";
		int compResult = Objects.compare(a, b, new StringLengthComparator());
		if(compResult>0) {
			System.out.println("a가 더 길다.");
		}else if(compResult==0) {
			System.out.println("a와 b의 길이는 같다.");
		}else {
			System.out.println("b가 더 길다.");
		}
	}
}
//
a가 더 길다.


----------------------------------------------------
1.4 null 처리 

객체가 null 인 상황은 잠재적으로 NullPointerException을 발생시킬수 
있기 때문에 의심스러운 경우 잘 체크해야 한다. 일반적으로 obj == null 과 
같이 체크하지만 Objects 에는 다양한 메서드로 관련 처리를 도와준다. 

- requireNonNull() 계열의 메서드는 표현대로 non null이 필요하다.
따라서 그렇지 않으면, 즉 null인 경우는 자체적으로 NullPointerException을 
발생시켜준다. 필요하다면 예외 객체에 원하는 메시지를 설정할 수도 있다. 
만약 객체가 null이 아니라면 해당 객체를 리턴한다. 

- isNull이나 nonNull() boolean 값으로 객체가 null인지 여부를 리턴한다. 

ex)
package ch12.objects;

import java.util.Objects;

public class NullCheckTest {

	public static void main(String[] args) {
		String[] strs = { "Hello", null };
		
		if (Objects.nonNull(strs[0])) {
			System.out.println(strs[0].length());
		}
		
		if (Objects.isNull(strs[1])) {
			System.out.println("strs[1]은 null 입니다.");
		}
		
		try {
			String name = Objects.requireNonNull(strs[0]);
			System.out.println(name);
		} catch (NullPointerException e) {
			System.out.println(e);
		}
		
		try {
			String name = Objects.requireNonNull(strs[1], "먼저 값을 할당하세요.");
			System.out.println(name);
		} catch (NullPointerException e) {
			System.out.println(e.getLocalizedMessage());
			
			// requireNonNull()의 파라미터로 문자열이 추가로 전달된다. 
			// 이 문자열은 예외객체의 message에 할당되므로 getLocalizedMessage()
			//를 호출하면 확인할수 있다. 
		}
		
		try {
			String name = Objects.requireNonNull(strs[1], ()->"먼저 값을 할당하세요.");
			System.out.println(name);
		} catch (NullPointerException e) {
			System.out.println(e.getLocalizedMessage());
		}
	}
}
//
5
strs[1]은 null 입니다.
Hello
먼저 값을 할당하세요.
먼저 값을 할당하세요.


----------------------------------------------------
2. 날짜 및 시간의 처리 

2.1 날짜 및 시간을 관리하는 클래스의 변천사 

날짜 및 시간 데이터는 프로그래밍에서 아주 빈번히 사용된다. 
그런데 자바에서 특히 이 값을 표현하는 대표적인 클래스가 자주 
바뀌었다. 문제는 새로운 버전으로 갈수록 합리적이지만 
이전 버전이 아직도 많이 사용된다는 점이고 우리는 모두 다 알아야한다.

(1) java.util.Date 

자바가 처음 나오면서부터 날짜 및 시간을 관리하던 클래스는 java.util.Date 
클래스이다. 그러나 Date 클래스의 대부분 생성자 및 메서드들은 더이상 
사용되지 않는 것으로 (Deprecated)으로 처리되어 있을 만큼 상황이 
좋지 않다. 하지만, 이미 작성된 많은 API가 파라미터나 리턴 타입으로 
Date를 여전히 사용하고 있는 편이다. 

다음은 Date 클래스의 주요 메서드들이다.

생성자/메서드명  :  선어부와 설명 

Date() : public Date()
현재 시각 (System.currentTimeMillis())을 이용하는 생성자이다.

public Date(long date)
date 를 이용하는 생성자이다. date는 1970/11 0:00:00 초를 
기점으로 해당 시각까지의 밀리 초( 1/1000초) 단위의 값이다. 

getTime() : public long getTime()
Date 객체의 시각을 long 값 (밀리초)으로 리턴한다. 

setTime() : public void setTi (long time)
Date 객체의 시각을 time으로 설정한다. 

toString() : public String toString()
Date 를 EEE MMM dd HH:mm:ss zzz yyyy 패턴의 문자열로 리턴한다. 

equals() : public boolean equals(Object obj)
getTime() 을 이용해 두 Date 객체의 시각이 같은지 여부를 리턴한다. 

Date  객체를 출력할때 사용되는 EEE MMM dd HH:mm:ss zzz yyyy 패턴의
의미는 SimpleDateFormat에서 다시 다룬다. 

ex)
package ch12.date;
import java.util.*;

public class DateTest {

	public static void main(String[] args) {
		Date d1 = new Date();
		System.out.println(d1);
		// 현재 시각을 이용해 Date 타입 객체 d1을 생성하고 출력.
		
		Date d2 = new Date(1500000000000L);
		//1500000000000L 을 이용해 Date 타입 객체 d2를 생성하고 출력. 
		
		System.out.println(d2);
		long gap = d1.getTime() - d2.getTime();
		System.out.printf("두 날짜의 차는 "+gap/1000/60/60/24 +"일이다.");
	}
}
//실행 시점에 따라 결과는 달라짐. 
Sun Apr 14 15:16:58 KST 2019
Fri Jul 14 11:40:00 KST 2017
두 날짜의 차는 639일이다.

(2) java.util.Calendar

Date 의 다음으로 시간 처리에 추천된 클래스에는 Calendar 클래스이다.
Calendar는 추상클래스로 직접 객체를 생성할수 없고 static 메서드인 
getInstance()를 호출해서 얻는다. 

getInstance()는 OS의 로케일(Locale)과 타임존(Timezone) 정보를 이용해서 
적절한 Calendar 객체를 생성 후 리턴한다. 이때 리턴되는 실제 구현체는 
BuddhistCalendar, JapaneseImperialCalendar, GregorianCalendar의 
세종류이다.
BuddhistCalendar는 주로 태국 지역에서 사용되는 불기를 기준으로 하는 달력.
GregorianCalendar는 우리가 주로 사용하는 서기이다. 

로케일(Locale)이란 사용자의 언어와 국가를 기반으로 사용자에 적합한 
환경을 제공하기 위한 것으로 "언어-국가" 형식으로 표시한다. 
예를들어 대한민국 로케일(ko-KR)이 적용되면 통화 기호로 원화가()
가 사용되지만, 미국 로케일(en-US)의 경우는 달러$ 가 사용된다. 
사용 가능한 Locale은 다음과 같이 찾아볼수 있다. 

ex)
Locale [] locales = Locale.getAvailableLocales();
for(Locale l: locales){
System.out.println(l.getLanguage()+"_" + l.getCountry());
}

타임존(Timezone)이란 시간대를 말하며 지구 자전에 따른 지역별 
사간 차이를 나타낸다. 흔히 멀리 해외여행을 다녀왔을 때 느끼는 시차는 
다른 타임존의 지역을 다녀왔을 때 느낄수 있는 것이다. 
사용가능한 타임존은 다음과 같이 확인할수 있다. 

ex2)
String [] tzs = TimeZone.getAvailableIDs();
for(String tz: tzs){
System.out.println(tz);
}

로케일과 타임존을 이용해서 다양한 Calendar를 사용해보자.

ex3)

package ch12.date;

import java.util.Calendar;
import java.util.Locale;
import java.util.TimeZone;

public class GetCalendarTest {

	public static void main(String[] args) {
		Calendar cal = Calendar.getInstance();
		System.out.println(cal.getClass().getName()); // java.util.GregorianCalendar
		TimeZone newYorkTZ = TimeZone.getTimeZone("America/New_York");
		Calendar calNewYork = Calendar.getInstance(newYorkTZ);
		int gap = (cal.get(Calendar.HOUR_OF_DAY) - calNewYork.get(Calendar.HOUR_OF_DAY));
		System.out.printf("서울은 뉴욕보다 %d시간 빠르다.%n", gap);

		Calendar buddhistCal = Calendar.getInstance(new Locale("th", "TH"));
		System.out.println(buddhistCal.getClass().getName()); // sun.util.BuddhistCalendar
	}
	
	public void printTimeZone() {
		String [] tzs = TimeZone.getAvailableIDs();
		for(String tz: tzs) {
			System.out.println(tz);
		}
	}
	public static void printLocale() {
		Locale [] locales = Locale.getAvailableLocales();
		for(Locale l: locales) {
			System.out.println(l.getLanguage()+"_"+l.getCountry());
		}
	}

}
//
java.util.GregorianCalendar
서울은 뉴욕보다 13시간 빠르다.
sun.util.BuddhistCalendar

Calendar에는 다양한 시간 관련 상수값과 setter 와 getter 메서드를 
이용해 시각을 설정한다. 

Calendar의 주요 상수 

상수명 : 설명 
Calendar.YEAR : 년도
Calendar.MONTH : 월
Calendar.DAY_OF_MONTH : 일
Calendar.DAY_OF_WEEK : 요일
Calendar.AM_PM : 오전/오후
Calendar.HOUR : 시
Calendar.MINUTE : 분
Calendar.SECOND : 초

다음은 Calendar 클래스의 주요 메서드이다. 

메서드명 : 선언부와 설명 

getInstance() : public static Calendar getInstance()
OS의 TimeZone, Locale에 의거해서 적절한 Calendar 객체를 
리턴한다. 

public static Calendar getInstance(
TimeZone zone, Locale aLocale)
지정된 zone 과 aLocale에 의거해서 Calendar 객체를 리턴한다. 

getTime() : public final Date getTime()
Calendar 객체를 Date 타입으로 리턴한다. 

setTime() : public final void setTime(Date date)
Date 객체를 이용해 Calendar의 시각을설정한다. 

getTimeInMillis() : public long getTimeInMillis()
Calendar 의 시각을 밀리 초로 리턴한다. 

setTimeInMillis() : public void setTimeInMillis(long millis)
밀리 초 단위인 millis 로 Calendar의 시각을 설정한다. 

get() : public int get(int field)
field에 해당하는 값을 리턴한다. field는 Calendar의 상수 값중 
하나이다. 

set() : public void set(int field, int value)
field 에 해당하는 값을 value로 설정한다. 
field는 Calendar 상수 값중 하나이다. 

public final void set( int year, int month, int date)
year, month , date 값을 이용해 Calendar의 날짜를 설정한다. 

날짜를 다루면서 한가지 주의할 사항이 있는데 대부분 컴퓨터 
프로그램에서 월은 0부터 시작한다. 
따라서 우리가 일반적으로 사용하는 달력으로 환산하려면 1을 
더해준다. 

ex)
Calendar cal = Calendar.getInstance();
cal.set(Calendar.MONTH,0); // 1월 설정 
System.out.printf("지금은 %d월이다. ", cal.get(Calendar.MONTH) +1);

주의 ,
프로그래밍에서 월은 0부터 시작하므로 0~11 까지 정의돼 있을 꺼 같지만, 
0~12 까지 사용된다. 12는 UNDECIMBER 라 부르며 
GregorianCalendar에서는 사용하지 않고, 음력 체계에서만 사용된다. 

Calendar와 Date 간의 형변환도 기억해 두어야 한다. 

ex)
Calendar cal = Calendar.getInstance();
Date fromCal = cal.getTime(); // Calendar --> Date 
cal.setTime(fromCal); // Date --> Calendar

ex2)
package ch12.date;

import java.util.Calendar;

public class CalendarTest {

	public static String getDateString(Calendar c) {
		int year = c.get(Calendar.YEAR);
		int month = c.get(Calendar.MONTH)+1;
		int date = c.get(Calendar.DATE);

		int dayOfWeek = c.get(Calendar.DAY_OF_WEEK);// 1:일요일 ~ 7:토요일
		String dayOfWeekStr = null;
		if (dayOfWeek == Calendar.SUNDAY) {
			dayOfWeekStr = "일";
		} else if (dayOfWeek == Calendar.MONDAY) {
			dayOfWeekStr = "월";
		} else if (dayOfWeek == Calendar.TUESDAY) {
			dayOfWeekStr = "화";
		} else if (dayOfWeek == Calendar.WEDNESDAY) {
			dayOfWeekStr = "수";
		} else if (dayOfWeek == Calendar.THURSDAY) {
			dayOfWeekStr = "목";
		} else if (dayOfWeek == Calendar.FRIDAY) {
			dayOfWeekStr = "금";
		} else {
			dayOfWeekStr = "토";
		}
		return String.format("%d년 %d월 %d일(%s)", year, month, date, dayOfWeekStr);
	}

	public static String getTimeString(Calendar c) {
		int hour = c.get(Calendar.HOUR);
		int minute = c.get(Calendar.MINUTE);
		int second = c.get(Calendar.SECOND);
		int amPm = c.get(Calendar.AM_PM);
		String amPmString = (amPm == Calendar.AM ? "오전" : "오후");
		return String.format("%d시 %d분 %d초(%s)", hour, minute, second, amPmString);


	}

	public static void main(String[] args) {
		Calendar cal = Calendar.getInstance();
		System.out.println("오늘은: " + getDateString(cal));
		System.out.println("지금은 " + getTimeString(cal));
		cal.set(Calendar.YEAR, 2002);
		System.out.println("오늘은: " + getDateString(cal));
	}
}
//
오늘은: 2019년 4월 14일(일)
지금은 5시 11분 38초(오후)
오늘은: 2002년 4월 14일(일)

Calendar는 add()와 roll() 메서드를 이용해서 연산할수 있다. 

표12.5 Calendar의 시간 연산 메서드 

메서드명 : 선언부와 설명 

add() : abstract public void add(int field, int amount);
Calendar, DATE 등 주어진 field 값을 amount 만틈 더하거나 뺀다. 
이때 다음 단위(Calendar, DATE 일 경우 Calendar.MONTH)도 영향을 받는다. 

roll() : abstract public void roll(int field, boolean up);
Calendar.DATE 등 주어진 field의 값을 amount 만큼 더하거나 뺀다. 단, 
다음 단위(Calendar.DATE 일 경우 Calendar.MONTH)는 영향받지 않는다. 

add()와 roll()은 모두 특정 field에 값을 더하거나 뺄수있다. 차이점은 
add는 연산결과가 다른 field에 영향을 준다. 
예를들어 시계의 태엽을 감을때 add 방식은 분침이 한퀴 돌면 시침도 
한칸 이동하는 식이다. 
하지만, roll은 계속해서 분침만 돌아간다. 

ex)

package ch12.date;

import java.util.Calendar;

public class CalendarOperTest {
	public static String printSimpleCalendar(Calendar c) {
		int month = c.get(Calendar.MONTH);
		int date = c.get(Calendar.DATE);
		return String.format("%d월 %d일", month, date);
	}
	
	public static void main(String[] args) {
		Calendar cal = Calendar.getInstance();
		cal.set(Calendar.DATE, 29);
		System.out.println("최초: "+printSimpleCalendar(cal));
		cal.add(Calendar.DATE, 20);
		System.out.println("20일 add 후: "+printSimpleCalendar(cal));
		cal.roll(Calendar.DATE, -20);
		System.out.println("-20일 roll 후: "+printSimpleCalendar(cal));
	}

}
//
최초: 3월 29일
20일 add 후: 4월 19일
-20일 roll 후: 4월 30일

(3) java.time 패키지 
Calendar 클래스는 날짜에 대한 간편한 조작이 가능하지만 사용하기 
번거롭고 기능이 많이 부족했다. 시간과 날짜가 섞여 있는 것도 어색하다. 
마치 달력에 몇시냐고 물어보는 형태이다. 여전희 월의 시작이 0인점도 
혼동을 일으키기 쉽다. 이런 번거로움 때문에 많은 개발자가 별도의 
라이브러리를 이용하기도 했다. 

자바 8에서부터는 java.time 패키지가 등장해서 날짜, 시간에 대한 모든 것을 
담당하게 되었다. 

java.time 과 주요 하위 패키지들. 

java.time : 날짜와 시간을 다루는데 필요한 클래스 정의 
ex)LocalDate, LocalTime, LocalDateTime,
ZonedDateTime, Instant Period, Duration 

java.time.chrono : ISO 이외의 비 표준 달력 시스템을 다루는 클래스 정의 
ex)HijrahDate, JapanessDate, ThaiBuddishDate ..

java.time.format : 문자로 된 날짜, 시간을 파싱해서 객체로 만들거나 
필요한 문자열로 출력하는 클래스 정의 
ex) DateTimeFormatter 

java.time.temporal : 날짜와 시간의 필드와 단위를 처리하기 위한 클래스 정의 
ex) Temporal, TemporalAdjuster 

java.time.zone : 시간대와 관련된 클래스 정의 

----------------------------------------------------
2.2 java.time 패키지

(1) 날짜 및 시간을 표현하는 클래스 
java.time에는 Temporal 인터페이스와 다섯 가지의 구현체가 
날짜와 시간을 표현한다. 

LocalDate, LocalDateTime, LocalTime, ZonedDateTime, Instant 
--> <<interface>> Temporal 

클래스들이 많아졌지만, Temporal 인터페이스에 대한 구현체들이기 
때문에 Temporal 인터페이스의 사용법만 익히면 나머지 클래스의 사용법은 
매우 유사하다. 기존의 Calendar 대비 클래스별로 세분화되어 날짜와 
시간을 표시한다. 

- LocalDate : 현재 소속된 로컬의 날짜를 다루는 클래스 이다. 
- LocalTime : 현재 소속된 로컬의 시간을 다루는 클래스 이다. 
- LocalDateTime :현재 소속된 로컬의 날짜와 시간을 다루는 클래스로 
LocalDate와  LocalTime을 합한 것과 같다. 
- ZonedDateTime : 특정 타임존의 날짜와 시간을 다루는 클래스로 
LocalDate와 LocalTime 그리고 Timezone이 합쳐진 형태이다. 
- Instant : 1970.01.01 0:00:00 초 부터 지금까지의 시간을 나노초로
표현하며 Date와 의 타입 변환에 주로 사용된다. 

Instant를 제외한 나머지는 4개의 클래스는 사용법이 매우유사하다. 
이들은 now() 와 of()라는 정적 메서드를 갖는다. 

now()는 현재 시각을 기준으로 날짜 또는 시간 정보를 갖는 객체를 
리턴한다. now()는 필요에 따라 ZoneId 또는 Clock 객체를 이용해 특정 
타임존 또는 클럭 기반으로 객체를 생성할수 있다. 

of()는 각 객체가 가지는 요소(예를들어 LocalDate는 년/월/일 정보, 
LocalTime은 시/분/초 정보)들을 파라미터로 받아서 객체를 생성한다. 

ex)
 package ch12.date;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.ZoneId;
import java.time.ZonedDateTime;

public class CreateTime {

	public static void main(String[] args) {
		localDate();
		localTime();
		etc();
	}

	private static void localDate() {
		LocalDate date = LocalDate.now();
		System.out.println(date);

		LocalDate date2 = LocalDate.of(2015, 01, 01);
		System.out.println(date2);
	}

	private static void localTime() {
		LocalTime time = LocalTime.now();
		System.out.println(time);

		LocalTime time2 = LocalTime.of(13, 40, 23);
		System.out.println(time2);
	}

	private static void etc() {
		LocalDateTime dt = LocalDateTime.now();
		System.out.println(dt);
		
		ZonedDateTime zdt = ZonedDateTime.of(dt, ZoneId.of("Asia/Seoul"));
		System.out.println(zdt);
	}
}
//
2019-04-14
2015-01-01
18:04:13.231910900
13:40:23
2019-04-14T18:04:13.231910900
2019-04-14T18:04:13.231910900+09:00[Asia/Seoul]

(2)날짜/시간 정보의 조회와 변경 

각 클래스는 상황에 맞는 getXXX() 메서드를 제공한다. 여기서 XXX는 
클래스 별로 Year, Month, Hour, Minute 등이 사용된다.

정보 조회를 위한 메서드들 

클래스 : 메서드 : 설명 

LocalDate 
public int getYear() : 연도 정보 리턴 
public int getMonthValue() : 월 정보(1~12) 리턴 
public Month getMonth() : Month 객체로 월 정보 리턴 
public int getDayOfMonth() : 그 달에서 일 정보(1~31) 리턴 
public int getDayOfYear() : 그 해에서 일 정보(1~365) 리턴 
public DayOfWeek getDayOfWeek() : DayOfWeek 타입으로 요일 정보 리턴.
public boolean isLeapYear() : 윤년 여부 리턴 
public int lengthOfMonth() : 그 달이 몇일까지 인지 리턴 (365|366)

LocalTime
public int getHour() : 시간 정보(0~23)리턴 
public int getMinute() : 분 정보(0~59)리턴 
public int getSecond() : 초 정보(0~59)리턴 

LocalDateTime에서는 시간 연산을 위해서 
plusXXX(), minusXXX(), withXXX() 메서드들이 사용된다.
plus 계열은 더하기 , minus 계열은 빼기, with 계열은 
설정하기라고 생각하면 쉽다. 
XXX는 get() 계열과 마찬가지로 클래스에 따라서 Years,
Months 등이 사용된다. 이 메서드들은 같은 타입을 리턴하는데,
time 패키지의 클래스들은 String과 마찬가지로 변경 불가능한 
클래스이므로 매번 새로운 객체를 리턴한다. 

예를들어 11월에 다음 코드를 수행한다고 가정해보자. 처음 now 
값은 November이고 이 값은 아무리 plus, minus 연산을 수행해도 
변하지 않는다. plus 등 연산은 결과로 새로운 객체를 반환한다. 
따라서 now2의 값은 January 가 된다. 

ex)
LocalDate now = LocalDate.now()
LocalDate now2 = now.plusMonths(2)
System.out.println(now.getMonth().name()); //November
System.out.println(now2.getMonth().name()); //JANUARY

ex2)
package ch12.date;

import java.time.DayOfWeek;
import java.time.LocalDateTime;
import java.time.Month;
import java.time.format.TextStyle;
import java.util.Locale;

public class UseTimeInfo {

	public static void printDate(LocalDateTime now) {
		String date = now.getYear() + "/" + now.getMonthValue() + "/" + now.getDayOfMonth();
		String time = now.getHour() + ":" + now.getMinute() + ":" + now.getSecond();
		DayOfWeek day = now.getDayOfWeek();
		String dayDsipName = day.getDisplayName(TextStyle.SHORT, Locale.KOREAN);
		System.out.println(date + "(" + dayDsipName + ")" + time);
		Month month = now.getMonth();
		String monthDispName = month.getDisplayName(TextStyle.SHORT, Locale.KOREAN);
		System.out.println(monthDispName);
	}

	public static void main(String[] args) {
		LocalDateTime now = LocalDateTime.of(2017, 1, 1, 12, 30, 30);
		printDate(now);
		LocalDateTime now2 = now.plusMonths(2).minusDays(5);// now 월+2, 일-5
		printDate(now2);
		LocalDateTime now3 = now.withMonth(5).withHour(0); // 기존 월 --> 5로 수정
		printDate(now3);
	}
}
//
2017/1/1(일)12:30:30
1월
2017/2/24(금)12:30:30
2월
2017/5/1(월)0:30:30
5월

with() 중에 TemporalAdjuster를 파라미터로 받는 경우가 있는데 이 메서드는 
단순히 값을 설정하는 것이 아니라 기존 값을 기준으로 상대적으로 값을 
변경한다. TemporalAdjusters에는 TemporalAdjuster를 리턴하는 다양한 
정적(static) 메서드를 제공한다. 사용법들이 유사하고 가짓수만 많으므로 
대표적인 것들만 살펴보자. 

TemporalAdjusters의 주요 메서드 

메서드명 : 선언부와설명

firstDayOfYear() : public static TemporalAdjuster firstDayOfYear()
해당 년도의 첫날을 설정하기 위한 TemporalAdjuster를 리턴한다. 

lastDayOfYear() : public static TemporalAdjuster lastDayOfYear()
해당 년도의 마지막날을 설정하기 위한 TemporalAdjuster를 리턴한다. 

firstDayOfMonth() : public static TemporalAdjuster firstDayOfMonth()
해당 월의 첫날을 설정하기 위한 TemporalAdjuster를 리턴한다. 

lastDayOfMonth() : public static TemporalAdjuster lastDayOfMonth()
해당 월의 마지막날을 설정하기 위한 TemporalAdjuster를 리턴한다. 

next() : public static TemporalAdjuster next(DayOfWeek dayOfWeek)
돌아오는 요일을 설정하기 위한 TemporalAdjuster를 리턴한다

previous() : public static TemporalAdjuster previous( DayOfWeek dayOfWeek)
이전 요일을 설정하기 위한 TemporalAdjuster를 리턴한다.

ex)

package ch12.date;

import java.time.DayOfWeek;
import java.time.LocalDateTime;
import java.time.temporal.TemporalAdjusters;

public class UseTemporalAdjuster {

	public static void main(String[] args) {
		LocalDateTime datetime = LocalDateTime.of(2017, 1, 1, 1, 1, 1);
		System.out.println("기준일: "+datetime+"-"+datetime.getDayOfWeek());
		LocalDateTime lastDay = datetime.with(TemporalAdjusters.lastDayOfYear());
		System.out.println("마지막일: "+lastDay+"-"+lastDay.getDayOfWeek());
		LocalDateTime prevWeekDay = datetime.with(TemporalAdjusters.previous(DayOfWeek.SUNDAY));
		System.out.println("이전 일요일: "+prevWeekDay+"-"+prevWeekDay.getDayOfWeek());
		LocalDateTime nextWeekDay = datetime.with(TemporalAdjusters.next(DayOfWeek.MONDAY));
		System.out.println("다음 월요일: "+nextWeekDay+"-"+nextWeekDay.getDayOfWeek());
	}
}
//
기준일: 2017-01-01T01:01:01-SUNDAY
마지막일: 2017-12-31T01:01:01-SUNDAY
이전 일요일: 2016-12-25T01:01:01-SUNDAY
다음 월요일: 2017-01-02T01:01:01-MONDAY

(3) 날짜와 시간의 비교 
날짜와 시간을 비교하기 위해 compareTo(), isAfter(), isBefore(),
isEqual(), until()등의 메서드를 사용한다. 

메서드명 : 선언부와설명

compareTo() : public int compareTo(ChronoLocalDate other)
객체의 날짜가 other와 비교해서 빠르면 양수, 느리면 음수, 같으면 0을 
리턴 한다.

isAfter() : public boolean isAfter(ChronoLocalDate other)
객체의 날짜가 other 뒤의 시점인지 리턴한다.

isBefore() : public boolean isBefore(ChronoLocalDate other)
객체의 날짜가 other 이전 시점인지 리턴한다. 

isEqual() : public boolean isEqual(ChronoLocalDate other)
객체의 날짜가 other와 동일한 날짜인지 리턴한다. 

until() : public long until(Temporal endExclusive, TemporalUnit unit)
객체의 날짜와 endExclusive와의 unit 에 대한 차이를 long 값으로 
리턴한다.

위 표는 LocalDate의 메서드들이며 다른 클래스에도 유사한 메서드들이 
있으니 어렵지 않게 사용할수 있다. 다른 클래스의 메서드들은 
도큐멘테이션을 활용하자.

until()은 TemporalUnit 타입의 unit 을 기준으로 두 날짜의 차이를 
long 값으로 리턴한다. 
TemporalUnit 의 구현체로는 ChronoUnit 이 사용된다.
ChronoUnit은 Enum 으로 YEARS, MONTHS, WEEKS, DAYS, MINUTES, SECONDS 
등 enum 상수 값을 갖는다. 

ex)
package ch12.date;

import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;

public class DateCompare {

	public static void main(String[] args) {
		LocalDateTime date1 = LocalDateTime.now();
		LocalDateTime date2 = LocalDateTime.of(2000, 1, 1, 1, 1, 1);
		System.out.printf("date1: %s, date2: %s%n",date1,date2);
		System.out.println(date1.isBefore(date2));
		System.out.println(date1.isAfter(date2));
		System.out.println(date1.isEqual(date2));

		long pasted = date2.until(date1, ChronoUnit.YEARS);
		System.out.printf("date1는 date2으로부터 %d년 지났다." ,pasted);
	}
}
//
date1: 2019-04-17T23:40:27.424598500, date2: 2000-01-01T01:01:01
false
true
false
date1는 date2으로부터 19년 지났다.

두 날짜/시간 사이를 더 전문적으로 처리하기 위해서는 Period와
Duration 클래스를 사용할수 있다. 
이 두 클래스는 각각 between()이라는 정적 메서드를 이용해서 
구할수 있다. 
Period는 년, 달, 일의 차이를 계산하고 Period는 초, 나노초의 
차이를 계산한다. 

Period 클래스의 주요 메서드

메서드명 : 선언부와설명

between() : public static Period between
(LocalDate startDateInclusive, LocalDate endDateExclusive)
비교할 두 날짜의 차이를 저장할 Period 객체를 리턴한다.
단, startDateInclusives는 포함하고 endDateExclusive는 
포함되지 않는다.

getYears() : public int getYears()
년의 차이를 리턴한다.

getMonths() : public int getMonths()
월의 차이를 리턴한다.

getDays() : public int getDays()
일의 차이를 리턴한다.

Duration 클래스의 주요 메서드 

메서드명 : 선언부와설명

between() : public static Duration between
(Temporal startInclusive, Temporal endtInclusive)
비교할 두 시간 사이의 차이를 저장할 Duration 객체를 리턴한다.
단 startInclusive는 포함하고 endExclusive는 포함하지 않는다.

getSeconds() : public long getSeconds()
초의 차이를 리턴한다. 

getNano() : public int getNano()
나노초의 차이를 리턴한다.

주의할점은 Period는 단위별로 차이를 계산하고 Duration은 총 시간의
차이를 계산한다는 점. 

ChronoUnit의 열거 타입들도 between() 메서드를 갖는데 이 메서드는 
Duration과 마찬가지로 총 시간의 차이를 계산한다. 

ex)
LocalDateTime dt1 = LocalDateTime.of(2016, 1, 1, 1, 1, 1);
LocalDateTime dt1 = LocalDateTime.now();
long secDiff = ChronoUnit.SECONDS.between(dt1, dt2); // 총 초의 차이
long hourDiff = ChronoUnit.HOURS.between(dt1, dt2); // 총 시간의 차이

3개의 between() 메서드를 비교하면 다음과 같다. 

between()  메서드의 동작 기준 

메서드 : 리턴 타입 : 연산_기준
Period.between() : 년/월/일 차이_계산 : 각 단위별로 연산 

Duration.between() : 초/나노 초로 계산 : 총 시간을 기준으로 연산

ChronoUnit.XXX.between() : 모든 단위 계산 : 총 시간을 기준으로 연산

ex)
package ch12.date;

import java.time.Duration;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.Period;
import java.time.temporal.ChronoUnit;

public class DifferBetween {

	public static void main(String[] args) {
		LocalDate date1 = LocalDate.of(2000, 1, 3);
		LocalDate date2 = LocalDate.of(2017, 5, 1);

		Period period = Period.between(date1, date2);
		System.out.println(period);// Period에는 두 날짜의 차이가 저장됨
		System.out.println("몇 년 차이? " + period.getYears()); // 년 간의 차이
		System.out.println("몇 월 차이? " + period.get(ChronoUnit.MONTHS));// 월 간의 차이
		System.out.println("몇 일 차이? " + period.get(ChronoUnit.DAYS));// 일 간의 차이	
		
		long monthDiff = ChronoUnit.MONTHS.between(date1, date2);
		System.out.println("몇 개월 차이? "+monthDiff);// 총 개월의 차이
		
		LocalDateTime dt1 = LocalDateTime.of(2016,1,1,1,1,1);
		LocalDateTime dt2 = LocalDateTime.of(2017,1,1,1,1,1);
		Duration duration = Duration.between(dt1, dt2);
		System.out.println(duration);
		System.out.println("몇 초 차이? "+duration.getSeconds());		
		long secDiff = ChronoUnit.SECONDS.between(dt1, dt2); // 총 초의 차이
		System.out.println("몇 초 차이? "+secDiff);// 총 초의 차이
		long hourDiff = ChronoUnit.HOURS.between(dt1, dt2);
		System.out.println("몇 시간 차이? "+hourDiff);
	}
}
//
P17Y3M28D
몇 년 차이? 17
몇 월 차이? 3
몇 일 차이? 28
몇 개월 차이? 207
PT8784H
몇 초 차이? 31622400
몇 초 차이? 31622400
몇 시간 차이? 8784

(4) 날짜/시간의 표현 
날짜/시간 정보는 필요에 따라 다양한 형태로 표시될수 있다. 
예를들어 2017년 1월 1일이라는 값을 필요에 따라 
2017/01/01, 170101, 0101(일) 등과 같이 출력할수 있다. 
출력될 때는 어떤 형식이든지 문자열로 출력되는데 매번 필요한
값을 뽑아서 문자열을 구성하기는 매우 힘들다. 
또는 거꾸로 화면상에 다양하게 출력된 문자열 값을 다시 날짜로 
환산할 필요도 발생한다. 

이처럼 객체를 원하는 형태의 문자열로 변환하는 과정을 포멧팅
(형식화, formatting)이 라고 하고, 반대로 문자열을 객체로 변경하는 
과정을 파싱(parsing)이라고 한다. 포멧팅과 파싱을 위해서는 
DateTimeFormatter객체가 활용된다. 

포멧팅과 파싱을 위한 LocalTime의 메서드 

메서드명 : 선언부와설명

parse() : public static LocalTime parse(CharSequence text)
text를 DateTimeFormatter.ISO_LOCAL_TIME에 의해서 LocalTime으로 
리턴한다. 

public static LocalTime parse(CharSequence text, DateTimeFormatter formatter)
text를 formatter에 의거 LocalTime으로 리턴한다. 

format() : public String format(DateTimeFormatter formatter)
LocalTime을 formatter에 의거 String으로 리턴한다. 

LocalDate와 LocalDateTime도 LocalTime과 동일한 메서드들이 제공된다. 
단지 리턴 타입만 LocalTime이 아니라 해당 클래스 타입으로 
변경된다.
DateTimeFormatter는 다양한 상수로 출력 형태들이 정의 되어 있다. 
주요 포맷들을 살펴보자. 

DateTimeFormatter에 미리 정의된 출력 형태 

상수명 : 설명 : 예

BASIC_ISO_DATE : 기본 ISO 날짜 형태 : "20111203"
ISO_LOCAL_DATE : ISO 로컬 날짜 형태 : "2011-12-03"
ISO_LOCAL_TIME : ISO 로컬 시간 형태 : '10:15'or '10:15:30'
ISO_LOCAL_DATE_TIME : ISO 로컬 날짜_시간 형태 : '2011-12-03T10:15:30'
ISO_ORDINAL_DATE : 년과 년에서의 날 수 : '2012-337'
ISO_WEEK_DATE : 년과 주수 및 주에서의 날수 : '2012-W48-6'

다음은 '2007.02.05.01:11:0'의 시각을 다양한 형태로 출력한 예.

ex)
package ch12.date;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class DateParse {
	public static void main(String[] args) {
		LocalDateTime date = LocalDateTime.of(2007, 2, 5, 1, 11, 0);
		System.out.printf("기본 날짜 출력: %s%n", date);
		System.out.println(date.format(DateTimeFormatter.BASIC_ISO_DATE));
		System.out.println(date.format(DateTimeFormatter.ISO_LOCAL_DATE));
		System.out.println(date.format(DateTimeFormatter.ISO_LOCAL_TIME));
		System.out.println(date.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));
		System.out.println(date.format(DateTimeFormatter.ISO_ORDINAL_DATE));
		System.out.println(date.format(DateTimeFormatter.ISO_WEEK_DATE));
		
		String isoLocalDateTime = "2007-02-05T01:11";
		System.out.println(isoLocalDateTime);
		LocalDateTime parsed = LocalDateTime.parse(isoLocalDateTime);
		System.out.printf("복원된 값: %s",parsed);
	}
}
//
기본 날짜 출력: 2007-02-05T01:11
20070205
2007-02-05
01:11:00
2007-02-05T01:11:00
2007-036
2007-W06-1
2007-02-05T01:11
복원된 값: 2007-02-05T01:11

위와 같이 DateTimeFormatter는 다양한 포맷의 출력을 지원하지만,
개발자가 원하는 형태의 출력이 아닐수 있다. 이때는 ofPattern()을 
이용할수 있다. ofPattern()에는 미리 지정된 형식 문자들을 조합해서 
원하는 패턴을 작성할수 있다. 

다음은 사용자 정의 패턴 지정에 사용할수 있는 형식 문자들이다. 

포멧과 파싱에 자주 사용되는 형식 문자들 

기호 : 의미 : 표현 : 예 

y : 연도 : yyyy,yy : 2007,07
M : 월 : MMM, MM : 12월 , 12
d : 일 : dd : 21
E : 요일 : EEEE, E : 수요일, 수 
H : 시간( 0 ~ 23) : HH : 4
K : 시간( 0 ~ 11) : KK : 11
m : 분 ( 0 ~ 59) : mm : 30
s : 초 ( 0 ~ 59) : ss : 40 
a : 오전/오후 : a : 오전/오후 

이 외의 다양한 형식 문자들은 
java.time.format.DateTimeFormatter API의 'Patterns 
for Formatting and Parsing'부분을 살펴보도록 한다. 

위의 형식 문자 중 한글이 들어가는 것을 사용할 때는 로케일을 
고러해야 한다. 예를 들어 오전/오후는 Locale.KOREAN에서만 
적용된다. AM이나 PM을 a로 대체하려면 
Locale.ENGLISH를 이용해야 한다. 

DateTimeFormatter의 ofPattern() 메서드 

메서드명 : 선언부와설명

ofPattern() : public static DateTimeFormatter ofPattern(String pattern)
pattern 이 적용된 DateTimeFormatter를 반환한다. 

public static DateTimeFormatter ofPattern(String pattern, Locale locate)
pattern과 locale 이 적용된 DateTimeFormatter를 반환한다. 

다음 예는 사용자 정의 패턴을 이용해서 날짜 및 시간을 출력하는 방법.

ex)

package ch12.date;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.Locale;

public class DateParse2 {
	public static void main(String[] args) {
		String sDate = "2015-01-01";
		LocalDate lDate = LocalDate.parse(sDate);
		System.out.println("ISO_LOCAL_DATE 형태 : " + lDate);

		String sDate2 = "2015-01-01(목)";
		DateTimeFormatter dformatter = DateTimeFormatter.ofPattern("yyyy-MM-dd(E)");
		LocalDate lDate2 = LocalDate.parse(sDate2, dformatter);
		System.out.println("사용자 정의 형태(날짜) : " + lDate2);

		String sTime = "03:30:30";
		LocalTime lTime = LocalTime.parse(sTime);
		System.out.println("ISO_LOCAL_TIME 형태 : " + lTime);

		String sTime2 = "03:30:30 오후";
		DateTimeFormatter tformatter = DateTimeFormatter.ofPattern("KK:mm:ss a");
		LocalTime lTime2 = LocalTime.parse(sTime2, tformatter);
		System.out.println("사용자 정의 형태(시간) : " + lTime2);

		String sTime3 = "03:30:30 PM";
		DateTimeFormatter tformatter2 = DateTimeFormatter.ofPattern("KK:mm:ss a", Locale.ENGLISH);
		LocalTime lTime3 = LocalTime.parse(sTime3, tformatter2);
		System.out.println("사용자 정의 형태(시간_로케일) : "+lTime3);

		String sDateTime = "2015-01-01T11:20:30";
		LocalDateTime ldt = LocalDateTime.parse(sDateTime);
		System.out.println("ISO_LOCAL_DATE_TIME 형태: " + ldt);
		
		String sDateTime2 = "2015년 01월 01일(목요일) 오후 03시 30분";
		DateTimeFormatter tformatter3 = DateTimeFormatter.ofPattern("yyyy년 MM월 dd일(EEEE) a KK시 mm분");
		LocalDateTime ldt2 = LocalDateTime.parse(sDateTime2, tformatter3);
		System.out.println("사용자 정의 형태(날짜_시간) : " + ldt2);
	}
}
//
ISO_LOCAL_DATE 형태 : 2015-01-01
사용자 정의 형태(날짜) : 2015-01-01
ISO_LOCAL_TIME 형태 : 03:30:30
사용자 정의 형태(시간) : 15:30:30
사용자 정의 형태(시간_로케일) : 15:30:30
ISO_LOCAL_DATE_TIME 형태: 2015-01-01T11:20:30
사용자 정의 형태(날짜_시간) : 2015-01-01T15:30


----------------------------------------------------
3. StringTokenizer 클래스를 통한 문자열 분리 

StringTokenizer는 문자열을 구분자 캐릭터를 이용해 분리해주는 클래스이다. 
예를들어 여러 개의 '이름: 값' 쌍으로 구성된 문자열이 있을 때 
이름과 값들을 쉽게 분리할수 있다. 
StringTokenizer는 분리할 문자열과 구분자를 파라미터로 받는다. 

예를들어 숫자와 쉼표로 구성된 문자열을 쉼표 기준으로 분리하기 
위한 코드를 다음과 같이 작성할수 있다. 

ex)
StringTokenizer tokens = new StringTokenizer("10,030,042,034,023",",");

StringTokenizer에는 구분자에 의해 분리된 토큰들의 정보를 알수 있는 
메서드들을 제공한다. 

다음은 StringTokenizer 클래스의 주요 메서드이다. 

메서드명 : 선언부와설명

countTokens() : public int countTokens()
소모하지 않고 남아있는 토큰의 개수를 리턴한다. 
여기서 소모의 개념은 nextToken()을 호출한 것을 말한다. 

hasMoreTokens() : public boolean hashMoreTokens()
남아있는 토큰이 있는지 여부를 리턴한다. 

nextToken() : public String nextToken()
다음 토큰을 문자열로 리턴한다. 

StringTokenizer는 구분자를 이용해서 문자열을 분리-관리한다. 
countTokens()를 사용하면 생성된 토큰의 개수를 확인할수 있다. 
주로 반복문을 통해서 토큰들을 확인하는데 hasMoreTokens()를 
이용해 토큰이 있는지 확인하고 있다면 nextToken()을 이용해서 
개별 토큰들을 사용할수 있다. 

ex)
String source = "10,030,042";
StringTokenizer tokens = new StringTokenizer(source, ",");
System.out.println("토큰의 개수: " + tokens.countTokens());
while(tokens.hashMoreTokens()){
System.out.println(tokens.nextToken());
} 

위의 예는 source 문자열을 ','를 이용해서 분리한다. 
따라서 10과 030 그리고 042 라는 3개의 토큰이 생기게 되고 
반복문을 통해 토큰들을 하나씩 빼서 출력한다. 

StringTokenizer를 사용할 때는 두가지 주의사항이 있다. 

첫번째는 countTokens()가 유동적이라는 점이다. 다음코드를 보자. 

ex2)
String source = "10,030,042";
StringTokenizer tokens2 = new StringTokenizer(source, ",");
for(int i = 0; i < tokens2.countTokens(); i++){
System.out.println(tokens2.nextToken());
} 

for 문을 이용한 아주 단순한 반복문이다. 얼른 생각하면 10, 030, 042 
가 리턴될 것 같지만, 이 코드의 실행과는 10, 030 이다. 
이유는 countTokens()는 남아있는 토큰의 개수를 리턴하는데 
이 값은 nextToken()을 호출할때 마다 하나씩 줄어든다. 
결국, 다음 그림처럼 세번째 토큰을 출력할 기회가 없는 것이다. 

따라서 적절한 for 문은 countTokens() 의 값을 미리 변수에 
할당해 놓은 후 사용하거나, hasMoreTokens() 조건을 
사용하는 것이다. 

ex3)
int cnt = tokens2.countTokens();
for(int i = 0; i < cnt; i++){
System.out.println(tokens2.nextToken());
}

for(; tokens2.hasMoreTokens(); ) {
System.out.println(tokens2.nextToken());
}

두번째 주의사항은 문자열을 토큰으로 분리할때 구분자는 문자열 
단위가 아니라 문자 단위라는 점이다. 
예를들어 구분자에 '0,'을 입력했다면, 구분자는 '0' 또는 ','가 
되고 토큰은 1, 3, 42가 된다. 

다음 예는 학생의 시험점수를 하나의 문자열 형태로 받아서 
평균을 구하는 방법을 보자. 

ex)
package ch12.token;

import java.util.StringTokenizer;

public class StringTokenizerTest {

	public static void main(String[] args) {
		String info = "이름:홍길동, Java:100, HTML:80, Script:85";
		StringTokenizer tokens = new StringTokenizer(info, ": ,");
		
		//소스와 구분자(: ,)를 이용해 StringTokenizer를 생성한다. 
		//따라서 실제로 동작하는 ':'과 '( 공백문자)' , ','의 3개로 
		//"이름", "홍길동", "Java", "100", "HTML", "80"
		//, "Script", "85"의 8개 토큰이 생성된다. 
		
		System.out.println("총 토큰의 개수: " + tokens.countTokens());
		int sum = 0;
		while(tokens.hasMoreTokens()) {
			String token = null;
			try {
				token = tokens.nextToken();
				sum += Integer.parseInt(token);
			} catch (NumberFormatException e) {
				System.out.println("숫자 아님: " + token);
				
				// 반복문을 이용해서 토큰을 사용한다. 
				//토큰은 String 형태로 얻을 수 있기 때문에 
				// 점수를 숫자로 변경하기 위해 Interger의 parseInt()를 
				// 사용한다. 만약, 숫자 형태가 아니라면 NumberFormatException이 
				//발생하므로 try ~ catch 블록으로 처리한다. 
			}
		}
		System.out.println("총점: " + sum);
	}
}
//
총 토큰의 개수: 8
숫자 아님: 이름
숫자 아님: 홍길동
숫자 아님: Java
숫자 아님: HTML
숫자 아님: Script
총점: 265



----------------------------------------------------
4. 형식화 클래스

많은 경우 프로그래밍에서 유용한 형식과 화면에서 유용한 데이터의 
형태는 다르다. 프로그램에서 유용한 형식은 데이터 자체가 많은 정보를 
가지는 경우로 객체일 경우가 많다. 
객체를 통해 다양한 속성과 기능들을 사용할수 있기 때문이다. 
하지만 화면에 출력될 때는 오로지 문자열만 의미 있기 때문에 사람이 
읽을수 있도록 가시성 좋은 표현이 필요하다.
그래서,Object 의 toString() 메서드를 오버라이딩해서 사용한다. 

하지만, 오버라이딩해서 사용하기 어려운 형태가 두 종류있다. 
바로 객체가 아닌 기본형 중 숫자와 다양한 형태로 출력될수 있는 
Date 클래스이다. 
예를들어 100000000은 쉽게 읽기 어렵다. 
100,000,000 과 같이 천단위 구분자가 있다면 좀더 읽기 쉬울걸이다. 
하지만, 100,000,000은 숫자가 아닌 문자열이다. 
숫자에는 ',' 가 들어갈수 없기 때문이다. 
이처럼 숫자 또는 Date 를 읽기 쉬운 문자열로 바꾸는데 사용되는 
클래스를 형식화 클래스라고 한다. 
형식화 클래스는 DecimalFormat과 SimpleDateFormat이 있다. 


4.1 DecimalFormat 클래스 

DecimalFormat은 숫자에 대한 형식화 클래스이다. 이런 형식화 클래스에서 
패턴을 만들고 적용하는 방법은 앞서 살펴봤던 DateFormatter에서의 방법과 
유사하다. 먼저 지정된 기호들을 조합해서 패턴을 만들고 그것을 이용해 
데이터를 문자열로 만들거나 거꾸로 문자열을 데이터로 변환한다. 

다음은 DecimalFormat에서 사용되는 기호와 사용예를 보여준다. 

DecimalFormat의 주요 패턴 기호 

기호 : 의미 : 예(1234.5에 패턴을 적용했을 경우)

0 : 0~9, 값이 없으면 0으로 채움 : 0->1234,
0.0 -> 1234.5 , 00000.00 -> 01234.50 

# : 0~9 : # -> 1234 , #.# -> 1234.5 , #####.## -> 1234.5

. : 소수 구분 기호 

- : 마이너스 표시 : -#.# -> -1234.5

, : 1,000 단위 그룹 구분자 -> #,###.# -> 1,234.5

E : 과학 표기법에서의 지수 문자 : 0.0E0 -> 1.2E3

% : 100이 곱해진 값으로 퍼센트(%) : #,###.##% -> 123,450%

\u2030 : 1000이 곱해진 값으로 퍼밀 (‰) : #,###.##\u2030 -> 1,234,500‰

\u00A4 : 통화 기호. 두 개가 사용되면 국제 통화 기호로 대체됨.
\u00A4#,###.## -> ￦1,234.5
\u00A4\u00A4#,###.## -> ￦1,234.5

사용할 패턴을 결정했다면, DecimalFormat의 생성자에 패턴을 넘겨주고 
객체를 생성할수 있다. 

ex)
DecimalFormat df = new DecimalFormat("#,###.#");

이제 DecimalFormat을 이용해서 parse()와 format()을 처리한다. 
앞서 DateFormatter에서의 밝혔듯이 parse()는 문자열을 데이터로 
만드는 과정이고, format()은 데이터를 문자열로 만드는 과정이다. 
applyPattern()은 기존의 DecimalFormat 객체에 새로운 패턴을 
적용한다. 

DecimalFormat의 주요 메서드 

메서드명 : 선언부와설명

format() : public final String format(double number)
number를 패턴에 의해 문자열로 변환 후 리턴한다. 

parse() : public Number parse(String source) throws ParseException
source 를 패턴에 의해 Number로 변환 후 리턴한다. 

applyPattern() : public void applyPattern(String pattern)
새로운 패턴을 DecimalFormat 객체에 적용한다. 

다음_예는 숫자를 통화기호가 붙은 문자열로 표현하고 
다시 숫자로 변환하는 과정을 보여준다. 

ex)
package ch12.format;

import java.text.DecimalFormat;
import java.text.ParseException;

public class DecimalFormatTest {

	public static void main(String[] args) throws ParseException {
		double orgNum = 1234.5;
		//DecimalFormat df = new DecimalFormat("\u00A4#,###.#");
		DecimalFormat df = new DecimalFormat("￦#,###.#");
		System.out.println(df.format(orgNum));
		String orgStr = "￦1,234.5";
		double parsed = (double) df.parse(orgStr);
		System.out.println(parsed);
		
		df.applyPattern("#.#%");
		System.out.println(df.format(parsed));
	}
}

//
￦1,234.5
1234.5
123450%

Note 
막상 한글 통화 기호를 입력하려면 당황스러울때가 있다. 
키보드에 있는 통화기호처럼 보이는 것은 백슬래시로 정식 통화 
기호가 아니며 심지어 사용하는 폰트에 따라 다르게 표시된다. 
정식적인 한글 통화 기호는 다음과 같이 Currency 클래스를 이용한다. 

ex)
String symbol = Currency.getInstance(Locale.KOREA).getSymbol();

간단히 입력할 때는 통상'ㄹ' 입력 후 한자키를 눌러 특수 문자 입력 
보드로 변경 후 3 번째에 있는 '￦' 를 사용하기도 한다. 

----------------------------------------------------
4.2 SimpleDateFormat 클래스

SimpleDateFormat은 DateFormatter와 마찬가지로 날짜/시간 정보에 
대한 패턴을 지정해서 파싱과 포멧팅을 처리한다. 
차이점은 SimpleDateFormat은 Date 객체에 대해서 사용된다는 점이다. 
SimpleDateFormat에서 패턴 작성을 위해 사용되는 기호들은 
DateFormatter에서 사용되는 것과 동일하다. 

SimpleDateFormat을 생성할 때에는 DecimalFormat과 마찬가지로 
생성자에 패턴 문자를 전달하면 되고 이후 format()과 parse()
메서드를 사용할수 있다. 

ex)
SimpleDateFormat sdf = new SimpleDateFormat("yyyy년 MM월 dd일 E요일");
System.out.println(sdf.format(date));

SimpleDateFormat에서 사용하는 메서드들은 DecimalFormat의 메서드들과 
동일하다. 
단지 파라미터와 리턴 타입이 약간씩 차이가 있을 뿐이다. 

SimpleDateFormat의 주요 메서드 

메서드명 : 선언부와 설명 

format() : public final String format(Date date)
date를 패턴에 의해 문자열로 변환 후 리턴한다. 

parse() : public Date parse(String source) throws ParseException
문자열을 패턴에 의해 Date로 변환 후 리턴한다. 

applyPattern() : public void applyPattern(String pattern)
새로운 패턴을 SimpleDateFormat 객체에 적용한다. 

다음은 날짜 형태의 문자열을 다른 형태의 문자열로 출력하기 
위한 과정을 보여주는 예

ex)
package ch12.format;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

public class SimpleDateFormatTest {

	public static void main(String[] args) throws ParseException {

		String source = "2020년 12월 25일";
		System.out.println(source+"를 요일 정보까지 출력하려면?");
		
		SimpleDateFormat format = new SimpleDateFormat("yyyy년 MM월 dd일");
		Date parsed = format.parse(source);
		
		format.applyPattern("yyyy년 MM월 dd일(E)");
		System.out.println(format.format(parsed));
	}
}
//
2020년 12월 25일를 요일 정보까지 출력하려면?
2020년 12월 25일(금)

----------------------------------------------------
4.3 MessageFormat 클래스 

문자열을 구성하다 보면 String과 다른 String , 기본형, 
객체들을 연결하는 경우가 많이 발생한다. 이런 경우
일반적으로 '+' 연산자를 사용한다.

String source = "Java: " + 100 + ", HTML: " + 90 + ", result: " +
'A';
아주 간단하기 때문에 자주 사용되기는 하지만 계속되는 '+'로 
인해 지저분해 보이고 한눈에 파악하기가 어렵다. 
이때 MessageFormat 을 이용하면 데이터를 변수 처럼 사용해서
메시지 패턴에 적용할수 있다. 

ex)
String pattern = "Java: {0}, HTML: {1}, result: {2}" ;
String result = MessageFormat.format(pattern, 100, 90, 'A');
System.out.println(result); // Java: 100, HTML: 90, result: A 
String result2 = MessageFormat.format(pattern, new Object[] {100,90,'A'});

패턴을 작성할때는 삽입될 데이터 위치에 파라미터가 들어온다는 
의미로 중괄호와 함께 데이터의 인덱스 번호를 써준다.
MessageFormat의 static 메서드인 format()에는 패턴과 함께 패턴의
파라미터에 사용될 값들이 가변인수(Varargs)형태로 전달된다. 
만약 패턴의 파라미터 개수가 가변인수의 개수보다 많으면 
파라미터 선언 그대로 출력된다. 
가변인수 대신 배열을 이용해서 값을 전달할 수도 있다. 

ex)
package ch12.format;

import java.text.MessageFormat;
import java.text.ParseException;

public class MessageFormatTest {

	public static void main(String[] args) throws ParseException {
		String pattern = "이름: {0}, Java: {1}, HTML: {2}, Script: {3}";
		String src = "홍길동:100:90:85,임꺽정:90:95:70,장길산:75:85:90";
		String [] studentInfo = src.split(",");
		for(String student: studentInfo) {
			System.out.println(MessageFormat.format(pattern, student.split(":")));
		}
	}
}
//
이름: 홍길동, Java: 100, HTML: 90, Script: 85
이름: 임꺽정, Java: 90, HTML: 95, Script: 70
이름: 장길산, Java: 75, HTML: 85, Script: 90

주의, 
위와 같이 코드를 작성하면 13행에 경고(warning)가 하나 발생한다. 
내용은 MessageFormat의 format()은 Object... 형태의 파라미터를 
받는데 실제 타입은 String... 이어서 타입이 정확히 일치하지 않는다는 
오류 메시지다. 이는 이클립스에서 프로그램의 안정성을 위해 출력하는 
경고 메시지로 무시해도 지장은 없다. 하지만 좀 꺼림칙하다면 
Window -> Preference -> Java -> Compiler -> Errors/Warnings
-> Potential programming problems 항목에서 
inexact type match for vararg arguments의 항목을 Ignore로 
변경한다.
또는 소스 코드에서 문제를 해결하려면 Object[]로 
student.split(":")를 형변환해서 사용한다.
System.out.println(MessageFormat.format(pattern, student.split(":")));
System.out.println(MessageFormat.format(pattern, (Object[])student.split(":")));

----------------------------------------------------
5. 정규표현식 처리 

정규표현식(Regular Expression: regexp)이란 문자열을 처리하는 방법으로 
패턴 기반의 특정한 조건에 맞는 문자를 검색하거나 치환하는데 사용된다. 
흔히 웹 페이지를 사용하다 보면 이메일이나 전화번호 등이 지정된 
형식에 맞는지, 비밀번호의 복잡도에 특수문자, 영문자, 숫자 등이 
섞여 있는지 등을 확인해야 하는 경우가 많다. 이 과정을 입력 값 
검증 즉 validation 체크라고 한다. 

이런 입력 값을 검증할때 사용자가 입력한 문자열을 파악해서 양식에 
맞는지 파악하기는 매우 어려운일이다. 이때 정규표현식을 이용하면
아주 쉽게 문자열을 분석하고 우리가 원하는 형태인지 파악할수 있다.
정규표현식은 자바 언어만을 위한 것이 아니라 자바스크립트, SQL ,
파이썬 등 다양한 분야에서 활용되므로 복잡하지만 한번 잘 익혀 놓으면
활용할 곳은 아주 많다. 

정규표현식을 작성할때는 일정한 패턴의 문자를 '/'로 감싸서 표현하며 
필요하다면 뒤에 플래그를 추가할수도 있다. 

ex)
/패턴/[플래그]

5.1 정규표현식 표현 방법 

먼저 정규표현식의 패턴 작성법에 대해 알아보자.
정규표현식의 패턴은 표준인 POSIX(Portable Operation System Interface)
형식과 언어별 확장 표현이 있는데 대부분 유사하므로 표준 방식만 익혀도 
큰 무리가 없다. 정규표현식에서 사용하는 기호들을 메타 문자(Meta 문자)라고 
한다. 메타 문자는 표현식 내에서 특정한 의미를 갖는다. 

메타 문자와 그 의미를 https://regexper.com 에서 제공하는 
레일로드 다이어그램(railroad diagram)형태로 알아보자. 

(1) 기본 메타 문자 활용 

메타 문자 : 레일로드 다이어그램 : 의미 

^x : Start of line -- "x" : 문자열이 x로 시작한다. 
ex) x,  xa,  xb, ...

x$ : "x" -- End of line : 문자열이 x로 끝난다.
ex) x, ax, bx, ...

.x : any character -- "x" : x 앞에 어떤 문자가 하나 있다. 
ex) ax, bx, 

x+ :  "x " loop 그림 : x 가 1번 이상 반복될수 있다. 
ex) x, xx, xxx, ...

x? : "x"  위로 선 : x 가 나오거나 안 나올수 있다.
ex) x,  ,  a 

x* : "x" 위로 선, loop 그림 : x가 0번 이상 반복될수 있다. 
ex) a,  x,  xx,  xxx, ...,

x│y : "x" 위에 , "y" 아래 : x 또는 y가 올수 있다. 
ex) x , y 

이런 문자들은 단독으로 사용되지 않고 여러 개가 묶여서 
사용된다. 

다음 예들을 살펴보자. 

ex1)
xa?y$ : 시작은 관계없이 x 뒤에 a가 있거나 없고 y로 끝난다. 
따라서 xy, hixy, hixay는 괜찮지만 xaay는 안된다.

ex2)
x│a?y$ : 연산자 우선순위에서 │의 우선순위가 가장 낮다. 
x 또는 a?y$가 적용된다. 
xy, hixay, xaa 등은 적합하지만, ay2는 부적합.

(2) 괄호의 활용 

정규표현식 : 레일로드 다이어그램 : 의미 

(xy) : group #1 "xy" : 괄호 안의 내용을 하나로 그룹화한다.

x{n, m} : "x" 1..4 times :
{} 앞의 내용이 최소 n번이상 m 번 이하까지 등장한다.
{n}: n 번 반복됨 
{n, } : n번 이상 반복됨.
{n,m} : n번 이상, m번 이하 반복됨 

[xy] : One of "x" 밑에 "y" : []안의 문자중 하나가 나와야 한다. 
[xy] : x 또는 y
[a-z] : 알파벳 소문자 a~z 
[0-9] : 숫자 
[가-힣] : 한글 

[^x] : None of "x" : [] 안에서의 ^는 부정을 의미한다. 
[^0-9] : 숫자가 아닌 것 

()는 내용을 그룹화할 때 사용한다.

- ^(abc)(def)+(ghi)$라는 패턴은 abc로 시작하고 def가 한번이상 
나오고 ghi로 끝나야 한다. 따라서 abcdefghi, abcdefdefghi는 적합,
abcdeghi는 부적합. 

{} 는 내용의 반복 횟수를 지정할수 있다. 

- (a1){2}b{2,4}c{2, } 패턴은 a1이 두번 나오고 
b가 2에서 4번, c가 두번이상 나와야한다.
따라서 a1a1bbcc의 경우는 적합,
a1a1bbbbbbcc 는 부적합.

[] 표기법은 문자의 구성요소를 확인할 때 많이 사용된다. 

- [a-z]{2}[0-9][가-힣][^A-Z]는 
영어 소문자 두 개, 숫자 하나, 한글 하나, 대문자가 아닌 것 하나를 의미.
따라서 aa1홍a , aa1홍2 적합,
aa1홍A는 부적합. 

(3) 예외문자처리
예외 문자를 처리할 때는 '\'를 사용한다. 예를들어 물음표나 
마침표를 표현하고 싶은데 이것들은 이미 정규표현식에서 
각각 특별한 의미를 지니고 있다. 따라서 의미 있는 기호로 
해석하지말고 글자 그대로 처리하라는 의미로 '\'을 붙여준다. 

- .x : x 앞에 어떤 문자가 하나 나와야 한다. 

- \.x : x 앞에 단순히 '.'가 있다. 

정규표현식에는 '\'를 이용한 축약형이 많은데 일괄적으로 소문자는 적용되는 
것을 찾는 것이고 대문자는 적용되지 않는 것을 찾는다. 

정규표현식 : 레일로드 다이어그램 : 의미 

\^ : "^" : \ 뒤에 나오는 문자를 기호로 처리하지 않는다.

\b : word boundary :단어의 경계를 찾는다

\B : non word boundary : 단어의 경계가 아닌 것을 찾는다. 

\d : digit : 숫자를 찾는다. 

\D : non-digit : 숫자가 아닌 것을 찾는다. 

\s : white space : 공백 문자를 찾는다.

\S : non-white space : 공백 문자가 아닌 것을 찾는다.

\w : word : 단어를 구성하는 알파벳, 숫자, _를 찾는다. 
[a-zA-Z0-9_]와 동일하다.

\W : non-word : 알파벳, 숫자, _를 제외한 문자를 찾는다. 
[^a-zA-Z0-9_]와 동일하다.

41/53 486

- \b 와 \B는 이해하기가 좀 어렵다. 다른 메타 문자들이 
특정 텍스트의 집합을 매칭시키는 것과 달리 이 둘은 단어의 
경계(boundary)를 가리킨다. 여기서 단어란 \w 즉, 
[a-zA-Z0-9_] 와 동일하다. 경계라는 말은 특정 문자가 아닌 
위치를 가리키기 때문에 패턴이 일치하더라도 매치되는 길이가 
0이 된다. 예를 들어 'Do you like lily?'에서 \b 와 \B의 위치를 
'*'로 나타내면 다음과 같다. 

ex)
\b : *Do* *you* *like* *lily*?
\B : D*o y*o*u l*i*k*e l*i*l*y?

따라서 '\bl'은 단어 경계뒤에 'l'이 나와야 하므로 밑줄로 
표시하면 Do you like lily?에서 
밑줄은 like의 'l', lily 의 앞의 'l' 이다. 
'\Bl'은 단어 경계뒤에 'l'이 나오지 않아야 하므로 역시 
밑줄로 표시하면 Do you like lily?가 된다. 
밑줄은 lily 의 두번째 'l' 

\Bl 다시 , 단어의 경계뒤에 l 이 아닌것은 이렇게 이해

- 숫자 입력이 필요한 경우 [0-9] 그렇지 않으면 
[^0-9]를 쓸수 있지만, 대신 \d와 \D를 사용할수 있다. 

ex)
a\dg\Dh 라는 패턴은 a, 숫자, g , 숫자가 아닌 것, h 순서대로 나와야한다

a3gAh 적합, adagah, a3g4h 등은 부적합. 

- 공백 문자는 공백, 탭, 엔터를 의미한다. 

ex2)
a\sb\Sc 라는 패턴은 a, 공백, b , 공백이 아닌문자, c가 순서대로 나와야한다

a boc는 적합, ab c 나 a b c 등 부적합. 

a boc는 적합, ab c 나 a b c 등 부적합. 

487 42/53

-일반적으로 단어를 구성하는 문자로는 알파벳, 숫자, _ 를
사용한다. (한글은 해당안됨.)

ex3)
^\w.. 라는 패턴은 단어를 구성하는 글자 하나로 시작해서 
어떤 문자가 두개 오면 된다. 
start of line - word - any_character- any_character
abc, _ab, 123 적합.  .aa, 한글 자 등은 부적합. 

(4) 유용한 정규표현식의 예 
자주 사용되는 구문들을 만들어 보자. 

- 한글이름: ^[가-힣]{2,5}$
Start_of_line - "가"-"힣"  : 2번이상 ~ 5 번 이하 반복 - End_of_line 

-휴대전화번호: 
^(010|011)[-\s]?\d{3,4}[-\s]?\d{4}$

Start_of_line - group1 "010" or "011"- One of : "-" or "(공백)"
digit 3번이상 4번 이하, One of : "-" or "(공백)"
digit 4번 - End_of_line

- 이메일 주소의 표현 
^[\w\.-]{1,64}@[\w\.-]{1,252}\.\w{2,4}$

Start_of_line - One_of : word , ".", "-" 1번이상 64번이하
"@"
One_of : word , ".", "-" 1번이상 252번이하
"."
word 2번이상 4번이하
End_of_line

----------------------------------------------------
5.2 플래그 

플래그는 이제까지 학습한 패턴을 적용하는 방식을 결정하는데 
자주 사용되는 플래그는 다음과 같다. 

플래그  :  설명 
g : Global : 문자열 내의 모든 패턴을 찾는다. 
i : Ignore Case : 문자열의 대소문자를 구별하지 않는다. 
m : Multi line : 문자열이 행이 바뀌어도 찾는다. 

정규표현식을 작성할때는 /패턴/[플래그] 형태로 사용한다. 

예를 들어 
기본 : Hello , Java , Lily 
(1)
/l/ 
Hello 의 첫번째 l 
(2)
/l/g 
Hello 의 l, l 둘다 
Lily 의 l 하나 
(3)
/l/gi
Hello 의 l,l 둘다 
Lily 의 L, l 둘다 
(4)
^[HJL]/g
Hello 의 H 하나 
(5)
^[HJL]/gm
Hello 의 H 하나 
Java 의 J 하나 
Lily 의 L 하나 

만약 패턴만으로 작성 정규표현식 /l/이 있다면 
이식을 만족시키는 표현은 (1) 번처럼 
맨 처음 매칭 부분을 발견하고 끝낸다. 

하지만 /l/g와 같이 플래그를 추가하면 전체에서 
매칭되는 문자열을 찾으므로 (2)번결과 처럼 
총 3개가 매칭된다. 

플래그는 여러개 중복해서 사용할수 있는데 (2)번 정규표현식 뒤에 
i를 추가하면 대소문자 구별을 없애 준다. 
따라서 (3)번의 결과를 얻을수 있다. 

m 즉 멀티행은 시작(^)과 끝($)을 각 문장마다 처리한다. 
이 플래그가 없다면 데이터가 여러 줄로 구성된 경우 시작과 끝에 
대한 점검을 1회만 한다. 즉 (4) 와 같다. 
m 플래그를 추가하면 (5)번 처럼 각 행마다 별도로 시작과 끝을 
확인 하게 된다. 
----------------------------------------------------
5.3 정규표현식을 사용하는 클래스

정규표현식을 자바에서 사용하기 위해서는 
java.util.regex.Pattern 과 java.util.regex.Matcher 
클래스가 주로 사용 된다. 

(1) Pattern 클래스 
Pattern 클래스는 정규표현식을 컴파일해서 관리한다. 
이 클래스는 public 한 생성자를 제공하지 않고 정적인 compile() 
메서드에 문자열 형태의 정규표현식을 넘겨주면 Pattern 객체를 
생성할 수 있다. 본격적인 정규표현식의 사용은 matcher() 메서드에 
분석하려는 문자열을 넘겨줘서 생성되는 Matcher 를 활용한다. 
또는 간단히 정규표현식에 문자열이 적합한지 확인하기 위해서는 matches()를 
사용할수 있다. 
다음은 Pattern 클래스에 선언된 주요 메서드 들이다. 

메서드명 : 선언부와 설명 
complie() : public static Pattern complie(String regex)
정규표현식 regex을 이용해 Pattern 객체를 생성하고 리턴한다. 

matcher() : public Matcher matcher(CharSequence input)
input 을 분석할수 있는 Matcher 객체를 리턴한다. 

matches() : public static boolean matches(String regex, CharSequence input)
input이 regexp에 부합하는지를 리턴한다. 

ex)
package ch12.regexp;

import java.text.MessageFormat;
import java.util.regex.Pattern;

public class RegexpTest {

	public static void main(String[] args) {
		String regexp = "^(010|011)[-\\s]?\\d{3,4}[-\\s]?\\d{4}$";
		String[] numbers = {
				"010-000-1234",
				"01112345678",
				"010)1234 5678",
				"010 1234 567a" };
		String resultPattern = "{0}는 전화번호 타입인가? {1}";
		for (String number : numbers) {
			boolean result = Pattern.matches(regexp, number);
			System.out.println(MessageFormat.format(resultPattern, number, result));
		}
	}
}
//
010-000-1234는 전화번호 타입인가? true
01112345678는 전화번호 타입인가? true
010)1234 5678는 전화번호 타입인가? false
010 1234 567a는 전화번호 타입인가? false

(2) Matcher 클래스 
Matcher 클래스는 패턴을 해석하고 입력 문자열에 대해 일치하는지 
파악하는 역할을 수행한다. 
Pattern과 마찬가지로 공개된 생성자는 없으며 Pattern의 matcher()를 
통해서 얻을수 있다. Pattern은 간단히 문자열이 정규표현식에 부합하는지만 
확인할수 있지만, Matcher는 문자열이 정규표현식의 내용을 가지고 있는지,
위치는 어디인지등 자세한 정보를 알수 있다. 

Matcher의 주요 메서드들. 

메서드명 : 선언부와설명

find() : public boolean find()
문자열 내에서 정규표현식에 부합되는 내용이 있는지 여부를 리턴한다. 
이때 start()의 리턴 값에서부터 검색한다. 

start() : public int start()
패턴에 부합되는 요소의 시작 인덱스를 리턴한다. 

end() : public int end()
패턴에 부합되는 요소의 끝 인덱스+1 를 리턴한다. 

matches() : public boolean matches()
비교하려는 문자열 전체가 정규표현식과 일치하는지를 리턴한다. 

lookingAt() : public boolean lookingAt()
비교하려는 문자열이 정규표현식으로 시작하는지를 리턴한다. 
이때 언제나 문자열의 0번 인덱스부터 검색한다. 

replaceFirst() : public String replaceFirst(String replacement)
문자열 중 정규표현식과 일치하는 처음 요소의 값을 replacement로 대체한다. 

replaceAll() : public String replaceAll(String replacement)
문자열 중 정규표현식과 일치하는 모든 요소의 값을 replacement로 대체한다. 

reset() : public Matcher reset()
Matcher 의 정보를 리셋해서 0번 인덱스부터 다시 검색하게 한다. 

Matcher에는 문자열과 정규표현식과의 관계를 조사하는 다양한 
메서드가 제공된다. 
matches()는 Pattern의 matches()처럼 전체 문자열이 정규표현식에 부합되는지
검사한다. lookingAt()은 문자열의 시작이 정규표현식에 부합되는지는 
검사한다. find()는 이전 검색 결과의 다음 위치에서부터 검색한다. 
따라서 몇번이나 포함되어 있는지를 알수 있다. 
다음 그림은 주어진 문장에서 'Java'를 찾는 3가지 메서드의 검색 기준을 
표현한다. 

<---------------------------matches()---->
<----lookingAt
Java and JavaScript has no relation
<-->     <-->
find()   find()

matches()와 lookingAt(), find()의 차이 

start()는 찾은 요소의 시작 인덱스, end() 는 찾은 요소의 
(인덱스+1)을 리턴한다. 다음 그림은 주어진 문장에서 
문자열"Java"를 찾았을 때 start()와 end()의 위치이다. 

Java and JavaScript
"j" -> start(0) == 0
"Java"의 옆 공백 -> end() == 4

ex)
package ch12.regexp;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class UseMatcherTest {

	public static void main(String[] args) {
		String src = "A Java and JavaScript has no relation";
		// lookingAt()은 문자열의 시작만 표현식에 일치하면 되는데,
		// 일치 안해서 false
		
		String regexp = "Java";
		Pattern pattern = Pattern.compile(regexp);
		Matcher matcher = pattern.matcher(src);
		
		System.out.println("완전히 일치 되는가? " + matcher.matches());
		System.out.println("정규 표현식을 포함하는가? " + matcher.lookingAt());
		
		matcher.reset();
		int cnt = 0;
		while (matcher.find()) {
			cnt++;
			int start = matcher.start();
			int end = matcher.end();
			System.out.println(cnt + ":(" + start + "," + end + ")" + src.substring(start, end));
		}
		
		String replaced = matcher.replaceAll("Some");
		System.out.println(replaced);
	}
}
//
완전히 일치 되는가? false
정규 표현식을 포함하는가? false 
1:(2,6)Java
2:(11,15)Java
A Some and SomeScript has no relation

마지막으로 정규표현식을 이용해 비밀번호의 복잡성을 테스트하는 예를 
살펴보자.  여기서 비밀번호는 영문, 숫자, 특수문자 중 두가지 
이상의 조합으로 8자리 이상의 문자열이 필요하다고 가정한다. 

ex)
package ch12.regexp;

import java.util.regex.Pattern;

public class PasswordValidationTest {

	public static void main(String[] args) {
		String[] passwords = {
				"abcde한글124",
				"abc!12",
				"abcdefghij",
				"abcdef!@",
				"abc123!@#"
		};

		for (String password : passwords) {
			String lenReg = "[a-zA-Z0-9!@#$%]{8,}";
			String engReg = "[a-zA-Z]";
			String numReg = "[0-9]";
			String specReg = "[!@#$%]";
			System.out.print(password+"는 ");
			int has = 0;
			if (Pattern.matches(lenReg, password)) {
				has += Pattern.compile(engReg).matcher(password).find() ? 1 : 0;
				has += Pattern.compile(numReg).matcher(password).find() ? 1 : 0;
				has += Pattern.compile(specReg).matcher(password).find() ? 1 : 0;
				if (has < 2) {
					System.out.println("영문, 숫자, 특수문자 중 두 가지 이상이 조합되어야 합니다.");
				} else {
					System.out.println("적합한 패스워드 입니다.");
				}
			} else {
				System.out.println("영문, 숫자, 특수문자로 8자 이상이어야 합니다.");
			}
		}
	}
}
//
abcde한글124는 영문, 숫자, 특수문자로 8자 이상이어야 합니다.
abc!12는 영문, 숫자, 특수문자로 8자 이상이어야 합니다.
abcdefghij는 영문, 숫자, 특수문자 중 두 가지 이상이 조합되어야 합니다.
abcdef!@는 적합한 패스워드 입니다.
abc123!@#는 적합한 패스워드 입니다.

----------------------------------------------------
6. 숫자 관련 처리 

6.1 java.util.Random 클래스 

앞서 Math.random()을 통해서 주사위를 구현하는 예제를 작성해보았다. 
이 random()은 0~1 사이의 double을 리턴하기 때문에 원하는 정수를 
만들기 위한 과정이 추가로 필요했다. 하지만,
java.util.Random은 double은 물론 int 와 같은 다양한 타입의 
무작위 수를 리턴받을수 있다. 

java.util.Random의 주요메서드 

메서드명 : 선언부와설명

nextInt() : public int nextInt()
int 범위의 무작위 int 값을 리턴한다. 

public int nextInt(int bound)
0 <= x < bound 사이의 무작위 int를 리턴한다. 

nextLong() : public long nextLong()
long 범위의 무작위 long 값을 리턴한다. 

nextBoolean() : public boolean nextBoolean()
무작위로 true/false 를 리턴한다. 

nextFloat() : public float nextFloat()
0.0f <= x < 1.0f 사이의 무작위 float를 리턴한다. 

nextDouble() : public double nextDouble()
0.0 <= x < 1.0 사이의 무작위 double을 리턴한다. 

다음 예제는 주사위 놀이를 하면서 무작위로 한번더 던질수 있는 
기회를 얻도록 프로그래밍 한것이다. 

ex)
package ch12.number;

import java.util.Random;

public class RandomTest {
	public static void playDice(Random random) {
		int step = random.nextInt(6);
		System.out.println((step + 1) + "만큼 전진");
	}
	
	public static void main(String[] args) {
		Random random = new Random();

		playDice(random);
		if (random.nextBoolean()) {
			System.out.println("보너스 스테이지");
			playDice(random);
		}
	}
}
//
3만큼 전진
보너스 스테이지
3만큼 전진


----------------------------------------------------
6.2 java.math.BigInteger 클래스 

long 이 제법 큰 범위의 정수를 표현할수 있지만, 여전히 그 한계는 있다. 
Number를 상속받은 BigInteger는 말 그대로 큰 정수를 표현하는 클래스이다. 
이 클래스는 내부적으로 int [] 에 값을 저장한다. 따라서 배열의 크기만 
커지면 아무리 큰 수도 저장할수 있게 된다. 

(1) 객체의 생성과 값 활용 

BigInteger는 생성자에 정수 형태의 문자열을 넘겨주면서 생성 하는 것이 
일반적이다. 이후 xxValue()나 xxValueExact()처럼 exact 가 붙은 
메서드들을 제공한다. 여기서 xx는 int, long, float, double 타입이다. 
둘의 차이점은 BigInteger가 가진 값이 변환하려는 타입의 범위 내에 
있는가에 있다. xxValue()는 값이 타입의 범위는 넘는 경우 내부적으로
형변환 처리해서 표현 못할 부분을 잘라내고 표현하지만, 
xxValueExact()는 범위를 넘어가면 java.lang.ArithmeticException을 
발생시킨다. 

ex) BigInteger 객체의 생성과 값 활용.
String largeNum = "12345678901234567890" 
-> BigInteger bi = new BigInteger(largeNum);
-> long num = bi.longValue();
//-6101065172474983726
-> long num = bi.longValueExact();
// ArithmeticException

(2) 기본 연산 

BigDecimal은 연산자가 아닌 메서드를 이용해서 사칙연산(+,-,*,/)
과 모듈러스 연산(%)을 처리한다. 이 연산 결과는 다시 
BigDecimal을 리턴한다. BigDecimal은 String과 마찬가지로 변경
불가한(immutable) 클래스이므로 리턴된 객체는 원래의 객체와 다르다. 

BigInteger 클래스의 주요 메서드 

메서드 명 : 선언부와설명

add() : public BigInteger add(BigInteger val)
val 을 더한 결과를 값으로 갖는 BigInteger를 리턴한다. 

subtract() : public BigInteger subtract(BigInteger val)
val을 뺀 결과를 값으로는 갖는 BigInteger를 리턴한다. 

multiply() : public BigInteger multiply(BigInteger val)
val과의 곱을 값으로 갖는 BigInteger를 리턴한다. 

divide() : public BigInteger divide(BigInteger val)
val로 나눈 몫을 값으로 갖는 BigInteger를 리턴한다. 

remainder() : public BigInteger remainder(BigInteger val)
val로 나눈 나머지를 값으로 갖는 BigInteger를 리턴한다. 

mod() : public BigInteger mod(BigInteger m)
m으로 나눈 나머지를 값으로 갖는 BigInteger를 리턴한다. 
단, m이 음수면 ArithmeticException이 발생한다. 

ex)
BigInteger 클래스의 활용 예 

package ch12.number;

import java.math.BigInteger;

public class BigIntegerTest {
	public static void createAndConvert() {
		// long l1 = 12345678901234567890L; - long의 범위를 벗어나는 정수
		BigInteger bi = new BigInteger("12345678901234567890");
		System.out.println(bi.longValue()); // 값의 잘림
		try {
			System.out.println(bi.longValueExact());// 예외 처리
		} catch (Exception e) {
			System.out.println("범위를 벗어남");
		}
		System.out.println(bi.doubleValue());
	}

	public static void simpleOperation() {
		BigInteger b1 = new BigInteger("1234567890");
		BigInteger b2 = new BigInteger("9876543210");
		System.out.println("연산 결과: " + b2.subtract(b1));
		System.out.println("원판 불변: " + b2);
	}

	public static void main(String[] args) {
		createAndConvert();
		simpleOperation();
	}
}
//
-6101065172474983726
범위를 벗어남
1.2345678901234567E19
연산 결과: 8641975320
원판 불변: 9876543210

----------------------------------------------------
6.3 java.math.BigDecimal 클래스 

BigInteger가 정수형 기본형을 확장한 클래스라면 BigDecimal은 
실수형 기본형을 확장한 클래스이다. BigDecimal 클래스를 사용하는 
주요 이유는 정확도에 있다. 앞서 실수형의 연산에서 배웠듯이 
실수는 정확하지 않다. 

ex)
double d1 = 2.0;
double d2 = 1.1;
double d1 = d1 - d2;
System.out.println("결과비교:d3: " +d3);
//결과비교 : d3:0.899999999999999

BigDecimal을 이용하면 실수의 연산을 정확히 처리할수 있다. 

(1) 객체의 생성과 값 활용 
BigDecimal은 여러모로 BigInteger와 유사하다. Number 클래스를 
상속받았으며 내부적으로 char[]에 값을 저장하며 변경 불가능한
클래스이다.

객체를 생성할때는 문자열을 이용할수도 있고 기본형을 이용할수도 있다.
주의할 점은 기본형을 이용할 경우 정확도를 기대할수 없다는 점이다. 
따라서 가급적 문자열을 이용해서 객체를 만들도록 하자.

ex)
BigDecimal b1 = new BigDecimal(2.0);
// 여전히 부정확한 연산 결과 발생 
BigDecimal b1 = new BigDecimal("2.0");

값의 활용이나 기본 연산자의 경우 BigInteger와 유사한 형태의 
메서드들을 제공하므로 관련 내용은 BigInteger의 설명을 참조한다. 

ex2)
package ch12.number;

import java.math.BigDecimal;

public class BigDecimalTest {

	public static void main(String[] args) {
		double d1 = 2.0;
		double d2 = 1.1;
		System.out.println(d1-d2);
		
		BigDecimal bd1 = new BigDecimal("2.0");
		BigDecimal bd2 = new BigDecimal("1.1");
		System.out.println(bd1.subtract(bd2));

		BigDecimal bd3 = new BigDecimal(2.0);
		BigDecimal bd4 = new BigDecimal(1.1);
		System.out.println(bd3.subtract(bd4));
	}
}
//
0.8999999999999999
0.9
0.899999999999999911182158029987476766109466552734375


===================================
[자바 해바라기 정리] 13 컬렉션 프레임워크 

컬렉션 프레임워크는 java.util에 있는 일련의 클래스들로 자바에서 
자료구조를 담당한다. 
자료구조란(data structure) 전산학에서 대량의 데이터를 효율적으로
이용할수 있도록 컴퓨터에서 데이터를 추가, 조회, 수정, 삭제 
(CRUD - Create, Retrieve, Update, Delete)하는 방식을 말한다. 
프로그램이라는 것이 데이터를 비즈니스 로직에 따라 가공해서 
보여주는 것이기 때문에 자료구조는 매우 활용도가 높다. 자바에서는 
다양한 컬렉션 프레임워크 클래스들을 제공해주는데 각 클래스의 
특징을 이해하고 용도에 맞는 컬렉션 API를 사용하는 것이 중용하다.


1. 컬렉션 프레임워크의 특징 

1.1 컬렉션 프레임워크 소개 

프로그래밍하면서 가장 쉽게 접할 수 있는 자료구조는 배열이다. 
하지만 배열은 너무 원시적이서 사용하기가 번거롭다. 예를들어
배열은 한번 크기가 정해지면 크기를 늘릴수 없고, 배열에 데이터가 
있는 상태에서 중간에 하나를 끼워 넣으면 끼워 넣으려는 자리의 
뒤쪽에 있던 자료들을 모두 한 칸씩 뒤로 움직여야 한다. 
마찬가지로 중간의 데이터를 지우려면 그 뒤쪽에 있던 자료들은 모두 
앞으로 한 칸씩 움직여야 한다. 

컬렉션 프레임워크는 기본적으로 이 배열을 확장해서 손쉽게 데이터를 
관리할수 있는 API를 제공해준다. 여기서 프레임워크란 잘 짜인 틀에
의해 만들어진 클래스들의 모임을 의미한다. 초창기 자바의 자료 구조는 
Vector, Stack, Hashtable, Properties 등이 있었다. 
이것들은 클래스 기반으로 연관 관계가 별로 없었다. 하지만 JDK 1.2 
버전 이후 등장한 컬렉션 프레임워크는 잘 짜인 인터페이스 기반의 관계를 
가지고 있기 때문에 몇 가지만 잘 익혀 놓으면 편하게 다양한 종류의 API를 
사용할 수 있다. 

컬렉션 프레임워크의 구성 

List->Collection->Iterable
Set->Collection->Iterable

3대 주요 인터페이스
List , Set , Map 

컬렉션 프레임워크는 크게 List, Set, Map 의 3가지 계열로 
구성된다. List와 Set은 Collection을 상속받았으므로 유사한 
메서드들이 사용된다. 
먼저 3가지 계열의 특징에 대해 알아보자. 

-List 계열 
List는 순서가 있는 데이터의 집합이다. 순서가 있기 때문에 
동일한 데이터의 중복이 허락된다. 동일 데이터의 값이라고 해도 
'몇 번째'라는 식으로 접근하면 찾을수 있기 때문이다. 
대표적인 List 계열의 구현체는 ArrayList나 
LinkedList, Stack , Vector가 있다. 

-Set 계열 
Set 은 순서를 유지하지 않는 데이터 집합이다. List 와 달리 
순서가 없기 때문에 '몇 번째'라는 말을 할수 없어 동일한 
데이터의 중복을 허락하지 않는다. 대표적인 Set 계열의 
구현체는 HashSet, TreeSet이 있다. 

-Map 계열 
Map 계열은 키와 값의 쌍으로 데이터를 관리하는 집합이다. 
이때 키는 중복되지 않고 값은 종복이 허락된다. 
대표적인 Map 계열의 구현체는 HashMap이나 TreeMap, Hashtable,
Properties가 있다. 

----------------------------------------------------
1.2 Collection 인터페이스

500 2/43

Collection 인터페이스는 List 와 Set 계열의 공통 조상으로 
다음의 메서드들이 정의되어 있다. 

Collection의 주요 메서드 

메서드 명 : 선언부와설명

add() : boolean add(E e)
요소 e를 컬렉션에 저장하고 성공 여부를 반환한다. 

addAll() : boolean addAll(Collection< ? extends E> c)
다른 컬렉션인 c의 모든 요소를 컬렉션에 추가하고 성공 여부를 
리턴한다. 

clear() : void clear()
컬렉션이 가지고 있는 모든 요소를 삭제한다. 

contains() : boolean contains(Object o)
컬렉션이 o 를 요소로 가지고 있는지 리턴한다. 

containsAll() : boolean containsAll(Collection<?> c)
다른 컬렉션인 c의 모든 요소가 컬렉션에 포함되어 있는지 
리턴한다.

equals() : boolean equals(Object o)
컬렉션과 o 가 같은 내용을 포함하고 있는지 비교하도록 재정의 
되었다. 

isEmpty() : boolean isEmpty()
컬렉션이 비어 있는지 확인한다. 

iterator() : IteratorFor<E> iterator()
컬렉션의 IteratorFor를 리턴한다. Iterator는 Collection에서 
자료를 조회하기 위한 표준 인터페이스이다. 

remove() : boolean remove(Object o)
컬렉션에서 o 를 제거하고 성공여부를 리턴한다. 

removeALl() : boolean removeAll(Collection<?> c)
다른 컬렉션인 c 의 모든요소를 컬렉션에서 제거하고 성공여부를 리턴한다. 

retainAll() : boolean retainAll(Collection<?> c)
다른 컬렉션 c에 포함된 객체는 남기고 다른 객체들은 제거한다. 
이 작업으로 컬렉션에 변화가 생기면 true, 그렇지 않으면 
false를 리턴한다. 

size() : int size()
컬렉션에 저장된 요소의 개수를 리턴한다. 

toArray() : Object[] toArray()
컬렉션의 요소들을 Object[] 형태로 리턴한다. 

<T> T[] toArray(T[] a)
컬렉션의 요소들은 T[] 형태로 리턴한다. 

Collection의 메서드들은 기능적으로 분류해보면 다음과 같다. 

분류 : Collection

추가 : add(E e) , addAll(Collection< ? extends E> c)

조회 : contains(Object o) , containsAll(Collection<?> c)
equals(), isEmpty(), iterator(), size()

삭제 : clear(), removeALl(Collection<?> c)
retainAll(Collection<?> c)

수정 : 없고 

기타 : toArray()

과거의 컬렉션 API들은 모든 요소를 원시 타입의 Object 형태로 저장했지만, 
8장에서 배운 제너릭 개념이 등장하는 JDK 5 버전부터는 타입 파라미터를 
이용하는 형태로 변경되었다. 


----------------------------------------------------
2. List 계열의 컬렉션 

2.1 List 인터페이스

List 계열은 순서, 즉 인덱스 기반으로 데이터를 저장한다.
실생활에서 List 가 적용된 예를 많이 생각해볼 수 있다. 
수첩에 해야 할 일들을 순서대로 적거나 은행에서 대기표를 
받아서 기다리기도 한다. 

List는 같은 데이터가 들어오더라도 인덱스를 이용해 구별할수 있어 
데이터의 중복이 허용되는 특징을 갖는다. 
여기서 같은 데이터라는 표현은 객체의 equals() 메서드가 
true를 리턴하고 객체가 갖는 hashCode() 값이 같을 때를 이야기한다. 
또한, List에는 null 값도 저장할 수 있다. 

다음은 n개의 문자열을 관리하는 List의 예를 살펴본것이다. 

0 : 0x100 -> Hi 
1 : 0x200 -> Hello 
2 : 0x200 -> Hello 
:
n-1 : null 

Collection 메서드의 기능별 분류 

위에 보면 인덱스는 0부터 n-1 까지 존재하며 각각의 인덱스에 관리하는 객체의 
참조값이 연결된다. 인덱스 1번과 2번의 'Hello'라는 문자열은 동일한 객체이지만 
중복해서 저장할수 있다. 

List 인터페이스는 Collection을 상속받았으며 추가로 인덱스를 사용할수 있는 
메서드들이 선언되어 있다. 

List 의 주요 메서드 

add() : void add(int index, E element)
index 위치에 element 를 저장한다. 

addAll() : boolean addAll(int index, Collection<? extends E> c)
index 위치부터 c의 요소들을 추가한다. 단 c는 E의 하위 요소들을 
저장하고 있어야 한다. 

get() : E get(int index)
index 위치에 저장된 요소를 리턴한다. 

indexOf() : int indexOf(Object o)
저장된 객체 o의 인덱스를 리턴한다. 동일한 객체가 여러개일 경우는 
맨 처음 발견한 객체의 인덱스를 리턴하고 객체가 없을 경우 -1이 
리턴된다. 

lastIndexOf() : int lastIndexOf(Object o)
List에 동일한 객체(o)가 여러 개 있을때 마지막 요소의 인덱스를 
리턴한다. 만약 객체가 없을 경우 -1을 리턴한다. 

listIterator() : ListIterator <E> listIterator()
List의 요소를 탐색할 수 있는 ListIterator를 리턴한다. 

remove() : E remove(int index)
index에 위치한 객체를 리스트에서 제거하고 리턴한다. 

set() : E set(int index, E element)
index의 요소를 element로 대체한다.

subList() : List<E> subList(int fromIndex, int toIndex)
fromIndex <= x < toIndex의 요소들로 구성된 새로운 List를 
리턴한다. 

List 까지 등장한 메서드를 기능적으로 분류하면 다음과 같다. 

분류 : Collection : List 

추가 :add (E e) : add (int index, E element)
추가 :addAll(Collection<? extends E> c) : 
addAll(int index, Collection<? extends E> c)

조회 : contains(Object o), containsAll(Collection<?> c)
, equals(), isEmpty(), iterator(), size()
: List 
get(int index) , indexOf(Object o), lastIndexOf(Object o)
listIterator()

삭제 : clear(), removeAll(Collection<?> c)
retainAll(Collection<?> c)
: List 
remove(int index)

수정 : 
List 
set(int index, E element)

기타 : toArray() : subList(int fromIndex, int toIndex)

List에서 범위를 넘어가는 인덱스를 사용하면 배열과 유사하게 
IndexOutOfBoundsException을 발생시킨다.

List 인터페이스의 구현체로는 Vector, Vector를 상속받은 
Stack, ArrayList , LinkedList 등이 있다. 

과거 버전 - List<E> 계열의 클래스 관계도 
Stack -> Vector ->List
ArrayList -> List 
LinkedList -> List 

이중 Vector와 Stack은 초창기부터 있던 버전이며 멀티스레드 환경에서 
안정적이지만 성능이 좋지 않다. 일반적으로는 ArrayList나 LinkedList를 
사용하는 것을 권장한다. 스레드와 관련된 내용은 14장에서 다룬다. 

----------------------------------------------------
2.2 ArrayList<E>

ArrayList<E>는 습관처럼 자주 사용되는 클래스로 활용도가 아주 높다. 
컬렉션 클래스들은 대부분 제너릭이 적용되어 있다. ArrayList<E>도 
예외는 아니므로 객체를 생성할 때 타입 파라미터를 넘겨주는 것이 좋다. 
또한, 객체를 참조할때 클래스를 이용한 참조보다는 인터페이스를 이용해서 
참조하는 것이 프로그램의 유연성을 좋게 한다. 

//원시 타입을 사용하는 형태 
List list = new ArrayList();

//제너릭을 적용한 형태 
List<String> strList = new ArrayList<>();

ArrayList에는 기본 생성자와 추가로 파라미터를 갖는 두개의 생성자를 
제공한다. 

public ArrayList()
public ArrayList(int initialCapacity)
public ArrayList(Collection<? extends E> c)

기본 생성자는 기본 용량이 0에서 시작한다. 반면 int를 받는 
생성자는 기본 용량을 파라미터인 initialCapacity로 잡는다. 
StringBuilder에서와 마찬가지로 크기와 용량은 다르다는 것의 유의하자.
컬렉션에서 '크기란(=size)', '실제로 관리하는 데이터의 크기'이다. 
반면 '용량(capacity)'은 '몇개까지 데이터를 관리할수 있는가?'와 
관련된다. 

생성자 중 int를 파라미터로 받는 생성자를 분석해 보면 ArrayList의
정체를 명확히 알수있다.

ex)
public ArrayList(int initialCapacity){
if (initialCapacity > 0) {
this.elementData = new Object[initialCapacity];
}else if (initialCapacity == 0) {
this.elementData = EMPTY_ELEMENTDATA;
}else {
throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity);
}
}

생성자를 통해 전달된 값은 내부적으로 elementData, 즉 
Object[]의 length로 사용된다. 이 elementData는 ArrayList<E>에서 
객체를 저장할수 있는 배열이다. ArrayList는 Array 즉 배열을 이용한 
List 인것이다. 

배열의 특징 중 하나가 한 번 결정된 크기는 변경이 불가능하다는 점이다. 
ArrayList도 배열을 기반으로 만들어졌지만, 용량과 상관없이 add()를 호출하면 
데이터는 잘만 들어간다. 이 비밀은 add()가 호출될 때 내부적으로 호출되는 
grow()의 소스를 살펴보면 쉽게 풀린다. 
다음 코드를 보면  grow()는 Arrays.copyOf()를 이용해서 기존 작은 배열인 
elementData를 newCapacity 용량의 큰 배열로 대체하는 것을 볼수 있다. 

ex)
private void grow(int minCapacity) {
int oldCapacity = elementData.length; // 기존 배열의 크기 
int newCapacity = oldCapacity + (oldCapacity >> 1);
if (newCapacity - minCapacity < 0)
newCapacity = minCapacity;
//-------------------------------------------------------
if ( newCapacity - MAX_ARRAY_SIZE > 0)
newCapacity = hugeCapacity(minCapacity); //필요한 배열의 크기 
elementData = Arrays.copyOf(elementData, newCapacity); 
//---------------------------------------- 큰 배열로 대체 
}

다음은 ArrayList<E>를 이용한 자료 처리의 예.

ex)
package ch13.list;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class ArrayListTest {
	List<Object> list = new ArrayList<>();
	
	List<Integer> integers = Arrays.asList(1, 2, 3, 4, 5);

	public void createTest() {
		list.add("Hello");
		list.add("Hello"); // 동일 데이터 추가
		list.add(null); // null 추가
		list.addAll(integers); // 다른 Collection 요소 추가
		list.add(integers); // 다른 Collection 추가
		list.add(0, new Object()); // 끼워 넣기
		System.out.println("추가 후 내용 출력: " + list);
	}

	public void retrieveTest() {
		// 반복을 이용한 요소 조회
		for(int i=0; i<list.size(); i++) {				// 리스트의 크기 조회
			System.out.println(i+" : "+list.get(i));	// 특정 인덱스의 객체 조회
		}
		// 포함 여부의 활용
		if (list.contains("Hello")) {	// 객체의 포함 여부 
			System.out.println("Hello의 위치는: " + list.indexOf("Hello"));	// 객체의 위치 조회
		}
		// 서브 리스트 활용
		List<Object> sub = list.subList(3, 5);
		System.out.println("sub의 내용: "+sub);
		System.out.println("sub의 내용을 다 가지고 있는가? " + list.containsAll(sub));
	}

	public void updateTest() {
		list.set(1, "updated");
		System.out.println("업데이트 후: "+list);
	}

	public void deleteTest() {
		list.remove(0);			// 특정 위치의 객체 삭제
		list.remove("Hello");	// 특정 객체가 있다면 처음 객체 삭제
		// 타입이 Integer인 경우 삭제
		for (int i = 0; i < list.size(); i++) {
			if (list.get(i) instanceof Integer) {
				list.remove(i);
			}
		}
		// Iterator 추가해서 해보기
		// Iterator<Object> iter = list.iterator();
		// while (iter.hasNext()) {
		// 처음 부터 끝까지 한번에 하나씩 밖에 못가져온다. 
		// (1) hasNext() : 다음요소에 읽어 올 요소가 있는지?> 확인하는 메소드
		// 있으면 true 없으면 false 를 반환. 
		// next() : 다음 요소를 가져온다. 
		// remove() : next() 로 읽어온 요소를 삭제한다. 
		//	Object s = iter.next();
		//	if (s instanceof Integer) {
		//		iter.remove();
		//	}
		//  }
		// 그러면 정수는 다 삭제 됨. 
		System.out.println("삭제 후 : " + list);
		list.clear();// 리스트 초기화
		System.out.println("초기화 후 : " + list);
	}

	public static void main(String[] args) {
		ArrayListTest alt = new ArrayListTest();
		alt.createTest();
		alt.retrieveTest();
		alt.updateTest();
		alt.deleteTest();
	}
}
//
추가 후 내용 출력: 
[java.lang.Object@2c13da15, Hello, Hello, null, 1, 2, 3, 4, 5, [1, 2, 3, 4, 5]]
0 : java.lang.Object@2c13da15
1 : Hello
2 : Hello
3 : null
4 : 1
5 : 2
6 : 3
7 : 4
8 : 5
9 : [1, 2, 3, 4, 5]
Hello의 위치는: 1
sub의 내용: [null, 1]
sub의 내용을 다 가지고 있는가? true
업데이트 후: [java.lang.Object@2c13da15, updated, Hello, null, 1, 2, 3, 4, 5, [1, 2, 3, 4, 5]]
삭제 후 : [updated, null, 2, 4, [1, 2, 3, 4, 5]]
초기화 후 : []

----------------------------------------------------
2.3 배열과 ArrayList, LinkedList의 특징 

508 10/43

배열은 우리가 알고 있는 가장 기본적인 형태의 자료 구조로 인덱스를 기반으로 
하는 구조가 간단하고 배열 내부에서의 접근 속도가 매우 빠르다. 

반면 배열은 크기를 변경할 수 없고 기존 배열의 크기보다 더 많은 데이터를 
추가하기 위해서는 새로운 배열을 만들고 기존 값들을 복사해야 한다. 
또한, 비순차적인 데이터의 추가, 삭제에는 더 많은 시간이 걸린다. 

예를들어 0~4까지의 index를 가진 배열이 있다고 할 때 1번 인덱스 요소를 
빼고 2와 3사이에 5라는 값을 끼워 넣는다고 생각해보자. 

일단 1번 데이터가 없어지며 뒤에 있던 2,3,4 번은 앞으로 한자리씩 
이동한다. 5가 새로 추가되기 위해서는 3,4 번이 다시 뒤로 움직여야 한다.

배열을 기반으로 하는 ArrayList도 태생적으로 배열의 장단점을 그대로 가질 수 
밖에 없다. 

이런 불합리성을 개선하기 위해 등장한 또 다른 리스트가 있는데 바로 
LinkedList<E> 이다. LinkedList는 각 요소를 Node(노드)로 정의하며
Node는 다음 요소의 참조값과 데이터로 구성된다. 
각 Node는 다음 Node에 대한 링크 정보를 가지며 데이터를 연속으로 
구성할 필요가 없어진다. 
ex)
LinkedList
      ->0x100 -> 0x200 ->0x500 -> 0x600 
0x100 ->0x200 -> 0x500 ->0x600 -> null 
         0          1       2        3
		 	 
위와 같은 자료 구조에서 만약 1을 삭제하고 2와 3사이에 4를 
추가한다면 어떻게 될까?

ex2)
LinkedList 에서의 추가와 삭제 
0x100 -> 
0x100 : 0x200 (->0x500으로 변경) :0
0x200 -> 0x500 : (삭제) :1
0x500 -> 0x600 : (->0x700 으로 변경) :2
0x700 -> 0x600 : (추가) :4
0x600 -> : null : 3

509 11/43

위에서 1을 삭제하려면 1을 참조하던 0번의 참조 링크를 
0x500으로 바꾸기만 하면된다. 이제 0x200번지는 G.C의 
대상이 될것이다. 2와 3사이에 4를 넣기 위해서는 3을 
바라보던 2의 링크를 새로운 4를 바라보도록 하고 4가 3을
바라보도록  링크를 조절하기만 하면 끝이다. 
ArrayList가 전체적으로 요소들이 움직였던 것에 비해 
훨씬 가볍게 동작한다. 

이제 LinkedList를 사용해보기 위해 LinkedList의 API를 
다시 알아봐야 할까? 결론은 거의 그렇지 않다. 앞선 예제에서 
ArrayList를 테스트할 때 코드에는 ArrayList가 객체 생성할 때 
말고는 나온 적이 없다. 단지 List의 메서드들을 사용했고 
LinkedList 역시 List의 구현체이므로 객체 생성부분만 바꾸면 
ArrayList에서 LinkedList로 대체된다. 이것이 인터페이스를
이용했을 때의 장점이다. 

ex) 
//List 의 구현체로 ArrayList 사용 
List<Object> list = new ArrayList<>(); 
//List 의 구현체로 LinkedList 사용 
List<Object> list = new LinkedList<>();

ArrayList와 LinkedList를 썼을때 성능상에 어떤 차이가 있는지 
알아보자. 다음 예제에는 ArrayList와 LinkedList를 이용해 
순차적/비순차적 데이터 검색과 추가 과정을 거쳐 성능을 확인한다. 

ex)
package ch13.list;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class ArrayVsLinkedTest {
	private static void addTest(String testcase, List<Object> list) {
		long start = System.nanoTime();
		for (int i = 0; i < 1000000; i++) {
			list.add(new String("Hello"));
		}
		long end = System.nanoTime();
		System.out.println(testcase + " 소요시간 : " + (end - start));
	}

	private static void addTest2(String testcase, List<Object> list) {
		long start = System.nanoTime();
		for (int i = 0; i < 100000; i++) {
			list.add(0, new String("Hello"));
		}
		long end = System.nanoTime();
		System.out.println(testcase + " 소요시간 : " + (end - start));
	}

	private static void accessTest(String testcase, List<Object> list) {
		long start = System.nanoTime();
		for (int i = 0; i < 100000; i++) {
			list.get(i);
		}
		long end = System.nanoTime();
		System.out.println(testcase + " 소요시간 : " + (end - start));
	}

	public static void main(String[] args) {
		ArrayList<Object> alist = new ArrayList<Object>();
		LinkedList<Object> llist = new LinkedList<Object>();

		addTest("순차적 추가: ArrayList", alist);
		addTest("순차적 추가: LinkedList", llist);

		addTest2("중간에 추가: ArrayList", alist);
		addTest2("중간에 추가: LinkedList", llist);

		accessTest("데이터 접근: ArrayList", alist);
		accessTest("데이터 접근: LinkedList", llist);
	}
}
//
순차적 추가: ArrayList 소요시간 : 93209700
순차적 추가: LinkedList 소요시간 : 154365000
중간에 추가: ArrayList 소요시간 : 109729447400
중간에 추가: LinkedList 소요시간 : 5186700
데이터 접근: ArrayList 소요시간 : 3905700
데이터 접근: LinkedList 소요시간 : 15382276300
시간이 조금 걸림 

둘의 성능을 표로 비교하면 다음과 같다. 

구분 : 순차 추가/수정/삭제 : 비순차 추가/수정/삭제 : 조회 

ArrayList : 빠름 : 느림 : 빠름 
LinkedList : 느림 : 빠름 : 느림 

소량의 데이터를 가지고 사용하는 경우에는 차이가 없지만, 일반적으로
데이터를 정적으로 사용할 경우, 즉 단순 조회용인 경우는 ArrayList가 
유리하고 반대로 동적인 추가/삭제가 많은 경우는 LinkedList가 유리하다. 

결론적으로 특정 클래스가 좋고 나쁨은 없다. 용도에 적합하게 사용해야 한다. 

----------------------------------------------------
2.4 정렬 

많은 요소 중에서 데이터를 찾다 보면 정렬을 통해 순서를 지정할 필요가 있다. 
이때 Collection 의 sort() 메서드가 사용된다. 

정렬을 위한 Collection의 sort() 

메서드명 : 선언부와설명
sort() : public static < T extends Comparable<? super T>> void sort(List<T> list)
기본 정책에 의해서 list의 요소를 정렬한다. 

public static <T> void sort(List<T> list, Comparable<? super T> c)
c에 의거해서 list의 요소를 정렬한다. 

첫번째 sort() 메서드에는 타입 파라미터가 복잡하게 설정돼 있는데 2단계로 
살펴보자. 먼저 메서드 레벨에 선언된 T는 Comparable을 상속받아야 하고 
메서드의 파라미터로 T가 타입 파라미터로 전달된 List가 필요하다. 
다음으로 Comparable은 클래스 레벨에 타입 파라미터가 있으며 T의 조상이 
설정돼야 한다. 예를 들어 Integer나 String 같은 클래스가 T의 좋은 
예가 될수 있다. 

ex)
public final class Integer extends Number implements Comparable<Integer> {}
public final String implements java.io.Serializable, Comparable<String>,
CharSequence{}

Comparable은 객체를 비교할 수 있는 기준인 compareTo() 메서드가 선언돼 있고 
String이나 Integer는 각각 사전 순으로 요소를 정렬하도록 구현돼 있다. 
그런데 만약 사전 순이 아니라 자리수를 기준으로 정렬하려면 어떻게 해야 
할까? String은 final 클래스 이므로 compareTo()를 재정의 할수 도 없는 일이다. 

이때는 두번째 sort() 메서드를 사용한다. 이 메서드는 호출할 때마다 
Comparator<T> 타입의 객체를 넘겨주면 된다. 

Comparator는 compare() 메서드를 통해 정렬의 방식을 결정한다. 
compare()는 T 타입의 객체 두개를 받아서 정렬을 위한 알고리즘을 
작성한다. 

ex)
public int compare ( T o1 , T o2)

Comparable의 compareTo()나 Comparator의 compare() 모두 int를 
리턴하는데 양수가 리턴되면 순서가 바뀌어야 하고, 음수가 리턴되면
순서를 그대로 유지한다. 0이 리턴 될 때 List<E> 계열에서는 
음수처럼 순서를 유지한다. 하지만 뒤에 살펴볼 TreeSet<E>
계열에서는 다르다. 

다음은 문자열의 길이를 비교하는 Comparator<E> 의예이다.

ex)
package ch13.list;

import java.util.Comparator;

public class StringLengthComparator implements Comparator<String> {
	@Override
	public int compare(String o1, String o2) {
		int len1 = o1.length();
		int len2 = o2.length();
		return len1 - len2;
	}
}

다음은 위의 StringLengthComparator를 이용해서 정렬을 처리하는 
예이다. 

ex2)
package ch13.list;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class ListSortTest {
	public static void main(String[] args) {
		List<String> names = Arrays.asList("토르", "캡틴아메리카", "스파이더맨", "아이언맨");
		Collections.sort(names);
		System.out.println("알파벳 순 정렬 결과: "+names);
		Collections.sort(names, new StringLengthComparator());
		System.out.println("글자수 정렬 결과: "+names);
	}
}
//
알파벳 순 정렬 결과: [스파이더맨, 아이언맨, 캡틴아메리카, 토르]
글자수 정렬 결과: [토르, 아이언맨, 스파이더맨, 캡틴아메리카]

주의,

Comparator의 compare()를 재정의할 때 상황에 따라 주의해야 한다. 
다음과 같이 구현하면 어떨까?

ex)
public int compare(Integer num1, Integer num2) {
return num1 - num2;
}

아주 간단히 num1과 num2를 정렬하는 메서드처럼 보인다. 하지만, 
만약 num1이 int의 최댓값이고 num2가 음수라면 어떤 결과가 발생할까?
정수의 오버플로가 발생해서 예상치 못했던 정렬 결과가 나올 것이다. 
따라서 위 코드는 다음과 같이 변경하는 것이 좋다. 

ex2)
public int compare(Integer num1, Integer num2){
if(num1 > num2) {
return 1;
}else if(num1 < num2){
return -1;
}else{
return 0;
}
}

물론 StringLengthComparator는 문자열의 길이가 
음수일 경우는 없기 때문에 상관없다. 

----------------------------------------------------
2.5 List<E>를 이용한 로또 게임 

List<E>의 특성을 이용해서 로또 게임을 만들어보자. 
로또는 1~45까지의 숫자가 적힌 공 중에서 당첨 공 6개와 
보너스 공 1개를 뽑는다. 이 공들은 중복되어 뽑힐 수 없는 
점만 주의하면 된다. 

ex)

package ch13.list;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;

class ListLotto {
	Integer bonus;
	List<Integer> lotto = new ArrayList<>();

	public void setup() {
		Random random = new Random();
		while (bonus==null) {
			int num = random.nextInt(45) + 1;
			if (!lotto.contains(num)) {
				if (lotto.size() < 6) {
					lotto.add(num);
				} else {
					bonus = num;
				}
			}
		}
		Collections.sort(lotto);
	}
	
   //객체의 내용을 출력하도록  toString()을 재정의 
   
	@Override
	public String toString() {
		return "당첨번호: " + lotto + ", 보너스: " + bonus;
	}
}

public class ListLottoTest {

	public static void main(String[] args) {
		ListLotto lotto = new ListLotto();
		lotto.setup();
		System.out.println(lotto);
	}
}
// Random 객체를 이용하므로 결과는 매번 다름 
당첨번호: [2, 19, 31, 32, 33, 44], 보너스: 21


----------------------------------------------------
3. Set 계열의 컬렉션 

3.1 Set 인터페이스

Set 계열은 주머니에 순서 없이 데이터를 넣는 형태이다. Set은 순서가 
없어서 리스트와 달리 동일한 데이터가 들어오게 되면 객체들을 구별할수가
없다. 따라서 데이터의 종복을 허용하지 않으며 이것은 효율적인 종복 데이터 
제거 수단이 된다. 이때 동일한 데이터인지 판단 여부는 equals() 메서드의 
리턴값이 true이고 hashCode() 값이 같은 객체를 이야기한다. 

ex)
0x100 -> Hi 
0x200 -> Hello 
null 

Hello -> .. : 올수 없다. 

Set 계열의 데이터 저장 

Set 계열에는 가장 많이 사용되는 형태인 HashSet 과 정렬 기능을 내장하고 
있는 TreeSet 이 있다. 

ex) Set 계열의 클래스 관계도 
HashSet -> Set 
TreeSet -> NavigableSet -> SortedSet -> Set

Set 계열은 인덱스가 없기 때문에 위치 기반으로 데이터를 가져올수 없다. 
Set이 가진 요소의 목록을 사용하기 위해서는 iterator()가 반환하는 
Iterator 객체를 사용한다. 
Iterator는 Collection에 저장된 요소에 접근하기 위해 사용하며, 표준 인터페이스로 
데이터를 읽는 방법을 제시한다. 

Iterator의 주요 메서드 

메서드명 : 선언부와설명

hasNext() : boolean hasNext()
가져올 다음 요소가 있는지 여부를 리턴한다. 

next() : E next()
가져올 다음 요소가 있다면 그 요소를 리턴한다

remove() : void remove()
현재 위치의 요소를 삭제한다. 

다음 예는 Set에서 Iterator를 획득 후 Set의 내용을 출력하는 
방식을 보여준다. 

ex)
Iterator<Object> iter = set.iterator();
while (iter.hasNext()){
Object obj = iter.next();
System.out.println(obj);
}

또는 간단히 인덱스를 사용하지 않는 for ~ each문을 이용할수도 있다. 

for (Object sobj : set) {
System.out.println(sobj);
}

어느 모로 보나, 향상된 for 문의 형태가 훨씬 간단하다. 
하지만 Iterator를 이용하는 문도 활용도가 있기 때문에 
기억해 두도록 하자. 

참고로 이 Iterator는 단방향으로만 사용된다. Iterator를 상속받은 
ListIterator는 양방향으로 사용이 가능한데 hasPrevious()와 
previous() 메서드가 제공된다. 단, ListIterator는 List 계열에서만 
사용이 가능하다. 

ListIterator가 추가로 갖는 메서드 

메서드명 : 선언부와설명

hasPrevious() : boolean hasPrevious()
가져올 이전 요소가 있는지 여부를 리턴한다. 

previous() : E previous()
가져올 이전 요소가 있다면 그 요소를 리턴한다. 

remove() : void remove()
현재 위치의 요소를 삭제한다. 


----------------------------------------------------
3.2 HashSet<E>

Set<E>의 대표적 구현체인 HashSet<E>을 이용한 자료 관리를 예제를 통해 
알아보자. 이 예제에서는 Phone이라는 사용자 정의 클래스를 HashSet에 
추가해보고 중복 데이터가 어떻게 제거되는지 살펴보자. 

Phone 클래스는 String 타입의 number가 선언된 아주 간단한 클래스이다. 
현실 세계에서 전화번호는 하나만 존재하는데, 즉 같은 전화번호는 없다. 
Set<E>에서는 어떨지 알아보자. 

ex)
package ch13.set;

public class Phone {
	String number;

	public Phone(String number) {
		this.number = number;
	}

	@Override
	public String toString() {
		return "전화 번호: " + this.number;
	}
}

본격적으로 HashSet<E>에 데이터를 추가/조회/수정/삭제해보자. 
List<E> 계열과 비교하여 특이한 점은 수정하는 메서드가 없다는 점이다. 
List<E>는 인덱스 위치의 요소를 수정했지만, Set<E>계열에서는 
인덱스가 없기 때문에 수정이 불가능하다. 인덱스를 사용하지 않는 
나머지 메서드들은 어차피 Collection<E> 을 구현한 것이기 때문에 
동일하게 사용할수 있다. 

ex2)
package ch13.set;

import java.util.HashSet;
import java.util.Set;

public class HashSetTest {
	Set<Object> hset = new HashSet<Object>();

	private void addMethod() {
		this.hset.add(Integer.valueOf(1));
		this.hset.add("Hello");
		this.hset.add("Hello");
		this.hset.add(null);
		this.hset.add(1);
		this.hset.add(new Phone("010-000-1234"));
		this.hset.add(new Phone("010-000-1234"));
		System.out.println("데이터 추가 결과: " + this.hset);
	}

	private void retrieveMethod() {
		System.out.println("데이터 개수: " + this.hset.size());

		for (Object sobj : this.hset) {
			System.out.println("데이터 조회: " + sobj);
		}
	}

	private void removeMethod() {
		this.hset.remove("Hello");
		System.out.println("데이터 삭제 결과: " + this.hset);
	}

	public static void main(String[] args) {
		HashSetTest hst = new HashSetTest();
		hst.addMethod();
		hst.retrieveMethod();
		hst.removeMethod();
	}
}
//
데이터 추가 결과: [null, 1, Hello, 전화 번호: 010-000-1234, 전화 번호: 010-000-1234]
데이터 개수: 5
데이터 조회: null
데이터 조회: 1
데이터 조회: Hello
데이터 조회: 전화 번호: 010-000-1234
데이터 조회: 전화 번호: 010-000-1234
데이터 삭제 결과: [null, 1, 전화 번호: 010-000-1234, 전화 번호: 010-000-1234]

출력된 결과를 살펴보면 두 가지 흥미로운 점이 있다. 
첫째는 Integer.valueOf(1)과 1, "Hello"와 "Hello"는 중복된 데이터로 
간주되어 출력 결과에는 하나만 존재한다. 하지만, Phone 객체는 2개가 
다 들어 있음을 알수 있다. 
둘째는 출력된 요소의 순서이다. 기본적으로 Set<E>에 add()한 순서가 
아닐 뿐 아니라 실행할 때마다 다른 결과가 나올 수도 있다. 

String이나 Integer 등은 중복되는 데이터가 잘 제거 되었지만, 
Phone은 그렇지 못했다. Set<E>이 number가 같은 Phone 객체를 중복 
데이터로 간주해서 하나만 관리하도록 처리해보자. 
Set<E>에서 두 객체가 '같다'라는 평가는 
equals()의 결과 true가 리턴되는 것과 함께 추가로 hashCode()의 
결과가 같아야 한다. 
다음과 같이 Phone을 수정한 Phone2를 이용해 테스트를 해보자. 
참고로 equals()와 hashCode()의 재정의는 소스파일에서 
마우스 오른쪽 버튼을 클릭하여 단축 메뉴에서 
[Source]->[Generate]->[hashCode() and equals()]
를 이용한다. 

ex)
package ch13.set;

public class Phone2 {
	String number;
	Integer price;

	public Phone2(String number, Integer price) {
		this.number = number;
		this.price = price;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((number == null) ? 0 : number.hashCode());
		result = prime * result + ((price == null) ? 0 : price.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Phone2 other = (Phone2) obj;
		if (number == null) {
			if (other.number != null)
				return false;
		} else if (!number.equals(other.number))
			return false;
		if (price == null) {
			if (other.price != null)
				return false;
		} else if (!price.equals(other.price))
			return false;
		return true;
	}

	@Override
	public String toString() {
		return "SamePhone [number=" + number + ", price=" + price + "]";
	}
}
//
이클립스에서 제공하는 소스 코드 생성기능을 사용하면 hashCode()와 
equals()를 함께 재정의하도록 메뉴가 구성된 이유도 두 메서드가 다 
재정의되어야 함을 암시한다. 

ex)
package ch13.set;

import java.util.HashSet;
import java.util.Set;

public class PhoneTest {
	public static void main(String[] args) {
		Set<Phone2> pSet = new HashSet<>();
		pSet.add(new Phone2("010", 2000));
		pSet.add(new Phone2("010", 2000));
		pSet.add(new Phone2("011", 3000));
		pSet.add(new Phone2("011", 3000));
		pSet.add(new Phone2("011", 1000));
		System.out.println("set의 크기: " + pSet.size());
		for(Phone2 phone: pSet) {
			System.out.println(phone);
		}
	}
}
//
set의 크기: 3
SamePhone [number=010, price=2000]
SamePhone [number=011, price=3000]
SamePhone [number=011, price=1000]

----------------------------------------------------
3.3 Set<E>의 정렬과 TreeSet<E> 

522 24/43

Collection<E>의 sort()는 List<E>의 요소들을 정렬시킬 수 있지만, 
Set<E>는 아니다. 앞서 배웠던 HashSet<E>은 순서가 없기 때문에 
기본적으로 정렬이 불가능하다. 대신 NavigableSet<E> 을 구현한 
TreeSet은 정렬 기능을 가지고 있다. 

(1)이진 트리 구조 
TreeSet<E>은 Tree는 자료가 저장되는 모양에서 유래된다. 
이진트리(binary tree)라고 불리는 이 구조는 루트 노드라고 불리는 
최상위 노드와 그자식들이 1~2개의 노드를 가지는 구조로 형성된다. 
하위 노드들을 필요에 따라 계속해서 자식 노드를 추가할수 있고 
자신은 부모 노드가 된다. 
루트 노드 -> 부모노드 ->자식노드 

이진 트리 구조가 데이터를 저장하는 방법에 대해 알아보자.
이진 트리는 값이 들어오면 부모 노드의 값보다 작은 값은 
왼쪽 노드에 할당하고 큰 값은 오른쪽 노드에 할당한다. 
만약 두 값이 같다면 추가되지 않는다. 

문자의 경우 크고 작음의 기준으로 유니코드 값을 이용한다. 
예를 들어 "w", "o", "r", "l", "d"라는 다섯 개의 
문자열이 이진 트리에 저장되는 순서는 다음과 같다. 

(1) "o"
w -> (w>o?) : o는 w 왼쪽 아래 "o"
(2) "r"
-> (w>r?) : r는 w 왼쪽아래 ,
다시, (r > o?) : r는 o 오른쪽아래 
(3) "l"
-> (w>l?) : l는 w 왼쪽아래 ,
다시, (l > o?) : l는 o 왼쪽아래 
(4) "d"
-> (w>d?) : d는 w 왼쪽아래 ,
다시, (d > o?) : d는 o 왼쪽아래 
다시, (d > l?) : d는 l 왼쪽아래 

이진 트리의 자료 정리 방법 

이렇게 자료를 정리했을 때 장점은 자료가 정리될때마다 자동으로 
정렬이 된다는 것이다. 
위 구조에서 왼쪽에서 오른쪽으로 읽어보면 
d->l->o->r->w 가 된다. 즉 오름차순 정렬이 되고 
반대 방향은 내림차순 정렬이다. 또한, "o"이상의 것은 
"o"의 부모이거나 오른쪽에 있는 요소 즉 "r"과 "w"가 된다. 

(2)TreeSet<E>

TreeSet<E>은 이진 트리 구조를 기반으로 한 Set<E> 계열의 
컬렉션이다. 하지만, 관리해야 하는 객체가 정렬되어야 하기 
때문에 저장되는 객체들은 Comparable<E>을 구현하고 있거나 
Comparator<E>를 생성자로 전달해서 사용자 정의 정렬 방식을 
이용할 수 있다. 

ex)
public TreeSet() { // Comparable 구현체 관리용
this(new TreeMap<E, Object>());
}
// 사용자 정의 정렬 방식 활용 
public TreeSet(Comparator< ? super E> comparator) {
this(new TreeMap<>(comparator));
}

객체를 저장할 때도 내부적으로 Comparable 형태로 형변환해 
사용하므로 Comparable 구현체가 아닌 자료가 저장될 경우 
런타임에 ClassCastException이 발생한다. 다음과 같이 
단순한 Object 객체를 저장하면 Object에는 Comparable이 
구현되어 있지 않으므로 오류가 발생한다. 

ex)
Set<Object> set1 = new TreeSet<>();
set1.add(new Object());
// Exception in thread "main"
java.lang.ClassCastException: java.lang.Object
cannot be cast to java.lang.Comparable

이런 경우 TreeSet<E>을 생성할 때 Comparator를 추가해야 
동작한다. 

ex)
class ObjComparator implements Comparator<Object> {
@Override
public int compare(Object o1, Object o2) {
return o1.toString().compareTo(o2.toString());
}

Set<Object> set1 = new TreeSet<> (new ObjComparator());
set1.add(new Object());

자료를 저장할 때도 주의할 사항이 있는데 비교되는 객체는 모두 같은 
Comparable<E>나 Comparator<E>의 E와 같은 종류여야한다. 
생각해보면 객체 간의 순서를 지정해서 저장 해야 하는데 
객체의 종류가 다르면 비교한 근거가 없기 때문에 문제가 발생하는 것이다. 
예를들어 숫자를 저장하다가 갑자기 Phone 객체가 들어온다면 둘을 
비교할 방법이 없을 것이다. 
이런 경우도 역시 ClassCastException 이 발생한다. 

ex)
Set<Object> set1 = new TreeSet<>();
set1.add("Hello");
set1.add(1);
// Exception in thread "main"
// java.lang.ClassCastException: java.lang.Object
// cannot be cast to java.lang.Integer

TreeSet<E>에는 정렬된 트리를 이용해서 요소를 조회하는 메서드들이 
제공된다. 

TreeSet의 메서드 

메서드 명 : 선언부와 설명 

first() : public E first()
정렬 결과 처음 요소를 리턴한다. 

last() : public E last()
정렬 결과 마지막 요소를 리턴한다. 

lower() : public E lower(E e)
e 바로 이전의 객체를 리턴한다. 

higher() : public E higher(E e)
e 바로 다음의 객체를 리턴한다. 

floor() : public E floor(E e)
e 또는 만약 e가 없다면 e 바로아래(이전) 객체를 리턴한다. 

ceiling() : public E ceiling(E e)
e 또는 만약 e가 없다면 e 바로위(다음) 객체를 리턴한다. 

pollFirst() : public E pollFirst()
first() 객체를 리턴하고 TreeSet<E>에서 제거한다. 

pollLast() : public E pollLast()
last() 객체를 리턴하고 TreeSet<E>에서 제거한다. 

decendingSet() : public NavigableSet<E> decendingSet()
내림차순으로 정렬하는 NavigableSet<E>를 리턴한다. 

headSet() : public NavigableSet<E> headSet( E toElement, boolean inclusive)
toElement 아래(이전) 객체들을 NavigableSet<E>으로 리턴한다. 
inclusive가 true이면 toElement를 포함하고 false이면 포함하지 않는다. 

tailSet() : public NavigableSet<E> tailSet(E fromElement, boolean inclusive)
fromElement 이후(다음) 객체들을 NavigableSet<E>으로 리턴한다. 
Inclusive 가 true 이면 fromElement를 포함하고 false이면 
포함하지 않는다. 

subSet() : public NavigableSet<E> subSet(E fromElement, boolean frominclusive, 
E toElement, boolean toInclusive)
fromElement 에서 toElement 사이의 요소로 구성된 NavigableSet<E> 을 
반환한다. 각 경계 요소의 포함 여부는 frominclusive와 toInclusive로 결정한다. 

이 기능들은 Set에 선언되지 않고 TreeSet<T>의 또 다른 상위 
인터페이스인 NavigableSet<E>에 선언되어 있고, TreeSet<E>이 
구현했다. 따라서 이 기능들을 사용하기 위해서는 객체 생성시 
Set<E> 이 아닌 NavigableSet<E> 타입으로 사용해야 한다. 
다음 예제를 통해 "w", "o", "r", "l", "d"를 TreeSet<E>에서 
관리해보자. 

ex)
package ch13.set;

import java.util.Arrays;
import java.util.NavigableSet;
import java.util.TreeSet;

public class SimpleTreeSetTest {
	public static void main(String[] args) {
		TreeSet<Object> set = new TreeSet<>();
		set.addAll(Arrays.asList("w","o","r","l","d"));
		System.out.println("오름차순 TreeSet: "+set);
		System.out.println("처음 요소: "+set.first());
		System.out.println("마지막 요소: "+set.last());
		System.out.println("o 아래 요소: "+set.lower("o"));
		System.out.println("l 다음 요소: "+set.higher("l"));
		System.out.println("m 이전 요소: "+set.floor("m"));
		System.out.println("m 다음 요소: "+set.ceiling("m"));
		System.out.println("헤드 셋: "+set.headSet("m"));
		
		NavigableSet<Object> naviSet = set.descendingSet();
		System.out.println("내림차순 TreeSet: "+naviSet);
	}
}
//
오름차순 TreeSet: [d, l, o, r, w]
처음 요소: d
마지막 요소: w
o 아래 요소: l
l 다음 요소: o
m 이전 요소: l
m 다음 요소: o
헤드 셋: [d, l]
내림차순 TreeSet: [w, r, o, l, d]

이번에는 앞서 테스트 했던 StringLengthComparator를 이용해서 
TreeSet<E>에 담긴 문자열들을 정렬시켜보자. 

ex2)
package ch13.set;

import java.util.Arrays;
import java.util.NavigableSet;
import java.util.TreeSet;

import ch13.list.StringLengthComparator;

public class CustomTreeSetTest {
	public static void main(String[] args) {
		TreeSet<String> set = new TreeSet<>(new StringLengthComparator());
		set.addAll(Arrays.asList("타노스", "아이언맨","헐크","토르","데드폴","비전"));
		System.out.println("오름차순 TreeSet: "+set);
		
		NavigableSet<String> naviSet = set.descendingSet();
		System.out.println("내림차순 TreeSet: "+naviSet);
	}
}
//
오름차순 TreeSet: [헐크, 타노스, 아이언맨]
내림차순 TreeSet: [아이언맨, 타노스, 헐크]

위 예제의 결과는 흥미로운 점이 있다. 
TreeSet<E>에는 서로 다른 6개의 객체를 넣었지만, 출력 결과는 
3개 밖에 남지 않았다. 제거된 객체들은 길이가 같은 문자열들이다. 
즉 Comparator의 compare()에서 0이 리턴되는 경우는 추가되지 않음을 
알수 있다. 

----------------------------------------------------
3.4 TreeSet<E> 을 이용한 로또 게임 

526 28/43

이번에는 TreeSet<E>을 이용해 로또를 만들어보자. List<E>와 달라질 점은 
크게 두가지다. 먼저 Set<E> 계열에서는 데이터가 있는지 contains()로 
확인해볼 필요가 없다. 중복되는 데이터는 자동으로 제거되기 때문이다. 
또한, TreeSet<E>은 자체 정렬하므로 별도로 자료를 정렬시킬 필요도 없어진다. 
앞서 학습한 ListLottoTest와 다른 점 위주로 살펴보자. 

ex)
package ch13.set;

import java.util.Random;
import java.util.Set;
import java.util.TreeSet;

class TreeSetLotto {
	Integer bonus;
	Set<Integer> lotto = new TreeSet<>();

	public void setup() {
		Random random = new Random();
		while (bonus == null) {
			int num = random.nextInt(45) + 1;
			if (lotto.size() < 6) {
				lotto.add(num);
			} else {
				bonus = num;
			}
		}
	}

	@Override
	public String toString() {
		return "당첨번호: " + lotto + ", 보너스: " + bonus;
	}
}

public class TreeSetLottoTest {

	public static void main(String[] args) {
		TreeSetLotto lotto = new TreeSetLotto();
		lotto.setup();
		System.out.println(lotto);
	}
}
// 매번 다름 랜덤 객체 이용해서. 
당첨번호: [15, 16, 27, 32, 41, 44], 보너스: 27

----------------------------------------------------
4. Map 계열의 컬렉션

4.1 Map 인터페이스

Map<K,V> 계열은 생활 속에서 자료를 정리할 때 많이 사용되는 형식이다. 
예를 들어 우편번호를 키로 주소가 등록되어 있고 수첩 속에는 친구이름으로 
친구의 전화번호가 등록된다. 주민등록번호를 통해서 사람에  대한 정보를 
찾을 수 있다. Map<K,V>의 K와 V는 각각 키(Key), 값(Value)을 
의미하며 내부적으로 Map.Entry라는 Map 내부의 내부클래스 형태로 저장된다. 
즉 Map은 키와 값으로 구성된 Entry 객체의 모임이다. 
이때 키는 중복될 수 없고 값은 종복이 가능하다. 
Set<E>에서와 마찬가지로 중복이란 equals()의 결과 true이고 hashCode()가 
같은 경우이다. 다음 그림은 Map<K,V>을 통해 전화번호를 관리하는 예이다. 

ex)
0x100 -> 휴대폰 
0x200 -> 010-xx 

0x300 -> 사무실 
0x400 -> 02-12x

0x500 -> 집전화
0x400 -> 02-12x 

키 -> 중복불가 
값 -> 중복가능 

Map.Entry 

Map 계열의 데이터 저장

Map<K,V> 는 컬렉션 프레임워크에 포함되어 있지만, 
Collection<E> 을 상속받지는 않는다. 

과거버전 

ex)
Properties -> Hashtable -> Map 
HashMap -> Map 
TreeMap -> NavigableMap -> SortedMap -> Map

Map<K,V> 계열의 클래스 관계도 

Map<K,V>의 구현체 중 가장 많이 사용되는 것은 HashMap<K,V>이다. 
HashMap<K,V>의 Map.Entry 들은 순서가 없는데 여기에 정렬 기준을 
더한 것이 NavigableMap<K,V> 을 구현한 TreeMap<K,V>이다. 
Hashtable<K,V>는 List<E> 계열의 Vector<E> 처럼 멀티스레드에 
안전하지만 성능은 좋지 않은 과거 버전이다. 
Hashtable<K,V> 보다는 HashMap<K,V>를 사용하자. 

Hashtable<K,V> 의 하위클래스인 Properties는 속성 파일의 손쉬운 
관리라는 측면에서 자주 사용되는 클래스이다. 

529 31/43

Map<K,V>에 선언된 API들을 알아보자. List<E> 계열에서 인덱스를 이용해서 
요소인 E에 접근했듯이 Map<K,V>에서는 키인 K를 이용해서 값인 V에 
접근한다. 

Map<K,V>의 주요 메서드 

메서드 명 : 선언부와설명

clear() : void clear()
Map 의 모든 Entry를 지워서 초기화한다. 

containsKey() : boolean containsKey(Object key)
Map에 key로 등록된 Entry 가 있는지 여부 반환한다.

entrySet() : Set<Map, Entry<K,V>> entrySet()
Map의 Entry들을 Set에 담아서 리턴한다. 

get() : V get(Object key)
key로 등록된 값 객체를 리턴한다. 

keySet() : Set<K> keySet()
Map의 키 목록을  Set 형태로 리턴한다. 

put() : V put(K key, V value)
key를 키로 value를 값으로 하는 Entry를 Map에 추가한다. 
리턴값은 기존에 key로 등록된 값이 있다면 그 값, 
없다면 null 이다. 

putAll() : voit putAll(Map< ? extends K, ? extends V> m)
m에 포함된 모든 Entry들을 Map에 추가한다. 

remove() : V remove(Object key)
key에 해당하는 Entry를 Map에서 제거하고 리턴한다. 
Key에 해당하는 Entry가 없을 경우 null이 리턴된다. 

values() : Collection<V> values()
Map의 값 객체들을 Collection에 담아서 리턴한다. 

size() : int size();
Map에 포함된 Entry의 개수를 리턴한다 .

isEmpty() : boolean isEmpty();
Map에 데이터가 없는지 리턴한다. 

Map의 모든 Entry들을 하나씩 처리하기 위해서는 keySet()을 이용해 
키가 담긴 Set을 넘겨받아서 처리하거나 entrySet()을 이용해 
Entry가 담긴 Set을 넘겨받는다. 일반적으로 keySet()은 키를 
이용해서 작업을 처리할 때, entrySet()은 값을 이용해서 작업을 
처리할 때 좀더 유리하다. 

Map<K,V>의 메서드를 기능별로 분류해보면 다음과 같다. 

Map<K,V>의 메서드 분류 

분류 : Map<K, V>

추가 : put(K key, V value) ,  putAll(Map <? extends K, ? extends V> m)

조회 : containsKey(Object key), containsValue(Object value)
entrySet(), get(Object key), keySet(), values(), size()
isEmpty()

삭제 : clear(), remove(Object key)

수정 : put(K key, V value)
putAll(Map<? extends K, ? extends V> m)

Map<K, V>에 Entry를 추가할 때는 key가 중복되면 기존의 값을 
덮어 써버린다. 따라서 추가와 수정세 사용되는 메서드가 
동일하다. 

주의,
참고로 HashSet<E> 계열은 내부적으로 HashMap<K, V>에 값을 저장한다. 
이때 키에 해당하는 것이 실제 저장되는 객체이고 값 부분에는 
더미 객체(new Object())를 사용한다. 다음은 HashSet<E>의 
코드 일부분이다. 

ex)
private static final Object PRESENT = new Object();
public HashSet() {
map = new HashMap<>();
}
public boolean add(E e) {
return map.put(e, PRESENT) == null;
}


----------------------------------------------------
4.2 HashMap<K, V>

Map<K, V> 계열의 가장 대표적 구현체인 HashMap<K, V>를 이용해서 
전화번호를 관리하는 애플리케이션을 작성하면서 위에서 설명한 
메서드들의 사용법을 알아보자. 

ex)
package ch13.map;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class HashMapTest {
	Map<String, String> hMap = new HashMap<>();

	private void addMethod() {
		System.out.println("추가 결과: " + hMap.put("andy", "1234"));
		System.out.println("추가 결과: " + hMap.put("andy", "4567"));
		hMap.put("henry", "4567");
		hMap.put("kate", "9999");
		System.out.println(hMap);
	}

	private void retrieveMethod() {
		System.out.println("총 Entity 개수: " + hMap.size());
		Set<String> keys = hMap.keySet();
		for (String key : keys) {
			System.out.println("키: " + key + " , 값: " + hMap.get(key));
		}
		String targetNumber = "4567";
		Set<Map.Entry<String, String>> entrySet = hMap.entrySet();
		for (Map.Entry<String, String> entry : entrySet) {
			if (entry.getValue().equals(targetNumber)) {
				System.out.println("번호가 " + targetNumber + "인 사람: " + entry.getKey());
			}
		}
		System.out.println("kate의 전화번호가 있는가? " + hMap.containsKey("kate"));
	}

	private void removeMethod() {
		hMap.remove("andy");
		System.out.println(hMap);
	}

	public static void main(String[] args) {
		HashMapTest hmt = new HashMapTest();
		hmt.addMethod();
		hmt.retrieveMethod();
		hmt.removeMethod();
	}
}
//
추가 결과: null
추가 결과: 1234
{henry=4567, kate=9999, andy=4567}
총 Entity 개수: 3
키: henry , 값: 4567
키: kate , 값: 9999
키: andy , 값: 4567
번호가 4567인 사람: henry
번호가 4567인 사람: andy
kate의 전화번호가 있는가? true
{henry=4567, kate=9999}



----------------------------------------------------
4.3 TreeMap<K, V>를 이용한 정렬 

532 34/43

앞선 예제에서 살펴봤듯이 HashMap<K,V>는 순서가 없다. 
Map<K,V> 계열에도 Set<E>의 TreeSet<E>처럼 정렬이 지원되는 
TreeMap<K,V>가 존재한다. TreeMap<K,V>은 키값을 이용해 내부에 
저장된 Entry들을 정렬시킨다. 기본적인 정렬 방식은 TreeSet<E>
과 동일하다. 즉 별도의 Comparator<E>를 사용하지 않았으면 
저장되는 키가 Comparable<E> 을 구현하고 있어야 한다. 

다음 TreeMap<K,V>의 주요 생성자들이다. 

ex)
// 저장되는 Entry의 키는 Comparable 타입일 것. 기본 키를 이용해 
정렬 
public TreeMap() {..}

//키의 상위 객체를 요소로 갖는 Comparator를 이용해 정렬 
public TreeMap(Comparator< ? super K> comparato){..}

// K가 Comparable 타입이 아닐 경우 ClassCastException 발생 
public TreeMap(Map<? extends K, ? extends V> m) {..}

주요 메서드들 역시 TreeSet<E>의 것과 유사하다. 
대부분 뒤에 Entry가 접미사로 추가된다. 

TreeMap의 주요 메서드 

메서드 명 : 선언부와설명

firstEntry() : public Map.Entry<K,V> firstEntry()
정렬 결과 처음 Entry<K,V>를 리턴한다. 

lastEntry() : public Map.Entry<K,V> lastEntry()
정렬 결과 맨 마지막 Entry<K,V>를 리턴한다. 

lowerEntry() : public Map.Entry<K,V> lowerEntry(K key)
key 바로 이전의 Entry<K,V>를 리턴한다. 

higherEntry() : public Map.Entry<K,V> higherEntry(K key)
key 바로 다음의 Entry<K,V>를 리턴한다. 

floorEntry() : public Map.Entry<K,V> floorEntry(K key)
key 또는 만약 key 가 없다면 key 바로 아래 Entry<K,V>를 리턴한다. 

ceilingEntry() : public Map.Entry<K,V> ceilingEntry(K key)
key 또는 만약 key 가 없다면 key 바로 위의 Entry<K,V>를 리턴한다. 

pollFirstEntry() : public Map.Entry<K,V> pollFirstEntry()
firstEntry() 객체를 리턴하고 TreeMap<K,V> 에서 제거한다. 

pollLastEntry() : public Map.Entry<K,V> pollLastEntry()
lastEntry() 객체를 리턴하고 TreeMap<K,V> 에서 제거한다. 

decendingKeySet() : public NavigableSet<K> descendingKeySet()
내림 차순으로 정렬하는 NavigableSet<K>를 리턴한다. 

decendingKeyMap() : public NavigableMap<K> descendingMap()
내림 차순으로 정렬하는 NavigableMap<K,V>를 리턴한다. 

headMap() : public NavigableMap<K, V> headMap( k toKey, boolean inclusive)
toKey 아래(이전) Entry<K, V>들을 NavigableMap<K, V>으로 리턴한다. 
Inclusive가 true 이면 toKey를 포함하고 false이면 포함하지 않는다. 

tailMap() : public NavigableMap<K, V> tailMap( k fromKey, boolean inclusive)
fromKey 이후(다음) Entry<K, V>들을 NavigableMap<K, V>으로 리턴한다. 
Inclusive가 true 이면 fromKey를 포함하고 false이면 포함하지 않는다. 

subMap() : public NavigableMap<K, V> subMap<K fromKey, 
boolean fromInclusive, K toKey, boolean toInclusive)
fromKey에서 toKey 사이의 Entry<K, V>로 구성된 
NavigableMap<K, V>을 반환한다. 각 경계 요소의 포함 여부는 
fromKey와 toKey로 결정한다. 

다음은 TreeMap<K, E>을 이용해서 Entry<K, V>를 관리하는 예이다. 

ex)
package ch13.map;

import java.util.HashMap;
import java.util.Map;
import java.util.NavigableMap;
import java.util.TreeMap;

import ch13.list.StringLengthComparator;

public class TreeMapTest {
	private static Map<String, String> initMap(Map<String, String> map) {
		map.put("토르", "마블");
		map.put("베트맨", "DC");
		map.put("아이언맨", "마블");
		map.put("원더우먼", "DC");
		return map;
	}

	public static void main(String[] args) {
		Map<String, String> map = initMap(new HashMap<>());
		System.out.println("맵의 정렬 상태 1: " + map);
		Map<String, String> tmap = initMap(new TreeMap<>());
		System.out.println("맵의 정렬 상태 2: " + tmap);
		if(tmap instanceof NavigableMap<?, ?>) {
			NavigableMap<String, String> navMap = (NavigableMap<String, String>)tmap;
			System.out.println("맵의 맨 처음 요소: "+navMap.firstEntry());
			System.out.println("맵의 내림차수 정렬: "+navMap.descendingMap());
		}
		
		Map<String, String> tmap2 = initMap(new TreeMap<>(new StringLengthComparator()));
		System.out.println("맵의 정렬 상태 3: " + tmap2);
	}
}
//
맵의 정렬 상태 1: {아이언맨=마블, 원더우먼=DC, 토르=마블, 베트맨=DC}
맵의 정렬 상태 2: {베트맨=DC, 아이언맨=마블, 원더우먼=DC, 토르=마블}
맵의 맨 처음 요소: 베트맨=DC
맵의 내림차수 정렬: {토르=마블, 원더우먼=DC, 아이언맨=마블, 베트맨=DC}
맵의 정렬 상태 3: {토르=마블, 베트맨=DC, 아이언맨=DC}

//일반 HashMap<> 타입의 객체를 만들고 출력한다. 자료 저장순서는 
보장되지 않는다. 
// 저장 키인 String의 Comparator를 이용한 TreeMap<> 타입의 객체를 
만들고 출력한다. 출력 결과는 키의 알파벳 오름차순으로 정렬된다. 
// NavigableMap으로 형변환 후 firstEntry(), decendingMap()등 
메서드의 리턴값을 출력한다. 각각 정렬된 첫번째 Entry또는 
내림차순 정렬 결과를 얻을 수 있다. 

535 37/43
----------------------------------------------------
4.4 HashMap<K, V>을 이용한 로또 게임

Map<K,V> 구조에서 로또 게임을 생각해보자. 100만 번 랜덤한 숫자를 
발생시킨후 번호를 키로, 빈도수를 값으로 Map<K,V> 저장해 놓고 
빈도수를 기준으로 상위 1~6번까지를 당첨번호, 7번째를 보너스 번호로 
간주하도록 작성해보자. 

ex)
package ch13.map;

import java.text.MessageFormat;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random;
import java.util.TreeSet;

class LottoEntryComparator implements Comparator<Entry<Integer, Integer>> {
	@Override
	public int compare(Entry<Integer, Integer> o1, Entry<Integer, Integer> o2) {
		int result = o1.getValue().compareTo(o2.getValue()) * -1;
		if (result == 0) {
			result = o1.getKey().compareTo(o2.getValue()) * -1;
		}
		return result;
	}
}

public class MapLottoTest {
	public static void main(String[] args) {
		Map<Integer, Integer> lottoMap = new HashMap<>();
		Random random = new Random();
		for (int i = 0; i < 100000; i++) {
			int num = random.nextInt(45) + 1;
			if (lottoMap.containsKey(num)) {
				lottoMap.put(num, lottoMap.get(num) + 1);
			} else {
				lottoMap.put(num, 1);
			}
		}
		sortLottoByValue(lottoMap);
	}

	public static void sortLottoByValue(Map<Integer, Integer> map) {
		TreeSet<Map.Entry<Integer, Integer>> sortedEntries = new TreeSet<>(new LottoEntryComparator());
		sortedEntries.addAll(map.entrySet());
		String pattern = "{0} 번호: {1}\t(총 누적: {2})";
		for (int i = 0; i < 7; i++) {
			Entry<Integer, Integer> first = sortedEntries.pollFirst();
			String msg = null;
			if (i == 6) {
				msg = MessageFormat.format(pattern, "보너스", first.getKey(), first.getValue());
			} else {
				msg = MessageFormat.format(pattern, "당첨", first.getKey(), first.getValue());
			}
			System.out.println(msg);
		}
	}
}
//
당첨 번호: 32	(총 누적: 2,308)
당첨 번호: 25	(총 누적: 2,306)
당첨 번호: 15	(총 누적: 2,294)
당첨 번호: 7	(총 누적: 2,289)
당첨 번호: 20	(총 누적: 2,284)
당첨 번호: 35	(총 누적: 2,280)
보너스 번호: 44	(총 누적: 2,275)

---------------------------------------------------
4.5 Propertie<K, V>

Properties<K, V>는 구 버전의 컬렉션인 Hashtable을 상속받은 클래스로 
애플리케이션의 환경 설정 파일에 데이터를 읽고 쓰는 기능을 가지고 있다. 
예를 들어 데이터베이스에 접속하기 위해서는 애플리케이션에서 서버의 
주소, 사용자 계정(아이디/패스워드)등을 알고 있어야 한다. 
하지만 이 값들은 주기적으로 또는 수시로 변경될 수 있어야 한다. 
만약 이런 설정값들이 애플리케이션에 소스 코드 형태로 적혀 있다면 값을 
변경할 때마다 다시 컴파일을 진행해야 할것이다. 따라서 설정값들은 
일반적인 소스와 분리된 별도의 텍스트 파일에 보관하게 되는데 이 파일은 
컴파일 대상이 아니다. 

ex)
애플리케이션1 ---->  DB
String id ="andy"
String pass ="1234"
String addr = "192.168.0.2"
소스파일 : 변경시 컴파일 필요 

애플리케이션2 ---->  DB
Properties p 
id = andy
pass =1234 
addr =192.168.0.2 
일반 텍스트 파일 : 변경시 컴파일 불필요 

환경 설정의 저장 방식 차이 

이 설정 파일은 일반적으로 확장자를 '.properties'로 만든다.
(물론 꼭 정해져 있는 것은 아니다. ) 설정 파일은 
'키=값'과 같은 Entry 형태로 값을 여러개 저장할 수 있어서 
마치 파일에 작성해 놓은 Map과 유사하다. 

파일에 데이터를 쓰고 읽는 과정은 스트림을 이용하는 복잡한 과정이지만 
Properties는 간단한 메서드를 통해 손쉽게 처리할 수 있다. 

Properties 의 주요 메서드 

메서드 명 : 선언부와설명

getProperty() : public String getProperty(String key)
key에 해당하는 속성 값을 리턴한다. 

public String getProperty(String key, String defaultValue)
key에 해당하는 속성값을 리턴한다. 값이 없을 경우 
defaultValue를 리턴한다. 

stringPropertyNames() : Set<String> stringPropertyNames()
Properties가 가진 키의 목록을 Set<String>으로 리턴한다. 

setProperty() : public synchronized Object setProperty(String key, String value)
key로 value을 등록하고 기존에 key로 등록되었던 값을 리턴한다. 

load() : public synchronized void load(Reader reader)
throws IOException
reader를 이용해 속성을 읽어온다. 

loadFromXML() : public synchronized void loadFromXML(InputStream in)
throws IOException, InvalidPropertiesFormatException 
in 을 이용해서 XML 형태로 저장된 속성을 읽어온다. 

store() : public void store(Writer writer, String comments)
throws IOException
writer를 이용해서 속성을 파일에 저장한다. 이때 comment를 추가할수 있다.

storeToXML() : public void storeToXML(OutputStream os, String comment)
throws IOException
os를 통해 속성 파일을 XML 형태로 추가한다. 
이때 comment 를 추가할수 있다. 

Properties<K,V> 도 Map<K, V>를 구현하고 있기 때문에 put(), get()
과 같은 메서드를 사용할 수 있다. 하지만 일반적으로 속성들은 모두 문자열로 
간주하기 때문에 문자열을 기본으로 사용하는 getPropertiy(), setProperty()
메서드를 더 많이 사용하는 편이다. 

load 계열과 store 계열의 메서드들이 눈에 띄는데 각각 파일에서 속성을 
읽어오거나 쓰는 역할을 담당한다. 이 메서드들은 파라미터로 입/출력을 
위한 스트림들을 파라미터로 받는데 이에 대한 자세한 설명은 
15장에서 다룬다. 

다음은 Properties 를 이용해 속성을 저장하고 읽는 방법에 대한 예제이다. 

ex)
package ch13.map;

import java.io.FileReader;
import java.io.FileWriter;
import java.util.Properties;
import java.util.Set;

public class PropertiesTestWithFile {
	private final static String PROP_FILE_PATH = "./config.properties";

	public static void main(String[] args) {
		saveToFile();
		loadFromFile();
	}

	private static void saveToFile() {
		Properties props = new Properties();
		props.setProperty("id", "andy");
		props.setProperty("pass", "1234");
		props.setProperty("addr", "192.168.0.2");
		props.setProperty("이름", "홍길동");
		System.out.println("속성 확인: " + props);
		try (FileWriter output = new FileWriter(PROP_FILE_PATH)) {
			props.store(output, "System Config");
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	private static void loadFromFile() {
		Properties props = new Properties();

		try (FileReader input = new FileReader(PROP_FILE_PATH)) {
			props.load(input);
			Set<String> keys = props.stringPropertyNames();
			for(String key: keys) {
				System.out.println(key+" : "+props.getProperty(key));
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
//
속성 확인: {pass=1234, 이름=홍길동, id=andy, addr=192.168.0.2}
pass : 1234
이름 : 홍길동
id : andy
addr : 192.168.0.2
//해당 워크스페이스에서 파일 만들기.

===================================
[자바 해바라기 정리] 14 멀티스레드 프로그래밍

1. 멀티스레드 프로그래밍

1.1 스레드 와 프로세스 

컴퓨터에서 설치하여 사용하는 이클립스나 워드 프로세서, 브라우저와 
같은 코드 덩어리를 애플리케이션이라고 한다. 설치된 애플리케이션을 
실행하게 되면 운영체제(OS)로부터 메모리의 일정 영역을 할당받고 
CPU와 HDD를 이용해서 동작하는데 이것을 프로세스라고 부른다. 
일반적으로 운영체제들은 동시에 여러 프로세스를 실행시킬수 있는데 
이것을 멀티 프로세스라고 부른다. 이클립스를 여러 개 실행시키거나 워드 
작없을 하면서 음악을 재생시키며 채팅을 하는 것은 모두 멀티 프로세스로 동작한다. 

개별 프로세스들은 동작을 위해 자신만의 데이터, 메모리 등의 자원과 
여러 스레드라는 것으로 구성된다. 즉 이클립스를 여러 개 실행시키면 
멀티 프로세스가 동작하는 것이고 설사 애플리케이션이 같더라도 일반적으로 
프로세스 간의 공유는 발생하지 않는다. 

ex) 
애플리케이션 실행 

Process 1 -> 자원, 스레드, 스레드, 스레드 
Process 2 -> 자원, 스레드, 스레드, 스레드
Process 간의 공유 없음. 
멀티 프로세스 

그럼 프로세스를 구성하는 스레드는 무엇일까? 
스레드는 프로세스 동작의 최소 단위이다. 모든 프로세스는 하나 이상의 
스레드로 구성된다. 즉, 이제까지 우리가 만들었던 프로그램들도 모두 
스레드가 있었다는 이야기다. 이 스레드를 우리는 메인 스레드(main thread)
라고 부른다. 이 메인 스레드가 main() 메서드를 실행하면서 애플리케이션이 
구동된다. 

둘 이상의 스레드로 구성된 프로세스를 멀티스레드 프로세스라고 
부른다. 메신저 같은 애플리케이션은 채팅하면서 파일을 전송할수 있다. 
만약 이 프로세스가 단일 스레드 모델이라면 파일을 전송할 때 
채팅을 함께 진행할 수 없다. 하지만 파일 전송을 담당하는 스레드와 
채팅을 처리하는 스레드가 동시에 동작하므로 파일 전송과 함께 채팅이 
가능하다. 문서를 편집하는 MS-Word의 경우 글을 편집하는 동안 가끔 
자동 저장이 이뤄진다. 이처럼 스레드는 하나의 프로세스 내에서 동시에 
여러 작업을 가능하게 한다. 

주의, 
엄밀히 말해서 하나의 CPU가 여러 작업(즉 스레드)을 동시에 처리할 수는 없다. 
사실은 CPU가 여러 스레드를 아주 빠른 시간에 번갈아 수행해서 동시에 
처리되는 것처럼 느끼게 한다. 
이런 과정을 컨텍스트 스위칭(Context Switching)이라고 한다. 
하지만 앞으로 이 책에서 멀티스레드는 특별한 언급이 없을 때는 동시에 
실행되는 것으로 표현한다. 실제로 멀티코어 CPU에서는 정말로 동시에 
여러 작업이 진행될 수 있게 되었다. 

윈도우 운영체제의 경우 Windows 검색 을 통해 리소스 모니터를 실행시키면 
현재 메모리를 사용중인 모든 프로세스의 정보를 확인할 수 있다. 
다음 그림을 보면 현재 이 책을 집필하는 데 사용되고 있는 
MS-Word(WINWORD.EXE) 프로세스의 경우 총 26개의 스레드로 구성되 
있을 알수 있다.이 수는 그때그때 달라진다. 

멀티 프로세스와 멀티스레드 

----------------------------------------------------
1.2 멀티스레드 프로그래밍 의 장/단점 

그럼 우리는 왜 멀티스레드 프로그래밍을 해야 할까?

멀티스레드를 사용해야 하는 이유에 대해서는 크게 CPU 사용률 향상, 
작업의 분리로 응답성 향성, 자원의 공유를 통한 효율성 증대를 들수 있다. 
하지만, 컨텍스트 스위칭 과정에 별도의 비용이 발생하거나 제어의 
어려움은 스레드를 사용하면서 오는 단점이라고 볼수 있다.

(1) CPU 사용률 향상
요즘의 CPU 성능은 매우 우수해서 한번에 연산할 수 있는 내용이 매우 많다. 
일반적인 요청 사항을 연산하는데 걸리는 시간은 짧은 편이며 실제로 CPU 사용량은 
20% 미만인 경우가 많다. 대부분 '느리다'라고 생각되는 부분은 네트워크나 
파일 I/O와 관련된 내용이 많다. 

싱글 스레드 기반의 애플리케이션은 CPU 입장에서는 너무 쉬운 작업이다. 
멀티스레드를 사용하면 동시에 여러 개의 스레드를 실행시키기 위해 
CPU가 아주 바쁘게 움직인다.  즉, CPU의 활용율을 높일 수 있다. 

ex) 
요청-요청-요청 -> CPU 20% 사용중 

요청-> 
요청-> CPU 80% 사용중 
요청->

멀티스레드와 CPU 사용률 

(2)작업의 분리로 응답성 향성 
멀티스레드 프로그램은 작업을 스레드 단위로 분리해서 병령 수행할 수 있게 한다.
사용자로부터 입력을 기다리는 상황에서 별도로 진행되어야 하는 작업이 있다고 
생각해보자. 다음 예제는 구구단 문제가 출제되어 사용자의 값 입력을 기다리는 
상황인데 긴장감을 고조시키기 위해 카운트다운을 해야 하는 상황이다. 

ex)
package ch14.basic;

import java.util.Random;

import javax.swing.JOptionPane;

public class UIThreadTest {

	public static void main(String[] args) {
		Random random = new Random();
		int first = random.nextInt(9) + 1;
		int second = random.nextInt(9) + 1;

		for (int i = 10; i > 0; i--) {
			try {
				Thread.sleep(1000);
			} catch (InterruptedException ignore) {
			}
			System.out.println("count down: " + i);
		}

		String result = JOptionPane.showInputDialog(first + "* " + second + "?");
		System.out.println("입력: " + result + ", 정답은: " + (first * second));
	}
}
/*
 		new Thread(()-> {
			for(int i=10; i>0; i--) {
				try {
					Thread.sleep(1000);
				} catch (InterruptedException ignore) {	}
				System.out.println("count down: "+ i);
			}
		}).start();;
 */
 //
 count down: 10
count down: 9
count down: 8
count down: 7
count down: 6
count down: 5
count down: 4
count down: 3
count down: 2
count down: 1

스레드의 생성이나 사용법은 뒤에 다루기 때문에 코드에 대한 자세한 설명은 
생략한다. 
처음으로 UI를 이용한 애플리케이션을 작성해보았지만, Scanner를 이용할 때도 
마찬가지이다. 의도는 카운트다운이 진행되는 중에 사용자로부터의 입력을 
받는 것이지만, 실제로는 카운트다운이 모두 진행된 뒤에 정답을 입력받기 위한 
다이얼로그가 활성화된다.  이런 경우 두개의 작업을 각각 다른 스레드로 
분리해서 처리해야 한다. 

카운트다운 부분을 다음과 같이 스레드로 변경하고 실행해보자. 

ex2)
new Thread(()-> {
			for(int i=10; i>0; i--) {
				try {
					Thread.sleep(1000);
				} catch (InterruptedException ignore) {	}
				System.out.println("count down: "+ i);
			}
		}).start();;
//

이제 카운트다운과 별도로 사용자로부터 값을 입력받고 결과를 
출력할 수 있다. 이처럼 사용자의 입력을 기다리거나 파일 전송 등 
시간이 걸리고 무거운 작업을 메인 스레드에서 분리하여 수행함으로써 
애플리케이션의 응답성을 향상할수 있다. 

(3) 자원의 공유를 통한 효율성 증대 
하나의 프로세스 안에 있는 스레드들은 그 프로세스의 자원을 공유한다. 
예를들어 많은 학생의 시험 점수를 처리하기 위해 배열에 관리한다면 
점수 입력 스레드와 점수 출력 스레드가 동일한 배열을 사용할수 있다. 
따라서 효율적인 자원 활용이 가능하다. 만약 별도의 프로세스라면 
IPC(Inter Process Communication)등 복잡한 과정을 거쳐야 한다. 

ex) 멀티스레드와 공유 자원 
프로세스 : 스레드 - 공유자원 -스레드 

546 5/453

(4) 컨텍스트 스위칭 비용 발생 

멀티스레드 프로그래밍은 작업 전환, 즉 컨텍스트 스위칭 과정에서 
싱글스레드에서는 필요 없는 비용이 발생한다. 

하나의 싱글 코어 CPU 환경에서 A와 B 작업을 수행한다고 생각해보자. 
두 작업을 순차적(Sequential)으로 수행하면 A 작업시간과 B 작업시간을 
더한 만큼의 작업시간이 필요하다. 

ex)
순수한 A 작업 시간 
<------------------------->
A-1 A-2 A-3 A-4 A-5

순수한 B 작업 시간 
<------------------------->
B-1 B-2 B-3 B-4 B-5

두 작업을 각각 스레드로 만들어 수행하면 다음과 같이 표현할수 있다. 
A와 B작업을 교대하는 과정에서 컨텍스트 스위칭 비용이 발생하게 된다. 
이렇게 진행되는 형태를 병행(Concurrent)프로그래밍이라고 한다. 

A-1|B-1|A-2|B-2|A-3|B-3|A-4|B-4|A-5|B-5 

결과적으로 두 가지 작업에 필요한 작업시간 외에도 추가 비용이 발생한 것을 
알수 있다. 

A-1A-2A-3A-4A-5B-1B-2B-3B-4B-5||||||
"||||||" -> Context Switching 비용 

(5) 스레드 제어의 어려움 

싱글 스레드 프로그래밍에서는 제어에 대해 고민할 필요가 없었다. 
단순히  어떻게 동작 할것인지 비즈니스 로직만 고민하면 
되었지만, 멀티스레드 프로그래밍에서는 각 스레드의 상태를 
파악하며 제어하기가 쉽지 않다. 하지만 이 부분은 좋은 프로그램을 
작성함으로써 극복해야하는 부분이다. 뒤에 다룰 스레드의 상태와 
제어 부분에서 이 문제에 대한 해법을 찾아보자. 

----------------------------------------------------
2. 스레드 생성과 수행

2.1 스레드 생성 

스레드는 일반적으로 Runnable 인터페이스를 구현하는 방법과 
Thread 클래스를 상속 받는 방법의 두 가지로 만들 수 있다. 

(1) Runnable 인터페이스의 구현 
먼저 Runnable 인터페이스를 구현하는 방법부터 알아보자. 
Runnable 인터페이스는 전형적인 함수형 인터페이스로 
람다식을 이용해서 쉽게 작성할 수 있다. Runnable에는 
run() 메서드 하나가 존재하고 이 메서드를 오버라이딩 해서 
필요한 내용을 작성한다. 일반적인 자바 프로세스의 출발점이 
main() 메서드인데 반해 스레드의 출발점은 바로 이 run() 
메서드이다. 

ex)
FunctionalInterface
public interface Runnable {
public abstract void run();
}

하지만 Runnable을 구현한 것은 아직 스레드가 아니다. 
두번째 단계로 Runnable 객체를 Thread의 생성자에 파라미터로 
넘겨줘서 Thread 객체를 생성해야 진정한 스레드가 만들어진다. 

ex)
Thread t1 = new Thread(new Runnable() {
public void run() {
System.out.println("Hello");
}
});

Thread t2 = new Thread( () -> {System.out.println("Hello");});

좌측의 코드는 익명의 내부 클래스를 이용했고, 
우측은 람다식을 이용해서 스레드를 작성한 형태이다. 
한눈에 보아도 람다식의 효율성이 두드러진다. 

(2) Thread 클래스 상속 

Thread 클래스는 Runnable을 구현하고 있다. 따라서 별도로 Runnable
객체를 파라미터로 넣을 필요 없이 Thread 클래스만 가지고 스레드를 
만들 수 있다. 

ex)
public class Thread implements Runnable {
...
}

class MyThread extends Thread {
public void run() {
System.out.println("Hello");
}
}

Thread t3 = new My Thread();

Thread를 상속받는 경우는 코드 작성은 쉬워지지만, 단일 상속의 제약에 
의해 더 이상 다른 클래스를 상속받을수 없다는 단점이 발생한다. 
상황에 따라 적절한 방식을 선택하자. 

----------------------------------------------------
2.2 스레드의 실행 

스레드를 생성할 때 필요한 비즈니스 로직을 run() 메서드에 
작성한 바 있다. 스레드를 실행할 때 재미있는 점은 이 run()
메서드를 호출하지 않는다는 점이다. 스레드를 동작 시킬 때는 
Thread 클래스에 선언된 start() 메서드를 사용한다. 
간단한 멀티스레드 프로그램을 작성하고 실행해 보자. 

ex)
package ch14.basic;

public class SimpleThreadTest {

	public static void main(String[] args) {
		Thread t1 = new Thread(new Runnable() {
			@Override
			public void run() {
				for(int i=0; i<30; i++) {
					System.out.print("-");
				}
			}
		});
		
		Thread t2 = new Thread(()->{
			for(int i=0; i<30; i++) {
				System.out.print("@");
			}
		});
		// start가 아닌 경우는 단순히 메인 스레드에서 호출됨
		t1.run();
		t2.run();
		System.out.println("main is over");
	}
}
//
------------------------------@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@main is over
//
t1.start(); 변경 
t2.start(); 변경 

//
main is over
-----------@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@-------------------

위 예제는 매우 간단한데 3가지 아주 흥미로운 내용이 존재한다. 

첫째, 소스 코드에서 보면 run() 메서드의 호출은 어디에도 보이지 
않지만, 분명히 run()은 동작했다. 

둘째, main() 메서드의 맨 마지막에 출력한 내용이 출력 결과를 보면 
맨 처음 등장한다. 

셋째, 출력된 결과를 보면 '-'와 '@'가 뒤섞여 나온다. 
심지어 여러번 실행하면 그때마다 출력 결과가 달라진다. 

이점들에 대해 하나씩 살펴보자. 

(1) run() vs start()

549 8/45

스레드 실행과 관련된 두가지 중요한 메서드는 run()과
start() 메서드 이다. run() 메서드는 스레드에서 수행할 작업을 
정의하는 메서드이고 start() 메서드 호출은 스레드의 run()
메서드가 호출될수 있도록 준비하는 과정이다.
실제 run() 메서드를 호출 하는 것은 JVM 이다.
start() 가 호출되면 JVM 이 운영체제의 스레드 스케줄러에 의해 
가능할 때 스레드의 run() 메서드를 호출한다. 
따라서 우리 코드상에는 run() 메서드를 호출하지 않는 것이다. 
마치 우리가 직접 main() 메서드를 호출하지 않은 것과 같다. 

ex) 
JVM -->실행 -> 메인 스레드 ->main()-> t1.start() 
(가능할때 t1을 실행해주세요.) ->JVM 

JVM -->실행 -> t1스레드 -> run() 

(2) 멀티스레드와 메모리 
두 메서드가 호출되면서 동작하는 과정을 메모리 관점에서 단계적으로 
살펴보자. 

단계1
6장에서 JVM의 메모리 구조를 스택과 힙으로 설명한 바 있다. 
이 스택공간은 스레드별로 생성된다. 최초 애플리케이션이 구동되면 
동작하는 메인 스레드도 하나의 스택을 차지한다. 
스택에서는 프로세스의 힙/공유 자원을 자유롭게 이용할 수 있다. 
이후 스택에는 메인 메서드가 호출하는 메서드들이 쌓였다 없어지기를 반복한다. 

단계2 
그러다가 메인 스레드가 t1 스레드의 start()메서드를 호출하면 t1 스레드를 
위한 별도의 스택 공간을 구성한다. 이 공간은 메인 스레드와는 전혀 무관한 
t1 스레드만의 공간이다.  따라서 메인 스레드가 t1 스레드의 스택에 있는 
지원을 사용할수는 없다. 하지만 힙/공유 자원은 두개의 스레드가 모두 접근 가능하다. 

단계3
이제 새로운 스택에서 t1 스레드의 run()메서드가 실행되면서 기존의 메인 스레드와 
전혀 별도로 존재하는 흐름이 생겨나게 되었다. 이후 두스레드는 병렬(번갈아 가며)
로 작업을 수행하게 된다. 따라서 앞선예제에서 "-"와 "@"가 뒤섞여 출력된다. 
또한, 하나의 스레드가 작업을 종료하는 것은 다른 스레드와 무관하다. 메인 스레드가 
실행하는 main() 메서드가 자신의 마지막 행에서 "main is over"를 출력하고 
종료되었음에도 아직 다른 스레드가 할 일이 남아 있다면, 애플리케이션은 종료되지 
않는 것이다. 모든 스레드가 종료 될 때 비로소 애플리케이션이 종료된다. 

ex)  스레드별 스택 구성 과정 
(1)최초의 메모리 구조
--------------------------
main() -> 힙/공유 자원 
-------------------------
메인 스레드 스택 

(2)새로운 스택 생성
--------------------------
start() -> 힙/공유 자원 
main()
-------------------------
t1 스레드 스택 

(3)번갈아 가며 동작
--------------------------
main() , run() -> 힙/공유 자원 
-------------------------

(1)->(2)->(3)

만약 start()를 호출하지 않고 코드에서 run() 메서드를 직접 
호출하면 어떻게 될까? 이때는 run() 메서드가 메인 스레드에서 
호출되는 것이므로 별도의 스택을 구성하지 않는다. 

하나의 스택 활용 
---------------------
run() ->힙/공유 자원 
main()

메인 스레드 스택에서의 호출과 메모리 

만약 [ch14.basic.SimpleThreadTest.java]에서 t1.start(), t2.start()를 
t1.run(), t2.run() 이라고 변경 후 실행하면 언제나 다음과 같은 결과를 
얻게 된다. t1과 t2가 스레드 객체임에도 불구하고 병렬 스레드로 동작하지 않고 
메인 스레드에서 단순히 일반 객체의 메서드 처럼 동작하는 것이다. 

ex)
------------------------------@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@main is over

----------------------------------------------------
3. 스레드의 상태와 제어 

3.1 스레드의 상태 

스레드들은 별도의 스택에서 따로따로 동작하기 때문에 제어하기가 쉽지 않다. 
따라서 상태에 대해 정확히 이해하고 제어할 필요가 있다. 스레드의 상태 값은 
Thread 내부에 State라는 enum으로 정의 되어 있으며 스레드 객체의 
getState() 메서드를 이용해서 확인할수 있다. 

Thread 객체의 상태(State)

enum 상수 : 설명 

NEW : 스레드 객체가 생성된 후 아직 start()가 호출되지 않은 상태 
RUNNABLE : JVM선택에 의해 실행 가능한 상태 
BLOCKED : 사용하려는 객체의 모니터 락이 풀릴 때까지 기다리는 상태 
WAITING : sleep(), wait(), join() 등에 의해 정해진 시간 없이 대기중인 상태 
TIMED_WAITING : sleep(), wait(), join() 등에 의해 정해진 시간 동안 대기중인 상태 
TERMINATE : run()메서드의 종료로 소멸된 상태 

다음은 스레드의 생애주기를 나타낸다. 

(1)new Thread().start()
NEW -> RUNNABLE --스레드 스케줄러->RUNNING--(2)run()->TERMINATE
(3) sleep(), wait() join(), I/O 블록킹 
(4) 시간 종료, notify(), interrupt(), I/O 종료 
(5) yield
RUNNING -> WAITING TIMED_WAITING(대기풀)-> RUNNABLE

(1)최초 스레드 객체를 생성하면 NEW 상태이다. 이 상태의 객체는 타입만 
Thread 일 뿐 스레드로서 동작은 하지 않는다. start() 메서드를 호출하면 
스레드의 상태는 RUNNABLE로 변경된다. 이 상태에서 스레드 스케줄러에 
의해 선택되면 동작할 수 있다. 만약 여러 개의 스레드가 RUNNABLE 
상태에 있다면 선택되기 위한 스레드 간 경합이 일어난다. 
따라서 특정 스레드의 정확한 동작 시점은 알수 없다. 

(2) JVM이 스레드의 run() 메서드를 호출하면 스레드가 동작한다. 
run() 메서드가 종료되면 스레드는 소멸(TERMINATE)된다. 
스레드가 소멸된다는 것은 스레드의 스택 자체가 없어지는 것이므로 
한번 소멸한 스레드는 더 이상 동작하지 않는다. 
만약, 이 스레드의 동작이 필요하다면 다시 스레드를 생성하고 
start() 하는 수밖에 없다. 

(3) 동작 중인 스레드는 스레드의 sleep(), wait(), join() 메서드가 호출되거나 
I/O에 의한 블로킹이 발생하는 경우 대기 풀(Waiting Pool)로 이동해서 
대기 상태(WAITING 또는 TIMED_WAITING)로 변경된다. 
대기 상태에서 스레드의 동작은 일시 정지된다. 

(4) 대기 상태의 스레드는 sleep()이나 join()의 시간 종료, wait()에 대한 
notify() 메서드 호출, interrupt() 메서드 호출, I/O 종료되는 경우 다시 
RUNNABLE 상태로 변경된다. RUNNABLE 단계의 스레드는 다시 처음처럼 
경합 과정을 거쳐 동작할 수 있다. 

(5) 동작 중인 스레드에서 yield() 메서드가 호출되면 스레드는 동작을 멈춘다. 
하지만  (3) 의 경우처럼 대기 상태로 이동하지는 않고 다시 
RUNNABLE 상태로 이동해서 경합하게 된다. 

BLOCKED 상태와 해지에 대해서는 뒤에서 다룬다. 

----------------------------------------------------
3.2 스레드 선택과 우선순위

스레드가 RUNNABLE 상태에서 선택될 때는 우선순위가 적용된다. 
예를들어 메신저에서 채팅과 파일 전송, 두개의 작업이 스레드로 진행 중이라고 
생각해보자. 둘 사이에 어떤 작업이 더 중요할까? 파일 전송은 잠시 멈춰도 
사실 불평이 거의 발생하지 않는다. 하지만 채팅 메시지가 바로바로 
전달되지 않으면 문제다. 이처럼 여러 스레드가 있을 때 특정 스레드가 
가급적 먼저 실행되기 위해서는 우선순위가 높은 것이 좋다. 

우선순위는 스레드의 중요도에 따라서 1~10 까지의 정수로 지정할 수 있다. 
Thread 클래스에는 자주 사용되는 우선순위들이 상수값으로 정의 
되어 있다. 

ex)
public final static int MIN_PRIORITY = 1;
public final static int NORM_PRIORITY = 5;
public final static int MAX_PRIORITY = 10;

이중 NORM_PRIORITY 가 기본값이다. 

스레드 우선순위는 setPriority()와 getPriority() 메서드로 
설정할수 있다. 

Thread 의 우선순위 관련 메서드 

메서드명 : 선언부와 설명 
setPriority() : public final void setPriority( int newPriority)
newPriority로 스레드의 우선순위를 설정한다. 

getPriority() : public final int getPriority()
스레드 우선순위를 리턴한다. 

우선순위를 적용한 스레드가 어떻게 동작하는지 예제를 통해
살펴보자. 

ex)
package ch14.status;

public class PriorityTest {
	static class MessengerThread extends Thread {
		public MessengerThread(String name) {
			super(name);
		}

		public void run() {
			for (int i = 0; i < 30; i++) {
				System.out.print(this.getName());
			}
		}
	}

	public static void main(String[] args) {
		Thread fThread = new MessengerThread("F");
		Thread tThread = new MessengerThread("T");
		fThread.setPriority(Thread.MIN_PRIORITY);
		tThread.setPriority(Thread.MAX_PRIORITY);
		fThread.start();
		tThread.start();
	}
}
// 매번 다름 
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
FFFFFFFTTTFTTTTTTTTTTTTTTTTTTTTTTTTTTTFFFFFFFFFFFFFFFFFFFFFF

실행 결과를 살펴보면 파일 전송 스레드를 먼저 시작했음에도 불구하고 
전반적으로 우선 순위가 높은 텍스트 전송 스레드가 더 앞부분에 실행되는 
것을 확인할수 있다. 하지만 우선순위가 높다고 해서 언제나 그 스레드가 
실행되는 것이 아니고 한번 시작했다고 해서 끝까지 동작하지도 않는다. 

이처럼 스레드 우선순위 의 역할은 실행될 확률이 높아지는 것뿐으로 우선순위
만으로는 스레드를 100% 제어할수 없다. 
----------------------------------------------------
3.3 sleep()을 통한 상태 제어 

sleep() 메서드는 동작하는 스레드를 주어진 시간 동안 일시 정지시켜 
대기풀에서 자게한다. 대기 중인 스레드는 설정 시간이 끝나거나 
interrupt() 메서드가 호출되면 대기 풀에서 벗어나 다시 RUNNABLE 
상태로 이동한다. 

Thread 의 sleep() 메서드 
메서드 명 : 선언부와 설명 

sleep() : public static native void sleep(long milis) throws InterruptedException
milis(1/1000초) 동안 동작중인 스레드를 대기풀에서 대기하게 한다. 
millis 가 지나면 자동으로 RUNNABLE 상태로 이동한다. 

public static void sleep(long milis, int nanos) throws InterruptedException
스레드를 (milis + nanos)까지 대기 풀에서 대기하게 한다. 
좀 더 세밀한 조절이 가능하다. 

스레드를 이용해서 초시계를 만들어 보자.  초시계는 1초에 한번씩
시간을 출력한다. 

ex)

package ch14.status;

import java.time.LocalTime;

public class SleepTest1 {

	public static void main(String[] args) {
		Timer timer = new Timer();
		timer.start();
	}

	static class Timer extends Thread {
		public void run() {
			for (int i = 0; i < 3; i++) {
				try {
					Thread.sleep(1000);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println("째깍: " + LocalTime.now());
			}
		}
	}
}
//
째깍: 08:49:02.065093600
째깍: 08:49:03.066546600
째깍: 08:49:04.066983700

반복문에서 sleep() 메서드를 호출해서 1000ms 즉 1초씩 
Thread를 대기 풀로 이동시킨다. 대기 풀에서 나온 후 다시 
RUNNABLE -> 동작의 단계로 이동하면 그 시점의 시각을 출력한다. 

출력 결과를 얼핏 살펴보면 1초씩 잘 증가하는 것처럼 보인다. 
하지만 나노초 단위까지 살펴보면 정확히 1초가 아님을 알수 있다. 
이것은 스레드가 대기 풀에서 1초를 쉬는 것은 정확하지만 이후 
RUNNABLE -> 동작 의 단계를 거쳐야 실행되므로 다시 실행되기 
위해서는 1초보다 더 걸릴수 밖에 없다. 

----------------------------------------------------
3.4 join() 을 통한 상태 제어 

556 /15/45

join() 메서드 역시 sleep()과 유사하게 스레드를 대기 풀로 이동시키는 
메서드이다. 
join()은 다른 스레드와의 선후 관계가 있을 때 사용되는데 다른 스레드의 작업이 
종료될때까지 join()을 호출하는 스레드가 대기 풀에서 대기한다. 
다른 작업을 나의 작업에 참여 시킨다(join)는 의미로 이해하면 좋다. 

Thread의 join() 메서드 

메서드 명 : 선언부와설명

join() : public final void join() throws InterruptedException
스레드가 소멸될때까지 대기한다. 

public final synchronized void join(long milis) throws InterruptedException
스레드가 소멸되는지 milis 간격으로 체크하고 소멸될때까지 대기한다. 

public final synchronized void join(long milis, int nanos) throws InterruptedException
nanos 까지 동원해서 좀 더 세밀하게 스레드 상태를 체크한다. 

예를들어 로봇을 만드는 애플리케이션을 스레드로 만들어보면 팔을 만드는 스레드,
몸통을 만드는 스레드, 조립하는 스레드로 구성할 수 있다. 
이들을 각기 자유롭게 작업하는데 조립 스레드는 팔과 몸통 스레드의 작업이 
끝나야만 작업이 가능하다. 이때 join()을 사용하면 조립 작업에 팔과 몸통 스레드를 참여시켜
끝날 때까지 대기한다. 

메인스레드
main(){
//팔작성 스레드.start()
//몸통 작성 스레드.start()
//조립 스레드.start()
}

팔 작성 스레드 
run(){
// do something
}

몸통 작성 스레드 
run(){
// do something 
}

조립 스레드 
run(){
//팔작성 스레드.join()
//몸통 작성 스레드.join()
//do something
}

팔 및 몸통 작성이 끝나면 조립 .

다음 예는 메인 스레드와 9개의 구구단 스레드가 동작하는 구구단 프로그램.
9개의 스레드는 각각의 단을 배열에 저장한다. 단 숫자를 곱할 때마다 
1초씨 sleep()을 호출해서 쉰다. 
메인 스레드에서는 구구단 스레드들이 각 단을 완성하면 최종 결과를 출력한다. 

ex)
package ch14.status;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class JoinTest {
	static class GuguThread extends Thread {
		private int dan;
		String[] result = new String[9];

		public GuguThread(int dan) {
			this.dan = dan;
		}

		public void run() {
			for (int i = 1; i < 10; i++) {
				result[i - 1] = dan + "*" + i + "=" + (dan * i);
				try {
					Thread.sleep(1000);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
			System.out.print(dan + "단완료\t");
		}
	}

	public static void main(String[] args)  {
		List<GuguThread> gugus = new ArrayList<>();

		for (int i = 1; i < 10; i++) {
			GuguThread gugu = new GuguThread(i);
			gugus.add(gugu);
			gugu.start();
		}

		for (GuguThread gugu : gugus) {
			try {
				gugu.join();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}

		System.out.println("\n구구단 출력");
		for (GuguThread gugu : gugus) {
			System.out.println(Arrays.toString(gugu.result));
		}
	}
}
//
1단완료	2단완료	3단완료	4단완료	5단완료	6단완료	7단완료	8단완료	9단완료	
구구단 출력
[1*1=1, 1*2=2, 1*3=3, 1*4=4, 1*5=5, 1*6=6, 1*7=7, 1*8=8, 1*9=9]
[2*1=2, 2*2=4, 2*3=6, 2*4=8, 2*5=10, 2*6=12, 2*7=14, 2*8=16, 2*9=18]
[3*1=3, 3*2=6, 3*3=9, 3*4=12, 3*5=15, 3*6=18, 3*7=21, 3*8=24, 3*9=27]
[4*1=4, 4*2=8, 4*3=12, 4*4=16, 4*5=20, 4*6=24, 4*7=28, 4*8=32, 4*9=36]
[5*1=5, 5*2=10, 5*3=15, 5*4=20, 5*5=25, 5*6=30, 5*7=35, 5*8=40, 5*9=45]
[6*1=6, 6*2=12, 6*3=18, 6*4=24, 6*5=30, 6*6=36, 6*7=42, 6*8=48, 6*9=54]
[7*1=7, 7*2=14, 7*3=21, 7*4=28, 7*5=35, 7*6=42, 7*7=49, 7*8=56, 7*9=63]
[8*1=8, 8*2=16, 8*3=24, 8*4=32, 8*5=40, 8*6=48, 8*7=56, 8*8=64, 8*9=72]
[9*1=9, 9*2=18, 9*3=27, 9*4=36, 9*5=45, 9*6=54, 9*7=63, 9*8=72, 9*9=81]

Thread.sleep()을 통해 1초씩 쉬면서 result 에 구구단을 저장한다. 
전체를 완성하는데 9초 이상의 시간이 소요된다. 

구구단을 저장하는 작업이 끝나면 완료 메시지를 남긴다. 

GuguThread들을 관리할 List 를 선언한다. 

9개의 GuguThread를 만들어서 List에 담고 start()를 호출해서 RUNNABLE
상태로 만든다. 

메인 스레드에서 각 GuguThread 객체의 join()을 호출함으로써 다른 
스레드가 종료될 때까지 메인 스레드는 대기 상태로 존재한다. 

모든 스레드가 종료 후 메인 스레드가 다시 
'RUNNABLE > 동작' 으로 상태를 변경하면서 구구단 내용을 출력한다. 

출력 결과를 살펴보면 9개의 스레드가 병렬로 동작하므로 순서 없이 구구단 
작성이 완료되고 모든 구구단 스레드들의 동작이 끝나면 마지막으로 메인 
스레드가 출력함을 알수 있다. 
40행의 join() 메서드 호출 부분을 주석 처리하고 실행해보면 차이점을 알수 
있다. 

----------------------------------------------------
3.5 interrupt()를 통한 대기 풀 탈출 

sleep()이나 join()으로 인해 대기 풀에서 대기 중인 스레드들은 지정된 시간이 
지나거나 끼워 넣었던 스레드가 종료되면 자동으로 RUNNABLE 상태로 
이동한다. 그런데 대기 중인 스레드를 임의로 RUNNABLE 상태로 이동시켜야 할 
경우도 있다. 예를 들어 미디어 플레이어를 만들고 있다면 재생 스레드에는 
일시 정지와 다시 시작이 필요하다. 
일시 정지는 재생 스레드가 언제 다시 시작할지 알수 없으므로 sleep()을사용 
할것이다. 특정 시점에 대기 중인 재생 스레드를 동작 시키려면 interrupt()를 
호출하면 된다. interrupt()는 대기 중인 스레드에게 InterruptedException을 
발생시켜 즉시 RUNNABLE 상태로 이동시킨다. 
sleep()과 join() 메서드가 InterruptedException을 throws 처리하는 이유는 
바로 interrupt() 의 필요성 때문이다. 

Thread 의 interrupt() 메서드 

메서드명 : 선언부와 설명 
interrupt() : public void interrupt()
대기 중인 스레드를 강제로 깨워서 RUNNABLE 상태로 바로 이동하게 한다. 

다음 예는 1분간 sleep() 하려는 MinuteAlarmThread를 메인 스레드에서 
10초만에 강제로 깨우는 과정을 처리하는 예이다. 

ex)

package ch14.status;

public class InterruptTest {
	static class MinuteAlarmThread extends Thread {
		public void run() {
			try {
				Thread.sleep(1000 * 60);
			} catch (InterruptedException e) {
				System.out.println("깜짝이야.");
			}
			System.out.println("시간이 되었습니다.");
		}
	}

	public static void main(String[] args) {
		Thread timeChecker = new MinuteAlarmThread();
		timeChecker.start();

		try {
			Thread.sleep(1000 * 10);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		
		timeChecker.interrupt();
	}
}
//
깜짝이야.
시간이 되었습니다.
//10초후 출력 

timeChecker의 run() 메서드에서는 sleep() 메서드를 호출해서 
1분(1000*60) 간 대기 상태에 존재하게 된다. 만약 이 스레드의 
interrupt()가 호출된다면 7행에 예외가 발생하고 8행을 통해 예외가 
처리된 후 나머지 동작 즉 11행부터 진행된다. 

메인 스레드 역시 sleep() 메서드를 통해 10초 동안 대기상태에 빠진다. 
이후 timeChecker의 interrupt()를 호출하면 timeChecker는 계획보다 
50초 빨리 깨어나서 동작한다. 

----------------------------------------------------
3.6 yield()를 통한 상태 제어 

sleep() 이나 join()은 스레드의 상태를 대기 상태로 변경하는 반면 
yield()는 대기상태로 변하지 않고 동일한 우선순위를 가진 다른 스레드에게 
실행을 양보하고 즉시 RUNNABLE 상태로 변경된다. 

Thread의 yield() 메서드 

메서드명 : 선언부와설명

yield : public static native void yield()
스레드 스케줄러에게 이 스레드가 실행을 양보할수 있음을 알려준다. 

ex)
package ch14.status;

public class YieldTest {
	static class YieldThread extends Thread {
		String symbol;

		public YieldThread(String symbol) {
			this.symbol = symbol;
		}

		public void run() {
			for (int i = 0; i < 60; i++) {
				if (i % 2 == 0) {
					System.out.print(symbol);
				} else {
					Thread.yield();
				}
			}
		}
	}
	
	public static void main(String[] args) {
		new YieldThread("_").start();
		new YieldThread("^").start();
	}
}
// 실행결과는 매번 달라짐 
_^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^_____________________________

----------------------------------------------------
3.7 스레드의 종료 

561 20/45

스레드는 run() 메서드가 끝나면 자동으로 종료된다. 그런데 내부의 상황에 의해 
스레드가 종료될 수도 있지만, 외부의 요건에 의해 스레드를 종료시켜야 
할 때도 있다. 이를 위해 Thread 클래스에는 stop() 메서드가 제공된다. 
하지만 이 메서드는 사용중지 권고(deprecated) 되어 있다. 
즉 더 이상 쓰면 안된다. 

Thread 종료를 위한 stop() 메서드 

stop() : public final void stop() 
스레드를 즉시 중지시킨다. 

이 메서드가 deprecated된 이유는 안전성을 위함이다. stop()
이 호출되면 스레드는 바로 강제 종료된다. 만약 스레드에서 다른 
파일이나 네트워크 연결 등 시스템의 다른 자원을 사용 중이었다면, 
이 자원을 반납할 기회가 없게 된다. 스레드를 안정적으로 종료시키기 
위해서는 플래그(flag)  값을 이용해서 내부에서 자연스럽게 종료할 수 
있도록 처리해야 한다. 

다음 예를 살펴보자. ResourceUseThread는 시작하면서 시스템 자원을 
사용한다. 이 스레드를 중지시키기 위해 stop() 메서드를 이용하는 경우와 
종료되는 상황을 만드는 경우 두가지를 사용해보자. 

ex)
package ch14.status;

import java.util.Scanner;

public class StopTest {
	static class ResourceUseThread extends Thread {
		boolean flag = true;

		public void run() {
			System.out.println("자원 획득");
			while (flag) {
				try {
					Thread.sleep(1000);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
                System.out.print("자원사용");
			}
			System.out.println("자원 반납");
		}
	}

	public static void main(String[] args) {
		ResourceUseThread t = new ResourceUseThread();
		t.start();

		Scanner scan = new Scanner(System.in);
		if (scan.nextLine().equals("s")) {
			t.stop();
		} else {
			t.flag = false;
		}
		scan.close();
		System.out.println("main over");
	}
}
//s 이외의 문자를 입력하는 경우 
자원 획득
자원사용자원사용자원사용자원사용
main over
자원사용자원 반납
!
//s 문자를 입력하는 경우 
자원 획득
자원사용자원사용자원사용자원사용
main over

ResourceUseThread의 동작을 정지시킬 것인지 파악하기 위한 플래그 
값을 설정한다. 

run() 메서드 내부에서 자원을 획득한 후 flag가 true 인 경우 반복문 
내에서 자원을 사용한다. 만약 반복문이 종료된다면 19행처럼 
자원이 반납된다. 

ResourceUseThread 타입의 t 객체를 만들고 시작시킨다. 

Scanner 를 통해 's'를 입력받으면 t의 stop() 이 호출된다. 
출력 결과를 보면 스레드는 자원을 반납하지 못하고 즉시 종료된다. 

's'이외의 입력을 받으면 t의 flag를 false로 바꿔 반복문이 종료되고 자원을 
성공적으로 반납하게 된다. 

한번 run() 메서드가 끝나서 종료된 스레드는 생존주기가 완전히 소멸된다
(TERMINATE). 이 말은 스레드 객체가 소멸(FINALIZE) 된다는 뜻이 아니라 
스레드가 동작하는 스택 자체가 없어진다는 뜻이다. 
한번 소멸된 스레드는 다시 start()를 통해서 RUNNABLE로 이동할수 없다. 
소멸된 스레드의 start() 메서드를 호출하면 IllegalAThreadStateException 
이 발생한다. 스레드는 반드시 NEW 인 상태에서만 start() 가 호출될수 있다. 

ex)
public class DeadThreadTest{
static class SomeThread extends Thread{
public void run() {
System.out.println("thread is over");
}
}
public static void main(String[] args) throws InterrupedException {
SomeThread sThread = new SomeThread();
sThread.start();
Thread.sleep(1000*1);
sThread.start(); // IllegalStateException 발생 
}
}

해당 스레드의 동작이 필요하다면 다시 새로운 스레드 객체를 생성하고 
start()를 호출해야 한다. 

563 22/45 
----------------------------------------------------
3.8 데몬 스레드

데몬 스레드(Daemon Thread)란 일반 스레드의 작업을 돕는 보조적인 스레드를 
말한다. 일반적으로 데몬 스레드들은 다른 스레드가 동작하지 않으면 의미가 
없는 경우가 많다. 예를들어 문서 편집 작업 도중에 한번씩 동작하는 
자동 저장 스레드는 편집기를 종료하는 순간 의미가 없어진다. 
자바 애플리케이션의 가비지 컬렉션의 경우도 JVM이 종료된다면 더이상
필요가 없다. 

이런 데몬 스레드는 스스로도 종료될수 있지만 다른 스레드들이 종료되는 상태에서도 
종료된다. 이 점만 빼면 다른 스레드와 동일하다. 

일반적으로 데몬 스레드들은 무한 루프를 이용해 run() 메서드 이후 대기 상태에 
있다가 조건에 따라 실행된다. 

데몬 스레드를 만들기 위해서는 Thread의 setDaemon() 메서드를 이용하면 되고 
데몬 스레드가 생성한 스레드들은 모두 데몬 스레드가 된다. 

Thread에서의 데몬 스레드 설정을 위한 setDaemon()메서드 

메서드 명 : 선언부와 설명 
setDaemon() : public final void setDaemon(boolean on)
:스레드를 데몬 스레드로 만들 것인지 설정한다. 

ex)
package ch14.status;

public class DaemonThreadTest {
	static class SaveDaemon extends Thread {
		public SaveDaemon() {
			this.setDaemon(true);
		}

		public void run() {
			while (true) {
				try {
					Thread.sleep(1000 * 5);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println("자동 저장함");
			}
		}
	}

	public static void main(String args[]) {
		Thread daemon = new SaveDaemon();
		daemon.start();

		for (int i = 0; i < 20; i++) {
			try {
				Thread.sleep(1000);
				System.out.println("작업 중... " + i);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		System.out.println("main over");
	}
}
//
작업 중... 0
작업 중... 1
작업 중... 2
작업 중... 3
자동 저장함
작업 중... 4
작업 중... 5
작업 중... 6
작업 중... 7
작업 중... 8
자동 저장함
작업 중... 9
작업 중... 10
작업 중... 11
작업 중... 12
작업 중... 13
자동 저장함
작업 중... 14
작업 중... 15
작업 중... 16
작업 중... 17
작업 중... 18
자동 저장함
작업 중... 19
main over

위 코드에서는 SaveDaemon 스레드가 종료되는 조건이 설정되어 있지 않다 
하지만, 데몬 스레드이기 때문에 메인스레드가 종료되는 순간 자동으로 
종료된다. 

----------------------------------------------------
4. 멀티스레드 의 문제점과 해결 

4.1 데이터 공유와 동기화 문제 

멀티스레드의 장점 중 하나는 공유 데이터를 여러 스레드에서 사용할수 있다는 점이다. 
하지만 이 점은 자칫 큰 문제를 일으킬 수도 있다. 한집(프로세스)에 두 자매(스레드)가 
하나의 옷(공유 데이터)을 같이 입는다면 어떤 문제가 발생하고 그 문제를 
어떻게 해결해야 할까? 뻔히 알고 있는 답을 전통적인 은행 시스템 예에서 
살펴보자. 

현실의 Banking 시스템을 생각해보면 계좌 하나(Account)를 은행 창구, 모바일 뱅킹, 
인터넷 뱅킹 등 다양한 방식으로 접근할 수 있다. 이때 계좌는 공유데이터가 되고 
접근 방식들은 스레드가 된다. 

ex)
Banking 애플리케이션
출금 스레드1 -> Account int balance; (공유데이터 ) <- 입금 스레드 1
출금 스레드2 -> Account int balance; (공유데이터 ) <- 입금 스레드 2

Banking 애플리케이션과 공유 데이터 

문제는 이 공유 데이터에 여러 스레드가 동시에 접근해서 수정하면서 발생한다. 

최초 Account의 balance에는 100원이 설정되어 있다. 이때 출금 스레드 1이 
100원 값을 읽고 20원을 출금해서 80원으로 만들 계획이다.
(아직 출금은 되지 않은 상태이다. ) 거의 동시에 출금 스레드 2가 역시 100원값을 
읽고 60원을 출금해서 40원으로 만들 계획을 잡는다. 스레드들이 
동작하면서 첫번째 스레드가 80원으로 변경하고 두번째 스레드는 40원으로 변경한다. 

출금스레드 1: 100 -> 100 - 20 

Account.balance : 100  80  40 

출금스레드 2 : 100 -> 100 - 60 

멀티스레드에서의 공유 데이터 신뢰성 문제 

결과적으로 두개의 스레드가 작업을 마치면 결과는 나중에 작업을 끝낸 출금 스레드 2
의 결과로 40 이 될것이다. 정학한 결과는 (20+60) 이 출금된 20원이 되어야함은 
너무 당연한 일이다. 이런 상황을 데이터의 신뢰성이 깨졌다고 한다. 

예제를 통해 문제가 되는 은행 시스템을 만들어보자. 

Account는 계좌 정보로 잔액을 나타내는 balance와 입금(deposit)
및 출금 (withdraw) 메서드로 구성된다. 

ex)
package ch14.banking;

public class Account {
	protected int balance;

	public Account(int balance) {
		this.balance = balance;
	}

	public int withdraw(int money) {
		String threadName = Thread.currentThread().getName();
		if (balance >= money) {
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			balance -= money;
			System.out.println(threadName+" 출금: 잔액: "+balance);
		} else {
			System.out.println(threadName+": 잔액 부족 출금 불가");
		}
		return balance;
	}

	public int deposit(int money) {
		return balance += money;
	}
}
//
567 26/45

package ch14.banking;

public class WithdrawThread extends Thread {
	Account account;
	int money;
	boolean flag = true;

	public WithdrawThread(String name, Account account, int money) {
		super(name);
		this.account = account;
		this.money = money;
	}

	public void run() {
		for (int i = 0; i < 6 || flag; i++) {
			int balance = account.withdraw(money);
			if (balance <= money) {
				flag = false;
			}
		}
	}
}
//

ex3)
package ch14.banking;

public class BankingClient {
	public static void main(String[] args) {
		Account account = new Account(5000);
		WithdrawThread iBanking = new WithdrawThread("인터넷뱅킹", account, 1000);
		WithdrawThread mBanking = new WithdrawThread("모바일뱅킹", account, 1000);
		iBanking.start();
		mBanking.start();
	}
}
//매번 다름
인터넷뱅킹 출금: 잔액: 4000
모바일뱅킹 출금: 잔액: 4000
모바일뱅킹 출금: 잔액: 2000
인터넷뱅킹 출금: 잔액: 2000
인터넷뱅킹 출금: 잔액: 0
모바일뱅킹 출금: 잔액: 0
인터넷뱅킹: 잔액 부족 출금 불가
인터넷뱅킹: 잔액 부족 출금 불가
모바일뱅킹: 잔액 부족 출금 불가
인터넷뱅킹: 잔액 부족 출금 불가
모바일뱅킹: 잔액 부족 출금 불가
모바일뱅킹: 잔액 부족 출금 불가

출력 결과를 살펴보면 이상한 점이 한 두개가 아니다.

총 5000 원을 1000원씩 출금하는데 8차례나 출금에 성공했다.
결과의 1,2 행을 보면 두 개의 스레드가 출금했는데 
잔액이 둘다 4000 원이다 . 
마지막을 보면 잔액이 출금액보다 작으면 출금할수 없었는데 최종 
잔액이 음수가 나왔다. 
 공유 데이터인 Account에 대한 신뢰가 완전히 깨진 상태다. 
----------------------------------------------------
4.2 공유 데이터의 동기화 처리 

위 문제는 은행 뱅킹과 인터넷 뱅킹 스레드가 거의 동시에 공유 데이터인 
Account에 접근해서 상태를 바꾸면서 발생했다. 
이런 공유 데이터에 대한 문제 해결에는 '세마포어(Semaphore)'라는 개념이 
사용된다. 세마포어란 열차 운행 시스템에서 사용하는 신호기를 말하는데 
stop(멈춤)과 clear (비어 있음) 두 상태를 갖는다. 

두 대의 열차(스레드가) 서로 반대 방향으로 운행하는 열차 노선을 생각해보자. 
당연히 복선으로 구성한다면 고민할 필요가 없겠지만 그리 많지 않은 운행 
횧수를 고려하면 전체를 복선으로 하기에는 자원의 낭비가 많다. 
따라서 많은 구간이 단선으로 처리된다. 그러다 보니 두 열차가 함께 운행하는 
단선의 공유 구간(공유 데이터)이 발생한다. 두대의 열차가 이 공유 구간에 
같이 들어서면 충돌이 발생할 것이다. 

<--                          ---
  S2   ---공유구간 ---S1
--                             -->

충돌을 피하기 위해서 A 열차는 공유 구간 진입 전에 선로가 비어 있는지, 
즉 세마포어 s1이 clear 상태인지 확인한다. 비어 있다면 진입이 가능하다.
공유 구간에 진입하면서 s1을 stop으로 바꿔서 공유 구간을 사용 중임을 
표시하면 s2 역시 stop 상태로 변경된다. 
만약 이때 열차 B가 공유 구간에 접근한다면 stop 신호를 보고 멈추게 된다. 
즉 동시에 공유 공간을 사용하지 못하게 하는 것이다. 

A가 공유 구간을 빠져나가면서 다시 s2를 clear로 변경하면 이제 B가 
공유 구간을 운행 할수 있게 된다. B는 다시 s2를 stop으로 변경 후 
공유 구간을 주행한다. 이 과정을 반복하면 구간 내 충돌이 발생하지 
않게 된다. 

멀티스레드 프로그래밍에서는 이 문제를 해결하기 위해 lock 개념과 
synchronized 키워드를 사용한다. synchronized는 메서드 등 블록에 
사용하며 해당 영역(임계영역, critical section )은 동시에 하나의 스레드만 
사용할수 있도록 한다. 즉 공유 구간에 대한 설정이다. 
synchronized 구간을 사용하기 위해서 스레드들은 객체의 lock이 필요하다. 
모든 자바 객체는 lock을 가지고 있다. 

만약 스레드 t1이 synchronized 구간에 접근하려면 먼저 객체의 lock을 확인한다. 
만약 객체가 lock을 가지고 있다면 lock을 t1이 가져온 후 sychronized 영역을 
실행한다. t1 이 작업 중일 때 다른 스레드 t2가 접근한다면 역시 
lock을 확인해야 하는데 이미 t1이 가져가 버렸기 때문에 lock 이 없을 것이고 
t2는 t1이 lock을 반납할 때까지 기다린다. 
t1이 작업을 마치고 lock을 다시 공유 객체에게 반납하면 t2가 다시 lock을 
얻어서 작업을 수행한다. 

ex)
열차 운행 시스템과 멀티스레드 프로그래밍 

열차 운행 시스템 : 멀티스레드 프로그래밍 : Banking 애플리케이션 예 
열차  : 스레드 : iBanking, mBanking
선로 : 공유 객체 : account 
공유 구간 : 임계영역 : account 의 withdraw(), deposit() 
세마포어 : 락(lock) : account 객체의 lock 
세마포어 설치 : synchronized 영역 설정 : synchronized void withdraw()등 

(1) sychronized 키워드 사용 

synchronized 키워드는  메서드 또는 블록에 사용할 수 있다. 메서드에 
sychronized를 사용하는 것이 가장 간단한 방법이다. 하지만 만약 이 메서드 
내에 공유 데이터와 연관된 작업과 무관한 작업이 함께 있을 경우 공유 데이터와 
무관한 작업도 하나의 스레드만 사용 가능하기 때문에 성능상 좋지 않을수 
있다. 

ex)
public sychronized void method() {
// do something - 공유 데이터와 연관된 작업
// do something - 공유 데이터와 무관한 작업
}

반면 별도의 sychronized 블록을 만들고 대상 객체(target_object)를 
설정하면 공유 데이터와 연관된 작업과 그렇지 않은 작업을 분리할 
수 있다. 여기서 대상 객체는 lock 을 확인할 객체를 말한다. 

ex)
public void method() {
synchronized(target_object) {
// do something - 공유 데이터와 연관된 작업
}
// do something - 공유 데이터와 무관한 작업
}

sychronized 블록은 스레드들이 병행해서 수행할 수 없는 공간이므로 
이 블록이 많다면 멀티스레드의 성능이 그만큼 떨어진다. 
따라서 필요한 곳에서만 사용하는 것이 중요하다. 

컬렉션 프레임워크에서 ArrayList와 Vector 계열을 설명하면서 Vector는 
과거 버전으로 멀티스레드에 안전하지만, 성능이 좋지 않다고 설명했는데 
바로 synchronized의 사용 때문이다. Vector의 메서드들은 대부분 
synchronized 처리되어 있고 ArrayList는 그렇지 않다. 

ex)
/* Vector 의 size() */
public synchronized int size() {
return elementCount;
}

/* ArrayList 의 size() */
public int size() {
return size;
}

그럼 앞서 작성했던 Account를 수정해서 멀티스레드 환경에서 
안전한 synchronized 버전의 SynchronizedAccount를 만들어보자. 

ex)
package ch14.banking;

public class SynchronizedAccount extends Account {

	public SynchronizedAccount(int balance) {
		super(balance);
	}

	public synchronized int withdraw(int money) {
		String threadName = Thread.currentThread().getName();
		if (balance >= money) {
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			balance -= money;
			System.out.println(threadName + " 출금: 잔액: " + balance);
		} else {
			System.out.println(threadName + ": 잔액 부족 출금 불가");
		}
		return balance;
	}

	public synchronized int deposit(int money) {
		return balance += money;
	}
}

로직은 변경된 부분이 없고 단지 withdraw() 와 deposit() 메서드 
선언부에 synchronized만 추가되었다. 
이제 BankingClient2를 이용해서 SynchronizedAccount의 동작을 
살펴보자. 

ex2)
package ch14.banking;

public class BankingClient2 {
	public static void main(String[] args) {
		Account account = new SynchronizedAccount(5000);
		WithdrawThread iBanking = new WithdrawThread("인터넷뱅킹", account, 1000);
		WithdrawThread mBanking = new WithdrawThread("모바일뱅킹", account, 1000);
		iBanking.start();
		mBanking.start();
	}
}
//
인터넷뱅킹 출금: 잔액: 4000
인터넷뱅킹 출금: 잔액: 3000
모바일뱅킹 출금: 잔액: 2000
모바일뱅킹 출금: 잔액: 1000
모바일뱅킹 출금: 잔액: 0
인터넷뱅킹: 잔액 부족 출금 불가
인터넷뱅킹: 잔액 부족 출금 불가
인터넷뱅킹: 잔액 부족 출금 불가
인터넷뱅킹: 잔액 부족 출금 불가
모바일뱅킹: 잔액 부족 출금 불가
모바일뱅킹: 잔액 부족 출금 불가
모바일뱅킹: 잔액 부족 출금 불가

이제 출력 결과가 1000원씩 안정적으로 출금된 것을 확인할 수 있다. 
다만 아직 아쉬운 부분은 잔액 부족 상황에서 계속 인출을 시도하는 부분이다. 

(2) lock pool 
sychronized 블록을 실행하면서 lock을 획득하지 못한 스레드는 lock이 객체에 
돌아오기 전까지 실행할수 없는 BLOCKED 상태가 된다. 
BLOCKED 객체는 lock pool(락풀)에서 대기하고 있다가 객체의 lock이 반납되면 
다시 RUNNABLE 상태로 변경 후 다시 실행될수 있다. 

Lock에 의한 스레드 상태 변화 

RUNNABLE---> RUNNING(Lock 획득실패)
--->BLOCKED(락풀)---> RUNNABLE(선행 스레드의 Lock 반납)


----------------------------------------------------
4.3 wait() 아 notify(), notifyAll()

멀티스레드 환경에서 synchronized를 사용하면서 비효율성이라는 문제가 발생한다. 
현재 계좌의 잔액이 500원인 상황에서 1000원을 출금하는 스레드 t1과 
100원을 출금하는 스레드 t2, 그리고 5000원을 입금하는 스레드 t3가 있다고 
생각해보자. 

ex) 
출금(100원)스레드 t2 ->
출금(1000원)스레드 t1 -> Account.balance=500 sychronized int withdraw()<-
입금(5000원)스레드 t3 

t1 스레드가 출금을 위해 sychronized 영역인 withdraw()를 호출하면서 
lock을 획득하는데 잔액이 부족하므로 어차피 출금할 수 없다. 
t1이 lock을 반납하지 않은 시점에 t2가 접근해보지만, 이번에는 lock
이 없기 때문에 잔액이 있더라도 역시 출금할 수가 없다. 
사실 t1은 t3가 5000원을 입금하기 전까지는 동작해서 lock을 얻어봤자 
처리할 수 있는 일이 없는데 t2의 작업까지 방해하는 비효율적인 시스템 
인 것이다. 
이 문제는 wait()와 notify() 또는 notifyAll() 메서드를 통해 
보완할수 있다. 

스레드 비효율성 개선을 위한 Object의 메서드 

메서드 명 : 선언부와설명

wait() : public final void wait() throws InterrupedException
다른 스레드가 notify(), notifyAll()을 호출하기 전까지 현재 
스레드를 WAITING 상태로 유지한다. 

public final native void wait(long timeout) throws InterrupedException
다른 스레드가 notify(), notifyAll()을 호출하거나 timeout 시간이 
지나기 이전까지 스레드를 WAITING 상태로 유지한다. 

notify() : public final native void notify()
이 객체의 락이 필요한 스레드 하나를 WAITING 상태에서 RUNNABLE로 변경 
한다. 

notifyAll() : public final native void notifyAll()
이 객체의 락이 필요한 모든 스레드를 WAITING 상태에서 RUNNABLE로 변경 
한다. 

이 메서드들은 모두 Object 클래스에 선언되어 있으므로 모든 객체가 
사용할 수 있다. 메서드 호출 시 주의점은 wait() 메서드는 반드시 
synchronized 영역에서 호출되어야 하며 notify() 나 notifyAll()은 
객체의 락을 소유한 스레드가 호출해야 한다. 그렇지 않으면 
IllegalMonitorStateException 이 발생한다. 

스레드가 공유 객체의 lock을 가진 상태에서 wait() 메서드를 호출하면 
lock을 반납하고 대기 풀에서 WAITING 상태로 대기한다. 이후 다른 
스레드가 이 객체의 notify() 또는 notifyAll() 메서드를 호출하면 wait()
를 호출하고 대기 풀로 이동했던 스레드가 다시 RUNNABLE로 이동한다. 
이 두 메서드의 차이는 notify() 는 단 하나의 임의의 스레드를 
RUNNABLE 로 이동시키는 반면 notifyAll()은 모든 스레드를 RUNNABLE로 
이동 시킨다. 

wait() - notify()를 적용해서 시스템을 적용해보자. t1은 잔액이 
없다면 빈번히 lock을 얻고 withdraw()를 호출할 필요가 없다. 
이때 wait() 메서드를 사용한다. wait()를 호출한 스레드 t1은 
WAITING으로 상태가 바뀌어 대기 풀에서 대기한다. 
이제 t2는 방해자가 없으므로 잔고 범위 내에서 자유롭게 출금할 수 
있다. t3가 입금해서 비로소 t1의 출금이 가능해진 상황에서 t3는 
notify() 또는 notifyAll() 을 호출한다. 그 결과 t1은 RUNNABLE로 
다시 상태를 변경하고 실행될 수 있게 된다. 

기존의 Banking 시스템은 잔액이 부족해도 계속해서 인출을 시도한다. 
때문에 비효율적으로 동작하는데 이를 개선해보자. 

먼저 Account를 살펴보자.

ex)
package ch14.banking;

public class NotiAccount extends Account {

	public NotiAccount(int balance) {
		super(balance);
	}

	@Override
	public synchronized int withdraw(int money) {
		String threadName = Thread.currentThread().getName();
		if (balance >= money) {
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			balance -= money;
			System.out.println(threadName + ": 출금, 잔액: " + balance);
		} else {
			System.out.println(threadName+": 잔액 부족 출금 불가로 wait 호출");
			try {
				this.wait();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		return balance;
	}

	@Override
	public synchronized int deposit(int money) {
		String threadName = Thread.currentThread().getName();
		balance += money;
		this.notifyAll();
		System.out.println(threadName + ": 입금, 잔액: " + balance);
		return balance;
	}
}
//
잔액 부족시 account 객체의 wait() 메서드를 호출한다. 
이 코드를 실행한 스레드는 lock을 반납하고 상태가 WAITING
으로 변경된다. 

입금 후 account 객체에 대한 wait() 메서드를 호출한 스레드들을 
깨우기 위해 notifyAll() 메서드를 호출한다. 

다음으로 입금을 처리할 DepositThread이다. 
이 스레드는 5초 후 money를 Account에 입금하는 역할이다. 

ex2)
package ch14.banking;

public class DepositThread extends Thread {
	Account account;
	int money;

	public DepositThread(String name, Account account, int money) {
		super(name);
		this.account = account;
		this.money = money;
	}

	public void run() {
		try {
			Thread.sleep(1000 * 5);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		account.deposit(money);
	}
}
//
5초간 스레드는 WAITING 상태에 있다가 account에 money를 입금 
처리한다. 

마지막으로 클라이언트 코드를 살펴보자. 

ex3)
package ch14.banking;

public class BankingClient3 {
	public static void main(String[] args) {
		Account account = new NotiAccount(5000);
		WithdrawThread iBanking = new WithdrawThread("인터넷뱅킹", account, 1000);
		WithdrawThread mBanking = new WithdrawThread("모바일뱅킹", account, 1000);
		DepositThread tBanking = new DepositThread("텔레뱅킹", account, 10000);
		iBanking.start();
		mBanking.start();
		tBanking.start();
	}
}
//
인터넷뱅킹: 출금, 잔액: 4000
모바일뱅킹: 출금, 잔액: 3000
인터넷뱅킹: 출금, 잔액: 2000
모바일뱅킹: 출금, 잔액: 1000
인터넷뱅킹: 출금, 잔액: 0
모바일뱅킹: 잔액 부족 출금 불가로 wait 호출
인터넷뱅킹: 잔액 부족 출금 불가로 wait 호출
텔레뱅킹: 입금, 잔액: 10000
모바일뱅킹: 출금, 잔액: 9000
모바일뱅킹: 출금, 잔액: 8000
모바일뱅킹: 출금, 잔액: 7000
인터넷뱅킹: 출금, 잔액: 6000
인터넷뱅킹: 출금, 잔액: 5000

WithdrawThread 두 개와 DepositThread 하나를 생성하고 , 각각의 
start()메서드를 호출한다. 

출력 결과를 살펴보면 잔액이 부족한 시점에서 WithdrawThread는 불필요한 
출금을 시도하지 않고 WAITING 상태로 기다린다. DepositThread인 텔레뱅킹이
입금하고 notifyAll()을 수행하면 다시 RUNNABLE에서 동작을 재개한다. 

----------------------------------------------------
4.4 멀티스레드 와 컬렉션

멀티스레드와 컬렉션에 대해서 다시 한번 정리해보자. 멀티스레드 환경에서 
안전하다는 것은 메서드가 sychronized되어 있어서 한번에 하나의 스레드만 
사용 가능하다는 말이고 따라서 성능 문제가 발생할수 있다. 
다음 예는 Vector 와 ArrayList에 두개의 스레드가 데이터를 추가하는 예이다. 

ex)
package ch14.collection;

import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Vector;

public class ThreadSafeTest {
	static DecimalFormat df = new DecimalFormat("#,###ns");

	public static void test(List<Integer> list) throws InterruptedException {
		long start = System.nanoTime();
		Runnable r = () -> {
			try {
				for (int i = 0; i < 100; i++) {
					list.add(i);
				}
			} catch (Exception e) {
				String threadName = Thread.currentThread().getName();
				String exceptionInfo = e.getClass().getName() + " : " + e.getMessage();
				System.out.println(threadName + " : " + exceptionInfo);
			}
		};
		Thread t1 = new Thread(r, "t1");
		t1.start();
		Thread t2 = new Thread(r, "t2");
		t2.start();
		t1.join();
		t2.join();
		String elapsed = df.format(System.nanoTime() - start);
		System.out.println(list.getClass().getName() + ":" + list.size() + "개, 시간:" + elapsed);
	}

	public static void main(String[] args) throws InterruptedException {
		test(new Vector<Integer>());
		test(new ArrayList<Integer>());
		//test(Collections.synchronizedList(new ArrayList<>()));
	}
}
//예외가 발생하지 않았지만 문제 상황
java.util.Vector:200개, 시간:1,192,700ns
java.util.ArrayList:170개, 시간:538,000ns

//아주 운 좋은 경우
java.util.Vector:200개, 시간:20,134,000ns
java.util.ArrayList:200개, 시간:1,427,500ns

//대부분 예외가 발생하는 경우 
java.util.Vector:200개, 시간:1,258,500ns
t1 : java.lang.ArrayIndexOutOfBoundsException : Index 16 out of bounds for length 15
java.util.ArrayList:110개, 시간:651,400ns

파라미터로 List<Integer> 타입의 객체를 받는다. 

람다식을 이용해 Runnable 객체를 생성한다. run() 내부에서는 파라미터로 
받은 list를 사용한다. 이 람다식은 여러 스레드에서 사용되므로 list는 
스레드들의 공유 데이터가 된다. 

r을 이용해서 두개의 스레드를 생성하고 동작시킨다. 

join()을 이용해 두 스레드의 동작이 모두 끝나면 스레드 이름과 list에 
담긴 데이터 개수, 소요 시간을 출력한다. 

test()를 호출하면서 Vector아 ArrayList를 넘긴다. 

소스는 어렵지 않다. 하지만 스레드로 동작하다 보니 결과가 매우 
다양하다. 아주 운이 좋은 경우 두 스레드는 문제 없이 List에 데이터를 
담는다. 하지만 그 결과 Vector는 ArrayList보다  7배 이상 시간이 소요된다. 
synchronized의 영향으로 멀티스레드로서의 장점을 못 살리기 때문이다. 

두번째 출력 결과는 예외는 발생하지 않았지만 ArrayList의 결과는 오류이다. 
데이터는 200개가 있어야 하지만 20개의 데이터는 같은 자리에 추가 되었다. 
이것은 sychronized가 없는 결과로 사실 첫 번째 경우보다 더 문제다. 

대부분은 세 번째 경우처럼 ArrayIndexOutOfBoundsException 이 발생한다. 
이것은 ArrayList의 add() 메서드가 크기를 늘리는 부분과 데이터를 넣는 부분으로 
구성되는데 synchronized가 없는 상태에서 호출되므로 t1이 크기를 늘리러 가서 
아직 늘리지 못한 상황에서 t2가 새로운 자리에 값을 넣기 때문에 발생한다. 

ex)
public boolean add(E e) {
ensureCapacityInternal(size + 1); // Increments modCount!!!
elementData[size++] = e;
return true;
}

멀티스레드 환경에서 안전한 컬렉션을 사용하기 위해서는 Collections의 
synchronizedXXX 계열의 메서드를 사용한다. 

멀티스레드 환경을 위한 Collections의 메서드 

메서드 명 : 선언부와설명

synchronizedCollection() : public static <T> Collection<T>
sychronizedCollection(Collection<T> c)
c를 이용해 SynchronizedCollection 를 생성하고 리턴한다. 

synchronizedList() : public static <T> List<T> synchronizedList(List<T> list)
list를 이용해 SynchronizedList 또는 SynchronizedRandomAccessList
를 생성하고 리턴한다. 

sychronizedSet() : public static <T> Set <T> synchronizedSet(Set<T> s)
s를 이용해 SynchronizedSed를 생성하고 리턴한다. 

synchronizedMap() : public static <K, V> Map<K,V>
sychronizedMap(Map<K,V> m)
m을 이용해 SynchronizedMap를 생성하고 리턴한다.

위 메서드들은 이외에도 같은 패턴으로 synchronizedNavigableMap(),
sychronizedNavigableSet(), sychronizedSortedMap(),sychronizedSet()
이 제공된다. 

사용법은 평소 사용하던 컬렉션을 sychronizedXXX() 메서드의 파라미터로 
넣으면된다. 위 예에서 ArrayList를 바로 test()에 넣는 대신 
Collection.sychronizedList(new ArrayList<>())로 변경해보자. 

ex)
public static void main(String[] args) throws InterrupedException {
test(new Vector<Integer>());
test(Collections.synchronizedList(new ArrayList<>()));
}

//
java.util.Vector:200개, 시간:1,228,400ns
java.util.Collections$SynchronizedRandomAccessList:200개, 시간:453,400ns

실행 결과는 소요 시간은 ArrayList의 장점을 그대로 가지고 있으며 
데이터도 안전한 것을 확인할수 있다. 

----------------------------------------------------
5. 스레드 풀(Thread Pool) 활용 

5.1 스레드 풀의 개념 

구구단의 특정 단을 출력하는 스레드가 있다고 가정해보자. 총 9개의 스레드가 
생성돼서 짧은 동작을 마친 후 종료될 것이다. 스레드는 한 번 종료되면 재사용 
할수 없으므로 매번 처음부터 다시 생성 후 RUNNABLE 부터 동작해야 하는데 
이 과정에서 드는 비용도 만만치 않을 것이다. 

작업이 동시에 진행된다고는 하지만 사실 CPU도 한계가 있기 때문에 동시에 
아주 많은 작업을 처리하는 것은 무리다. 만약 실제 동시 처리 작업이 5개 
정도라고 가정한다면 나머지 4개의 스레드는 어차피 RUNNABLE 상태에 있을 
확률이 높다. 

이럴 때 스레드 풀(Thread Pool) 개념을 이용하면 쓸데없이 스레드가 
많이 만들어지고 소멸되는 과정을 없앨수 있다. 

스레드 풀은 미리 여러 개의 스레드를 만들어서 pool에 저장해 놓고 사용한다. 
만약 스레드가 필요한 경우 풀에 있는 스레드 중 하나를 사용하고 작업이 
끝나면 스레드를 종료시키지 않고 풀에 반납한다. 따라서 스레드 생성과 
소멸에 드는 비용을 크게 절감할수 있다. 

스레드와 스레드 풀의 차이 
ex1)
스레드 [Runnable] : 생성->동작->소멸
스레드 [Runnable] : 생성->동작->소멸
스레드 [Runnable] : 생성->동작->소멸

스레드 풀(ExecutorService)

작업 큐
[Runnable]...[Runnable] [Runnable] -> 작업 할당 -> 스레드 
스레드 [Runnable] [Runnable] 미리 생성된 스레드들 

스레드 풀에서 처리할 작업(Task)이 생기면 작업 큐에 넣어둔다. 이 
작업들은 Runnable 타입이다. 큐는 FIFO( First In, First Out) 구조로 
큐에 작업이 들어오면 미리 생성해 놓은 스레드들이 순서대로 하나씩 
처리하게 된다. 
자바에서는 스레드 풀을 위해 java.util.concurrent 패키지에 ExecutorService
인터페이스와 여러 클래스들을 제공한다. 

자바 스레드 풀의 상속 관계 

ThreadPoolExecutor->AbstractExecutorService->ExecutorService->Executor 

----------------------------------------------------
5.2 스레드 풀의 사용 

스레드 풀을 만들 때는 기본적으로 풀에 만들어 놓을 스레드의 개수를 정할수 있다. 
이것을 초기 스레드 개수라고 한다. 작업이 들어오면 스레드들에게 작업을 
할당하다가 할당할 스레드가 없어지면 최대 스레드 개수까지 추가로 생성한다. 
작업이 끝난 스레드들에 일정 시간(스레드 유지 시간) 이내에 새로운 작업이 
할당되지 않으면 최소 개수(코어 스레드 개수)를 남겨두고 모두 제거된다. 

스레드 풀을 생성할 때는 일반적으로 Executors 클래스에서 제공하는 팩토리 
메서드를 사용한다. 

스레드 풀 생성을 위한 Executors 의 팩토리 메서드 

메서드명 : 선언부와설명

newCachedThreadPool() : public static ExecutorService newCachedThreadPool()
처음 0개의 스레드에서 시작해서 Integer.MAX_VALUE 개까지 
스레드를 생성한다. 코어 스레드 수는 0이다. 

newFixedThreadPool() : public static ExecutorService
 newFixedThreadPool(int n Threads)
처음 0개의 스레드에서 시작해서 nThread 까지 
스레드를 생성한다. 코어 스레드 개수도 nThread 이다. 

이 메서드들은 내부적으로 ThreadPoolExecutor 를 생성해서 스레드 풀을 생성한다. 

ex)
public static ExecutorService newFixedThreadPool(int nThread){
return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS,
new LinkedBlockingQueue<Runnable>());
}

따라서 위 두 메서드가 제공하는 조건이 마음에 들지 않으면 직접 
Thread Pool Executor() 생성자를 호출할수도 있다. 

ThreadPoolExecutor의 생성자 

메서드명 : 선언부와설명

ThreadPoolExecutor() : public ThreadPoolExecutor(int corePoolSize,
int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable>
workQueue)
최대 maximumPoolSize까지 스레드를 생성할 수 있는 스레드 풀을 생성한다. 
unit 기준으로 keepAliveTime 이 지난 thread들은 corePoolSize까지만 
남기고 제거한다. 스레드에서 처리할 작업은 workQueue에서 관리한다. 

다음 코드는 ThreadPoolExecutor 를 통해서 직접 스레드 풀을 생성하는 예이다. 

ExecutorService es = new ThreadPoolExecutor(10, //코어 스레드 개수 
100, // 최대 스레드 개수 
120, // 최대 대기 시간 
TimeUnit.SECONDS, // 대기 시간 측정 단위 
new SynchronousQueue<Runnable>() // 작업 큐
)

(2)작업 생성 
스레드 풀에서 처리할 작업은 Runnable 또는 Callable 타입이다. 
이 둘은 모두 인터페이스로 스레드 동작 후 리턴할 값이 없을 경우는 
Runnable,  리턴할 값이 있을 경우는 Callable을 사용한다. 
Callable을 사용하기 위해서는 call() 메서드를 오버라이드하면 된다. 

다음은 java.util.concurrent.Callable 인터페이스이다. 

ex)
@FunctionalInterface
public interface Callable<V> {
V call() throws Exception;
}

Runnable과 Callable 모두 함수형 인터페이스로 람다식을 이용해서 
작성할 수 있다. 

(3)작업 처리 요청 
작업을 생성했다면 스레드 풀의 작업 풀에 작업을 넣어서 실행시킬 차례다. 
다음은 작업 처리를 요청하는 메서드들이다. 

작업 처리를 위한 ExecutorService의 메서드 

메서드 명 : 선언부와설명

submit() : <T> Future<T> submit(Callable<T> task)
task 를 작업 큐에 등록한다. 작업 처리 결과는 Future<T>를 통해 얻을수 있다. 

<T> Future<T> submit(Runnable task, T result)
task 를 작업 큐에 등록한다. result는 작업 처리 결과인 Future<T>의 
타입 파라미터로 사용된다. 
Future<?> submit(Runnable task)
task를 작업 큐에 등록한다. 작업 처리 결과는 Future<?>를 통해 얻을 수 있다. 

execute() : void execute(Runnable command)
command를 작업 큐에 등록한다. 

다음은 ExecutorService를 통해 Callable 타입의 작업을 처리하는 예이다. 
ExecutorService es = ...;
Callable callable = () -> {
// do something
return "callable 작업 종료";
};
Future<String> future = es.submit(callable);

(4)작업 완료 정보의 활용 
Callable의 작업 결과는 submit() 의 리턴 타입인 Future를 통해 확인할 수 있다. 
Future에 선언된 get() 메서드는 Callable 의 call() 에서 리턴한 값을 
리턴한다. 

Future의 주요 메서드 

메서드 명 : 선언부와 설명 

get() : V get() throws InterrupedException, ExecutionException 
작업이 완료될 까지 블로킹 되었다가 처리 결과인 V를 리턴한다. 

cancel() : boolean cancel(boolean mayInterruptIfRunning)
작업 처리가 진행중일 경우 취소 시킨다. 

isCancelled() : boolean isCancelled() 
작업이 취소 되었는지 여부를 리턴한다. 

isDone() : boolean isDone()
작업이 완료되었는지 여부를 리턴한다. 

Future의 메서드를 사용할 때 주의할 점은 submit()을 호출하자마자 
Future가 리턴되지만, 이 시점은 아직 Callable 작업이 종료되지 않은 
시점일 수 있다. 작업이 종료되지도 않았는데 Future의 get()에서 
결과를 리턴받을 수 있을까?

Future를 지연 완료 객체(Pending Completion Object)라고 하는데 이 객체를 
활용할 수 있는 시점은 리턴된 시점이 아니라 작업이 완료된 시점이기 때문이다. 
따라서 Future의 get() 메서드는 스레드 작업이 완전히 끝나기 전까지는 실행하는 
코드를 블로킹 시킨다. 이 메서드를 호출하기 위해서는 새로운 스레드에서 
처리해야 한다. 그렇지 않으면 기껏 스레드 풀을 통해 진행하려던 작업이 
순차 작업으로 처리될 수도 있다. 

ex)
Future<String> myFuture = es.submit(callable);
new Thread( ()->{
try{
System.out.println(myFeature.get());
}catch(Exception e) {
e.printStackTrace();
}
}).start();

(5) 스레드 풀 종료 
스레드 풀은 데몬 스레드가 아니므로 명시적으로 종료시킬 필요가 있다. 
스레드 풀을 종료시키기 위해서는 ExecutorService의 메서드들을 사용한다. 

종료와 관련된 ExecutorService의 메서드들 

메서드명 : 선언부와 설명 

shutdown() : void shutdown()
현재 진행중인 작업과 작업 큐의 작업이 모두 끝나면 스레드 풀을 종료한다. 
가장 안정적인 종료 절차이다. 

shutdownNow() : List<Runnable> shutdownNow()
현재 진행중인 작업을 interrupt 시켜버리고 스레드 풀을 즉시 종료한다. 
이때 작업 큐에 남은 작업의 목록을 리턴한다. 불안정한 상태의 종료가 
발생할 수 있다. 

awaitTermination() : boolean awaitTermination(long timeout, TimeUnit unit)
throws InterrupedException
shutdown()을 호출하고 timeout 이내에 모든 작업이 종료되면 true 를
리턴하고 그렇지 않은 경우 스레드들을 interrupt 시킨 후 false를 리턴한다. 

isShutdown() boolean isShutdown()
스레드 풀이 종료 단계에 있는지 리턴한다. 

isTerminated() : boolean isTerminated()
스레드 풀의 모든 스레드들이 다 종료돼서 안전히 소멸됐는지 리턴한다. 

이제까지 설명한 내용을 바탕으로 스레드 풀을 통해 구구단을 2차원 배열에 
저장해보자. 

ex)

package ch14.pool;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class ThreadPoolGuguTest {
	private static int[][] gugudan = new int[9][9];
	private static int dans = 0;
	public static void main(String[] args) throws InterruptedException, ExecutionException {
		int processCnt = Runtime.getRuntime().availableProcessors();
		System.out.println("VM에서 운용 가능한 프로세서 개수: " + processCnt);
		ExecutorService es = Executors.newFixedThreadPool(processCnt);
		System.out.println("작업 시작 전: " + es);

		Callable<String> callable = () -> {
			int dan = ++dans;
			for (int i = 1; i < 10; i++) {
				gugudan[dan - 1][i - 1] = dan * i;
			}
			return dan + " 작업 완료, " + Thread.currentThread().getName();
		};
		for (int i = 0; i < 9; i++) {
			Future<String> guguFuture = es.submit(callable);
			new Thread(() -> {
				try {
					System.out.println(guguFuture.get());
				} catch (Exception e) {
					e.printStackTrace();
				}
			}).start();
		}

		Thread.sleep(1000 * 5);
		System.out.println("작업 종료 후: " + es);
		for (int[] dans : gugudan) {
			for (int num : dans) {
				System.out.print(num + "\t");
			}
			System.out.println();
		}
		es.shutdown();
	}
}
//
VM에서 운용 가능한 프로세서 개수: 4
작업 시작 전: java.util.concurrent.ThreadPoolExecutor@3abfe836
[Running, pool size = 0, active threads = 0, 
queued tasks = 0, completed tasks = 0]
1 작업 완료, pool-1-thread-1
6 작업 완료, pool-1-thread-1
4 작업 완료, pool-1-thread-1
3 작업 완료, pool-1-thread-1
5 작업 완료, pool-1-thread-1
2 작업 완료, pool-1-thread-1
8 작업 완료, pool-1-thread-4
7 작업 완료, pool-1-thread-2
9 작업 완료, pool-1-thread-3
작업 종료 후: java.util.concurrent.ThreadPoolExecutor@3abfe836
[Running, pool size = 4, active threads = 0, 
queued tasks = 0, completed tasks = 9]
1	2	3	4	5	6	7	8	9	
2	4	6	8	10	12	14	16	18	
3	6	9	12	15	18	21	24	27	
4	8	12	16	20	24	28	32	36	
5	10	15	20	25	30	35	40	45	
6	12	18	24	30	36	42	48	54	
7	14	21	28	35	42	49	56	63	
8	16	24	32	40	48	56	64	72	
9	18	27	36	45	54	63	72	81	

스레드 풀의 크기를 결정하기 위해서 VM에서 사용 가능한 프로세서의 
개수를 조회한다. availableProcessors()에서 리턴하는 이 값은 실행환경에 
따라 다를수 있다. 

newFixedThreadPool()을 이용해서 스레드 풀을 생성하고 출력한다. 
아직 처리한 작업이 없기 때문에 출력 결과를 살펴보면 pool size등은 
모두 0이다. 

Callable 타입으로 작업을 생성한다. 작업은 구구단의 특정 단을 출력하는 것이고
완료 후 종료된 단의 정보와 함께 현재 스레드의 이름을 출력한다. 

반복문에서 submit() 메서드를 이용해 Callable 타입의 작업 9개를 제출한다. 
submit() 의 return 타입인 Future를 통해 값을 얻기 위해 별도의 스레드를 
동작시키고 그 내부에서 get()을 호출한다. 

5초후 스레드 풀 정보를 출력하면 풀에는 총 4개의 스레드가 있고 완료된 작업이 
9개 임을 알수 있다. 

gugudan 안에 모든 내용을 출력해서 값을 확인한다. 

스레드 풀을 종료시킨다. 


===================================
[자바 해바라기 정리] 15 Input-Output 

1. I-O 와 스트림 

1.1 스트림의 개념 

587 1/53

I/O 란 데이터의 입력(Input)과 출력(Output)을 함께 일컫는 말이다. 
이제까지의 예에서 키보드에서 발생하는 데이터를 Scanner를 통해 프로그램에서 
받아들이는 것이 입력이고 System.out.println()을 통해 프로그램의 값을 모니터로 
표현하는 것이 출력이다. 

자바의 I/O는 스트림(Stream)을 이용해서 데이터를 주고받는 구조로  되어 있다. 
스트림은 실생활에서 수도관에 비유할 수 있다. 수도관은 취수장에서 목적지인 
수도꼭지까지 한 방향으로만 계속 물을 흘려보낸다. 스트림도 마찬가지이다. 
스트림은 데이터의 소스에서 목적지까지 데이터를 이동시키는 일종의 통로이다. 
이때 데이터의 소스나 목적지를 노드(node)라고 부른다. 노드의 종류에는 키보드,
모니터는 물론 파일이나 메모리, 데이터베이스, 원격지의 다른 프로그램이 될수도 
있다. 이 노드에 연결된 스트림을 노드 스트림이라고 한다. 

스트림은 방향이 있는데 데이터를 받아들일 때는 InputStream(입력 스트림)이 
사용되고 데이터를 보낼 때는 OutputStream(출력 스트림)이 사용된다. 
스트림을 통해서 전송되는 데이터의 단위는 기본적으로 바이트(byte)이다. 
그런데 한글과 같은 문자들은 바이트로 처리되기 어렵다. 그래서 문자(char)
단위 데이터가 전송되기도 하는데 이때는 InputStream 대신 Reader를 사용하고, 
OutputStream 대신 Writer를 사용한다. 

ex)
자바 I/O 의 기본구조 

노드의 종류 
키보드, 모니터, 메모리, 파일, 데이터베이스, 네트워크 ...

노드 -> keyboard 입력스트림: InputStream, Reader-> Program 
Program -> 출력스트림 : OutputStream, Writer -> monitor 

(1)노드 스트림의 종류 
입출력과 관련된 I/O 스트림은 java.io 패키지에 선언된다. 
I/O 스트림은 전송되는 데이터 타입, 노드 타입, 그리고 방향에 따라 
매우 다양한 클래스가 제공된다. 
이 클래스들의 이름은 위 3가지 조건의 조합으로 구분되는데 원리만 
이해하면 쉽게 구별할수 있다. 

첫 번째 기준은 전송할 데이터의 타입이 byte 인가 char인가이다. 
byte 단위의 데이터가 이동할 경우 XXStream, char 단위의 데이터가 
이동할 때는 XXer이 된다. 컴퓨터의 모든 것은 byte로 이루어져 있기 
때문에 byte 스트림으로는 문자로 구성된 텍스트는 물론 영상과 같은 
바이너리(binary) 형태의 데이터도 전송할 수 있다. 반면 한글이나 
한자 같은 문자들은 한 글자가 2byte 이상으로 구성되어 있기 때문에 
byte 스트림으로 전송할 때 문자열이 깨지는 문제가 발생할 수 있다. 
그래서 텍스트를 전송할 때는 char 기반의 스트림을 사용하는 것이 
좋다. 

두번째 기준은 데이터의 이동 방향이다. 데이터를 읽어 들이면 
InputStream 또는 Reader, 출력하면 OutputStream 또는 Writer
가 된다. 

다음은 연결되는 노드의 타입이다. 노드 중 키보드와 모니터는 단방향이다. 
즉 키보드는 InputStream 또는 Reader만 연결이 가능하고, 모니터는 
OutputStream 이나 Writer가 연결된다. 다른 노드들은 일반적으로
양방향인데 파일과 연결할 때는 File, 다른 스레드와 연결에는 Piped, 
메모리를 이용할 때는 Array가 사용된다. Array는 저장할 데이터의 
타입에 따라 ByteArray, CharArray로 나뉜다. char 스트림의 경우 
String을 노드로 사용할 수도 있다. 이런 규칙들에 따라 노드 스트림을 
정리하면 다음과 같다. 

노드 스트림의 종류 

데이터 타입에 따라 
byte or char? 

방향에 따라 
입력 또는 출력?

노드 타입에 따라 

최종 노드 스트림 

1)byte->XXStream->InputStream->키보드->InputStream
2)byte->XXStream->InputStream->File->FileInputStream
3)byte->XXStream->OutputStream->모니터->OutputStream
4)byte->XXStream->OutputStream->File->FileOutputStream
5)byte->XXStream->OutputStream->ByteArray->
ByteArrayInputStream, ByteArrayOutputStream
6)byte->XXStream->OutputStream->Pipe->
PipedInputStream, PipedOutputStream

1)char->XXer->Reader->키보드->Reader
2)char->XXer->Reader->File->FileReader
3)char->XXer->Reader->CharArray->CharArrayReader
4)char->XXer->Reader->String->StringReader
5)char->XXer->Reader->Pipe->PipeReader

5)char->XXer->Writer->모니터->Writer
6)char->XXer->Writer->File->FileWriter
7)char->XXer->Writer->CharArray->CharArrayWriter
8)char->XXer->Writer->String->StringWriter
9)char->XXer->Writer->Pipe->PipeWriter


----------------------------------------------------
2. 노드 스트림

모든 스트림은 노드 스트림에서 시작하며 노드 스트림들의 최상위 
인터페이스는 키보드에 연결되는 InputStream과 Reader, 
모니터에 연결되는 OutputStream과 Writer이다. 
나머지 노드 스트림들은 노드만 변경될뿐 사용법은 동일하다. 

2.1 키보드를 이용한 InputStream 과 Reader 

589 3/53

먼저 데이터를 읽는 InputStream과 Reader에 대해서 알아보자. 

다음은 InputStream의 주요 메서드이다. 

InputStream의 주요 메서드 

메서드 명 : 선언부와 설명 

read() : public abstract int read() throws IOException
byte 하나를 읽어서 int로 반환한다. 더 이상 읽을 값이 없으면 -1을 리턴한다. 

public int read(bute b[]) throws IOException
데이터를 읽어서 b를 채우고 읽은 바이트의 개수를 리턴한다. 
0이 리턴되면 더 이상 읽을 값이 없는 상황이다. 

public int read(byte b[], int offset, int len) throws IOException
최대 len 만큼 데이터를 읽어서 b의 offset 부터 b에 저장하고 읽은 바이트
개수를 리턴 한다. 따라서 len + offset 은 b의 크기 이하여야 한다. 

close() : public void close() throws IOException
스트림을 종료해서 자원을 반납한다. 

available() : public int available() throws IOException
스트림으로 부터 읽어들일 수 있는 데이터의 크기를 리턴한다. 

skip() : public long skip(long n) throws IOException
스트림에서 n 만큼 건너 뛴다. 

mark() : public synchronized void mark ( int readLimit)
현재 읽고 있는 위치에 표시하며 reset()이 호출될 때 이 지점부터 
다시 읽을수 있다. readLimit 는 최대한 되돌릴수 있는 바이트 수이다. 

reset() : public synchronized void reset() throws IOException
스트림에서 읽는 위치를 mark()가 호출된 지점으로 되돌린다. 

markSupported() : public boolean markSupported()
스트림에서 mark()와 reset()이 지원하는지 리턴한다. 

read() 메서드는 스트림에서 데이터를 읽어 들인다. 첫번째 
read()는 하나의 바이트를 읽어서 리턴하는데 이상하게도 리턴 타입은 
byte 가 아니라 int 이다.  하지만 실상은 int의 맨뒤 8 bit에만 
실제로 데이터가 저장된다. 이 메서드의 읽은 결과가 -1 이면 
더 이상 읽을 데이터가 없음을 의미한다. 
다음 코드는 System 의 in 을 통해 InputStream을 얻어서 사용하는 예이다. 

ex)
package ch15.node.basic;

import java.io.IOException;
import java.io.InputStream;

public class InputStreamTest {

	public static void main(String[] args) {
		try (InputStream input = System.in) {
			int read = -1;
			while ((read=input.read())!=-1) {
				System.out.println("읽은 값: " + read+", 문자로: "+(char)read);
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}
//
abcd
읽은 값: 97, 문자로: a
읽은 값: 98, 문자로: b
읽은 값: 99, 문자로: c
읽은 값: 100, 문자로: d
읽은 값: 13, 문자로:  // \r
읽은 값: 10, 문자로: // \n 

System.in 을 이용해 InputStream을 획득한다. InputStream은 Closeable 인터페이스
를 구현하고 있으므로 try ~ with resource 문장을 이용하면 자동으로 
close()가 호출된다. 만약 try ~ with resource 문장을 사용하지 않으면 반드시 
finally 블록에서 close()를 호출해야 리소스 누수를 막을수 있다. 
System.in에서 리턴되는 InputStream의 실제 타입은 뒤에서 학습할 
BufferedInputStream 형태이다. 

input.read()를 이용해서 하나의 byte를 키보드로부터 읽은 후 그 값이 
-1 이 아니면 byte 와 char 로 형변환한 값을 출력 한다. 

591 5/53

실행 결과는 hi와 enter 키를 입력한 결과이다. h 와 i의 출력은 쉽게 
파악할 수 있으며 나머지 두 개는 enter 키의 결과이다. 
Windows에서 Enter 키는 '\r\n'을 유발한다. '\r'은 
carriage return 이라고 하며, '\n'은 line feed 또는 new line 을 의미한다. 

Windows의 경우 콘솔에서 Ctrl + z 를 입력하면 -1 이 스트림에 
전달되어 반복문이 종료된다. I/O 작업은 스레드의 블로킹을 유발하기 
때문에 성능에 대한 고민이 많이 필요하다. read()는 겨우 1바이트를 
읽는데 이때마다 스레드 블로킹이 유발되는 것은 아주 낭비를 초래한다. 
따라서 배열을 이용해서 여러 데이터를 한번에 읽는 방식을 추천한다. 
이 배열을 버퍼(buffer)라고 부른다. read(byte[])와 read(byte[], int, int)는
버퍼 단위로 데이터를 읽는다. 

다음은 버퍼를 이용해서 한 번에 10개씩 데이터를 읽는 예이다. 

ex)
package ch15.node.basic;

import java.io.IOException;
import java.io.InputStream;

public class InputStreamTest2 {

	public static void main(String[] args) {
		byte [] buffer = new byte[10];
		try (InputStream input = System.in) {
			int read = -1;
			while ((read=input.read(buffer))>0) {
				System.out.println("읽은 개수: " + read+", 문자열로: "+new String(buffer, 0, read));
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}

//
123456789
읽은 개수: 10, 문자열로: 123456789

읽은 개수: 1, 문자열로: 

123456789012345
읽은 개수: 10, 문자열로: 1234567890
읽은 개수: 7, 문자열로: 12345

서준아 안녕 아빠야
읽은 개수: 10, 문자열로: 섲서서�
읽은 개수: 10, 문자열로: ��아 안�
읽은 개수: 10, 문자열로: �� 아빠�
읽은 개수: 7, 문자열로: ��

한번에 10개의 byte를 읽기 위해 길이가 10인 byte[] buffer를 선언한다. 

buffer를 이용해서 10개씩 데이터를 읽어온다. 이 때 read()의 리턴값이 0보다 
큰 경우만 실제 데이터가 있는 경우이다. 윈도우에서는 ctrl + z를 
입력하면 0개의 데이터가 읽힌 채로 버퍼가 반환되고 반복문은 종료된다. 

buffer에서 읽은 byte의 개수만큼 이용해서 String을 생성후 출력한다. 

하지만 InputStream은 byte 단위의 전송이 이뤄지기 때문에 한 글자 2byte 이상으로 
이루어진 경우 처리가 어렵다. 위의 예제에서 한글을 입력하고 테스트 해보자. 

서준아 안녕 아빠야
읽은 개수: 10, 문자열로: 섲서서�
읽은 개수: 10, 문자열로: ��아 안�
읽은 개수: 10, 문자열로: �� 아빠�
읽은 개수: 7, 문자열로: ��

한글은 'ms949' 캐릭터 셋째(character set)에서는 2byte, 
'utf-8'에서는 3 byte를 사용한다. 
위 예는 'utf-8'이 사용된 결과이고 10byte 씩 읽어오므로 
3글자 + 1byte 만큼의 데이터가 전송되었다. 
맨 마지막 1byte 때문에 깨지는 문제가 발생한다. 따라서 전송될 
데이터가 문자일 경우는 char 단위의 Reader를 사용하는 것이 좋다. 

Reader 에서 제공되는 메서드들은 대부분 InputStream의 메서드와 유사하다. 
전반적으로 byte 가 char로 대체되는 형태이다. 

593 7/53

Reader의 주요 메서드 

메서드 명 : 선언부와설명

read() : public int read() throws IOException 
char 하나를 읽어서 int로 반환한다. 더 이상 읽을 값이 없으면 
-1 을 리턴한다. 

public int read(char cbuf[]) throws IOException
데이터를 읽어서 cbuf를 채우고 읽은 char의 개수를 리턴한다. 
0이 리턴되면 더 이상 읽을 값이 없는 상황이다. 

abstract public int read(char cbuf[], int off, int len) throws IOException
최대 len 만큼 데이터를 읽어서 cbut의 offset 부터 cbuf에 저장하고 읽은 
char 개수를 리턴한다. 따라서 len+off 는 cbuf의 크기 이하여야한다. 

public int read(java.nio.CharBuffer target) throws IOException
데이터를 읽어서 target에 저장한다. target은 cbuf를 대체한다. 

close() : public void close() throws IOException
스트림을 종료해서 자원을 반납한다. 

available() : public boolean ready() throws IOException
소스에서 데이터를 읽을 수 있는지 리턴한다. 

skip() : public long skip(long n) throws IOException
스트림에서 n 만큼 건너뛴다. 

mark() : public void mark(int readAheadLimit) throws IOException
현재 읽고 있는 위치에 표시하며 reset()이 호출될때 이 지점부터 
다시 읽을수 있다. readLimit는 최대한 되돌릴수 있는 바이트 수이다. 

reset() : public synchronized void reset() throws IOException
스트림에서 읽는 위치를 mark() 가 호출된 지점으로 되돌린다. 

markSupported() : public bool markSupported()
스트림에서 mark()와 reset() 이 지원하는지 리턴한다. 

다음 예에서 Reader를 이용해서 데이터를 읽는 과정을 확인해보자. 

ex)
package ch15.node.basic;

import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;

public class ReaderTest {

	public static void main(String[] args) {
		char [] buffer = new char[10];
		try (Reader reader = new InputStreamReader(System.in)) {
			int read = -1;
			while ((read=reader.read(buffer))>0) {
				System.out.println("읽은 개수: " + read+", 문자열로: "+new String(buffer, 0, read));
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}
//
12345678912345
읽은 개수: 10, 문자열로: 1234567891
읽은 개수: 6, 문자열로: 2345
//
서준아 안녕 좋은 아침 아빠야 오늘도 재미나게 놀아
읽은 개수: 10, 문자열로: 서준아 안녕 좋은 
읽은 개수: 10, 문자열로: 아침 아빠야 오늘도
읽은 개수: 10, 문자열로:  재미나게 놀아

문자열 단위의 데이터를 한꺼번에 읽기 위해 char[]인 buffer를 사용한다. 

키보드에는 byte 기반의 스트림이 기본적으로 연결되므로 InputStreamReader를 
이용해 char 기반 Reader로 변경한다. 이런 스트림을 보조 스트림(Processing Stream)
이라고 부르는데 뒤에 자세히 다룬다. 

자바 5 이전까지는 ReaderTest 처럼 InputStream이나 Reader를 이용해서 
키보드로부터 입력 받았지만, 자바5에서 Scanner가 추가된 이후로는 
Scanner를 이용하는 것이 훨씬 이득이다. 하지만 위 예제들은 
입력을 처리하는 가장 기본 예이므로 아주 중요하다. 

----------------------------------------------------
2.2 모니터를 이용한 OutputStream 과 Writer 

다음으로 출력을 위한 OutputStream을 알아보자. 

OutputStream의 주요 메서드 

메서드명 : 선언부와 설명 

write() : public abstract void write(int b) throws IOException
b의 내용을 char로 출력한다. 

public void write(byte b[]) throws IOException
b를 문자열로 변환해서 출력한다. 

public void write(byte b[], int off, int len) throws IOException
b의 off 부터 (off + len - 1 ) 만큼을 문자열로 변환해서 출력한다. 

close() : public void close() throws IOException
스트림을 종료해서 자원을 반납한다. close()는 내부적으로 
flush()를 호출한다. 

flush() : public void flush() throws IOException
버퍼가 있는 스트림에서 버퍼의 내용을 출력하고 버퍼를 비운다. 

OutputStream을 이용한 출력 예를 살펴보자. 

package ch15.node.basic;

import java.io.IOException;
import java.io.OutputStream;

public class OutputStreamTest {

	public static void main(String[] args) {
		try (OutputStream output = System.out) {
			String msg = "Hello 자바";
			output.write(msg.getBytes());
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}
//
Hello 자바

System.out 를 통해 OutputStream을 얻는다. System.out은 
PrintStream 타입이다. 

msg를 getBytes()를 이용해서 byte[]로 바꾸고 writer()로 출력한다. 

Writer는 OutputStream의 byte가 char로 대체된다. 

Writer의 주요 메서드 

메서드명 : 선언부와 설명 

write() : public void write(int c) throws IOException
b의 내용을 char로 출력한다. 

public void write(char cbuf[]) throws IOException
cbuf를 문자열로 변환해서 출력한다. 

abstract public void write(char cbuf[], int off, int len) throws IOException
cbuf의 off 부터 ( off + len -1 ) 만큼을 문자열로 변환해서 출력한다. 

public void write(String str) throws IOException
str을 출력한다. 

public void write(String str, int off, int len) throws IOException 
str의 off 부터 ( off + len -1 )만큼을 출력한다. 

append() : public Writer append(CharSequence csq) throws IOException
csq를 출력하고 Writer를 리턴한다. 

public Writer append(CharSequence csq, int start, int end) throws IOException
csq의 start 부터 end 까지를 출력하고 Writer를 리턴한다. 

public Writer append(char c) throws IOException
c를 출력하고 Writer를 리턴한다. 

close() : public void  close() throws IOException
스트림을 종료해서 자원을 반납한다. close()는 내부적으로 flush()를 호출한다. 

flush() : abstract public void flush() throws IOException
버퍼가 있는 스트림에서 버퍼의 내용을 출력하고 버퍼를 비운다. 

다음은 Writer를 활용하여 출력하는 예이다. 

ex)
package ch15.node.basic;

import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;

public class WriterTest {

	public static void main(String[] args) {
		try (Writer output = new OutputStreamWriter(System.out)) {
			String msg = "Hello";
			output.write(msg);
			output.append(" Java ").append("World");
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}
//
Hello Java World

기본 출력인 PrintStream은 byte 단위이므로 이를 char 단위로 바꾸기 위해 
OutputStreamWriter를 이용해서 Writer를 생성한다. 

writer() 또는 append()를 이용해 문자열을 출력한다. 

----------------------------------------------------
2.3 메모리 기반의 입/출력 처리 

ByteArrayInputStream과 ByteArrayOutputStream 및 
CharArrayReader 와 CharArrayWriter는 각각 프로그램의 
메모리에서 byte 와 char 단위의 입출력을 처리하는 스트림이다. 
문자열 기반의 데이터가 어떻게 처리되는지 살펴보자. 

ex)
package ch15.node.array;

import java.io.CharArrayReader;
import java.io.CharArrayWriter;
import java.io.IOException;
import java.util.Arrays;

public class MemoryIOTest {

	public static void main(String[] args) {
		char[] memory = "안녕 Java World".toCharArray();
		char[] buffer = new char[5];
		int read = 0;
		try (CharArrayReader cReader = new CharArrayReader(memory);
				CharArrayWriter cWriter = new CharArrayWriter();) {
			while ((read = cReader.read(buffer)) > 0) {
				cWriter.write(buffer, 0, read);
			}
			System.out.println(Arrays.toString(cWriter.toCharArray()));
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}
//
[안, 녕,  , J, a, v, a,  , W, o, r, l, d]

데이터 소스로 char[]  memory 를 사용한다. 

CharArrayReader가 buffer 만큼 읽은 데이터를 CharArrayWriter에게 출력한다. 

CharArrayWriter에 출력된 내용을 확인하기 위해 모니터에 출력한다. 

----------------------------------------------------
2.4 파일 기반의 입/출력 처리 

파일 기반의 입/출력은 프로그래밍 과정에서 가장 빈번히 사용된다. 
프로그래밍 과정에서 발생한 데이터를 파일에 저장하거나 파일의 내용을 
읽기, 복사나 이동 등은 모두 파일 기반 입/출력을 사용한다. 

먼저 File 에 대해 알아보자. 앞으로 클래스는 File, 물리적인 파일은 파일로 
표시한다. 

(1)File 
File은 가장 기본적인 입/출력 장치 중 하나로 파일과 디렉터리를 다루는 클래스이다. 
File을 통해서 파일의 크기, 속성, 이름, 경로에 대한 정보를 얻거나 생성, 삭제할수 있다. 
하지만 파일에서 데이터를 읽고 쓰는 것은 스트림을 통해서만 가능하다. 

File 의 생성자에 대해 알아보자. 

File 생성자 
생성자 명 : 선언부와설명

File() : public File(String pathname)
pathname에 해당하는 파일을 생성한다. 만약 경로 없이 파일을 생성하면 
애플리케이션을 시작한 경로가 된다. 

public File(String parent, String child)
parent 경로 아래 child를 생성한다. 

public File(File parent, String child)
parent 경로 아래 child를 생성한다. 

public File(URI uri)
file로 시작하는 URI 객체를 이용해 파일을 생성한다. 

위의 File 생성자를 통해서 File 객체를 만들었다고 해도 물리적인 파일이 생성되는 
것은 아니다. 실제 파일을 생성하기 위해서는 createNewFile()이나 mkdir() 과
같은 메서드를 사용한다. 

파일의 경로를 구분할 때는 구분자가 사용되는데 문제는 운영체제마다 다르다는 점이다. 
예를들어 Windows의 경우 '/' 또는 '\'가 사용되고 UNIX 계열에서는 '/'만 사용된다. 
이처럼 시스템 종속적인 상황은 자바의 장점인 시스템 독립적인 애플리케이션에 문제가 
될수 있다. 가급적 File이 제공하는 상수값인 separator를 사용하면 시스템의 구분자를 
사용할수 있다. 
다음은 물리 파일을 생성 및 삭제하는 메서드들이다. 

파일 생성, 소멸 관련 메서드 

메서드 명 : 선언부와 설명 

createNewFile() : public boolean createNewFile() throws IOException
새로운 파일을 생성한다. 

mkdir() : public boolean mkdir()
새로운 디렉터리를 생성한다. 

mkdirs() : public boolean mkdirs()
경로상에 없는 모든 디렉토리를 생성한다. 

delete() : public boolean delete()
파일 또는 디렉터리를 삭제한다. 

deleteOnExit() : public void deleteOnExit()
애플리케이션이 종료될 때 자동으로 파일 또는 디렉터리를 삭제한다. 

실제 파일의 생성과 삭제를 테스트해보자. 

ex)
package ch15.node.file;

import java.io.File;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;

public class FileTest {

	public static void main(String[] args) throws IOException, URISyntaxException {
		String dirName = "c:"+File.separator+"Temp"+File.separator+"mydir";
		File file1 = new File(dirName);
		file1.mkdir();
		File file2 = new File(dirName, "test2.txt");
		file2.createNewFile();
		File file3 = new File(file1, "test3.txt");
		file3.createNewFile();
		File file4 = new File(new URI("file:///c:/Temp/test4.txt"));
		file4.createNewFile();
		file4.deleteOnExit();
	}
}
//
위 프로그램을 실행하면 C:/Temp 경로 아래 생성한 파일들을 확인할 수 있다. 
다만 test4.txt 파일은 애플리케이션이 종료되면서 삭제된다. 

이 외에도 File에는 다양한 메서드들이 제공된다. 

File 의 주요 메서드 

메서드 명 : 선언부와설명

getName() : public String getName()
파일의 이름을 리턴한다. 

getParent() : public String getParent()
파일의 부모 디렉터리 이름을 리턴한다. 

getParentFile() : public File getParentFile()
파일의 부모 디렉터리를 File 타입으로 리턴한다. 

getPath() : public String getPath() 
파일의 경로를 리턴한다. 

isAbsolute() : public boolean isAbsolute()
경로 이름이 절대경로인지 리턴한다. 
UNIX 계열을 /로 시작하고 Windows의 경우 드라이브 
문자로 시작하는 경우가 절대경로이다. 

getAbsolutePath() : public String getAbsolutePath()
파일의 절대 경로를 리턴한다. 

getCanonicalPath() : public String getCanonicalPath() throws IOException
파일의 정식 경로를 리턴한다. 정식 경로는 절대 경로이며 경로 내에  .
또는 .. 의 상대 경로 기호가 없는 경로이다. 

toURI() : public URI toURI()
파일을 URI 형태로 표현한다. 

canRead() : public boolean canRead()
파일이 읽을 수 있는 상태인지 리턴한다. 

canWrite() : public boolean canWrite()
파일이 쓸 수 있는 상태인지 리턴한다. 

isDirectory() : public boolean isDirectory()
파일이 디렉터리인지 리턴한다. 

isFile() : public boolean isFile()
파일이 파일인지 리턴한다. 

length() : public long length()
파일의 길이를 리턴한다. 

list() : public String[] list()
파일이 디렉터리인 경우 자식 파일들의 이름을 배열로 리턴한다. 

listFiles() : public File[] listFiles()
파일이 디렉토리인 경우 자식 파일들을 File[] 형태로 리턴한다. 

lastModified() : public long lastModified()
파일의 최종 편집일을 long 값으로 리턴한다. 

renameTo() : public boolean renameTo(File dest)
파일의 이름을 dest로 변경한다. 

다음은 File 클래스를 이용해 현재 경로의 파일 정보를 출력하는 예이다. 

ex)
package ch15.node.file;

import java.io.File;
import java.util.Date;

public class UseFileTest {

	public static void main(String[] args) {
		File currentDir = new File(".");
		if (currentDir.exists()) {
			File[] childs = currentDir.listFiles();
			for (File child : childs) {
				Date time = new Date(child.lastModified());
				String name = child.getName();
				long length = child.length();
				if (child.isDirectory()) {
					name = "[" + child.getName() + "]";
				}
				System.out.printf("%-20s\t%tF %<tT\t%s%n", name, time, length);
			}
		}
	}
}
//
.classpath          	2019-03-12 14:09:37	644
[.git]              	2019-03-12 14:09:38	4096
.gitignore          	2019-03-12 14:09:36	893
.project            	2019-03-12 14:09:37	386
[.settings]         	2019-03-12 14:09:36	0
config.properties   	2019-05-02 17:58:34	103
mylog_0.log         	2019-03-25 09:19:49	1593
[src]               	2019-03-28 11:02:50	4096
[target]            	2019-03-12 14:09:35	0

현재 경로를 나타내는 상대경로 기호'.' 를 이용해서 
File 객체를 생성한다. 현재 경로는 애플리케이션이 실행되는 
경로로 프로젝트 워크스페이스를 나타낸다. 

파일이 존재한다면 하위 파일 또는 경로의 상세정보를 출력한다. 

(2) FileInputStream과 FileOutputStream을 이용한 복사 
Windows 환경에서 FileInputStream과 FileOutputStream을 이용하여 
C:/Windows/explorer.exe 파일을 
C:/Temp 디렉터리로 복사해보자. 

ex)
package ch15.node.file;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class CopyTest {

	public static void main(String[] args) {
		File src = new File("c:" + File.separator + "windows" + File.separator + "explorer.exe");
		File target = new File("c:" + File.separator + "Temp" + File.separator + "explorer.exe");
		try (FileInputStream input = new FileInputStream(src);
				FileOutputStream output = new FileOutputStream(target)) {
			byte[] buffer = new byte[100];
			int read = 0;
			while ((read = input.read(buffer)) > 0) {
				output.write(buffer, 0, read);
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}

/*if(target.exists()) {
	String fileName = target.getAbsolutePath();
	String ext = fileName.substring(fileName.lastIndexOf("."), fileName.length()-1);
	target.renameTo(new File(fileName.replace(ext, "_"+System.currentTimeMillis()+ext)));
}*/
//

복사할 소스 파일과 타깃 파일 객체를 생성한다. 

try ~ with resource 문장에서 FileInputStream과 FileOutputStream을 생성한다. 
따라서 try 블록이 끝나면 두개의 스트림은 자동으로 close()가 호출된다. 

buffer를 이용해서 한번에 100바이트씩 읽어서 output으로 출력한다. 

실행 결과로 C:/Temp/explorer.exe 파일이 있는지 확인하고 실행해보자. 
탐색기가 잘 실행되면 성공이다.  전체적인 소스는 키보드나 모니터를 사용할 때와 
크게 다르지 않다. 다만 노드가 파일로 바뀌었을 뿐이다. 

파일 스트림 관련 생성자들은 파일에 대한 정보를 파라미터로 받는데 만약 
해당 파일이 존재하지 않으면 FileNotFoundException을 발생시킨다. 

FileInputStream과 FileOutputStream 생성자 

메서드 명 : 선언부와설명

FileInputStream() : 
public FileInputStream(String name) throws FileNotFoundException
name 경로의 파일을 읽는 FileInputStream을 생성한다. 

public FileInputStream(File file) throws FileNotFoundException
file 을 읽는 FileInputStream을 생성한다. 

FileOutputStream() : 
public FileOutputStream(String name) throws FileNotFoundException
name 경로의 파일에 출력하는 FileOutputStream 을 생성한다. 

public FileOutputStream(String name, boolean append) throws FileNotFoundException
name 경로의 파일에 출력하는 FileOutputStream을 생성한다. 
만약 기존에 파일이 있다면 뒤에 이어 쓴다. 

public FileOutputStream(File file) throws FileNotFoundException
file에 출력하는 FileOutputStream을 생성한다. 

public FileOutputStream(File file, boolean append) throws FileNotFoundException
file에 출력하는 FileOutputStream을 생성한다. 만약 기존에 파일이 있다면 
뒤에 이어쓴다. 

파일을 출력할 때 주의할 점은 파일 정보만을 사용하는 FileOutputStream은 
이미 대상 파일이 존재할 때 덮어 쓰게 된다. 대신 boolean 타입의 
append를 파라미터로 받는 생성자를 사용하면 덮어쓰지 않고 뒤에 
추가한다. 하지만 텍스트 파일이라면 관계없지만, 이미지, 동영상 등 
바이너리 파일은 뒤에 추가할 경우 원래처럼 동작하지 않는다. 
따라서 사용하기 전에 먼저 파일이 존재하는지 확인하고 처리하는 것도 
좋은 습관이다. 
다음은 파일 생성후 기존에 동일 이름의 파일이 있다면 타깃의 이름에 
시스템 시간을 붙여 충돌을 방지하는 예이다. 

ex)
if(target.exists()) {
String fileName = target.getAbsolutePath();
String ext = fileName.substring(fileName.lastIndexOf("."), fileName.length()-1);
target.renameTo(
new File(fileName.replace(ext,"_"+System.currentTimeMillis()+ext)));
}

(3)FileReader와 FileWriter 를 이용한 문서 작성 

FileReader와 FileWriter 는 문자 단위의 데이터를 파일에서 읽고 
쓰는 스트림이다. 

FileReader와 FileWriter 생성자 

생성자명 : 선언부와설명

FileReader() : 
public FileReader(String fileName) throws FileNotFoundException
fileName 경로의 파일을 읽는 FileReader를 생성한다. 

public FileReader(File file) throws FileNotFoundException
file을 읽는 FileReader를 생성한다. 

FileWriter()
public FileWriter(String fileName) throws IOException
fileName 경로의 파일에 출력하는 FileWriter를 생성한다. 

public FileWriter(String fileName, boolean append) throws IOException
fileName 경로의 파일에 출력하는 FileWriter를 생성한다. 
만약 기존에 파일이 있다면 뒤에 이어쓴다. 

public FileWriter(File file) throws IOException
file 에 출력하는 FileWriter를 생성한다. 

public FileWriter(File file, boolean append) throws IOException
file에 출력하는 FileWriter를 생성한다. 만약 기존에 파일이 있다면 
뒤에 이어쓴다. 

이번에는 Scanner를 통해 키보드로부터 입력받은 일기의 내용을 기존 파일에 
이어서 출력하고 다시 파일의 내용을 읽어서 화면에 출력하도록 처리 해보자. 

다음 그림은 처리 과정을 간략하게 그림으로 표현한 것이다. 

FileReader와 FileWriter를 이용한 문서 작성 과정 

키보드->System.in->FileWriter->diary.txt->FileReader->System.out->모니터 

ex)
package ch15.node.file;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Date;
import java.util.Scanner;

public class EditFileTest {

	public static void main(String[] args) {
		File target = new File("c:" + File.separator + "Temp" + File.separator + "diary.txt");

		try (Scanner scanner = new Scanner(System.in);
				FileWriter writer = new FileWriter(target, true);
				FileReader reader = new FileReader(target);) {
			writer.write("\n시작 - " + new Date() + "\n");
			String str = null;
			while (true) {
				str = scanner.nextLine();
				if (str.equals("x")) {
					break;
				} else {
					writer.write(str + "\n");
				}
			}
			writer.flush();// 버퍼의 내용을 출력하고 비움

			char[] buffer = new char[10];
			int read = -1;
			while ((read = reader.read(buffer)) > 0) {
				System.out.print(String.valueOf(buffer, 0, read));
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}
//
서준아 안녕 오늘 하루 재미나게 놀아~~ 나중에 보자^^
x

시작 - Wed May 08 12:45:24 KST 2019
서준아 안녕 오늘 하루 재미나게 놀아~~ 나중에 보자^^

스트림을 통해서 읽을 소스이며 출력 대상인 
target을 C:/Temp/diary.txt 로 설정. 

필요한 스트림 관련 요소들을 선언한다. 
Scanner는 그날의 일기 내용을 키보드로 부터 받기 위해 사용한다. 
FileWriter와 FileReader는 target에 쓰거나 읽기 위해 사용된다. 

그날의 일기를 작성하기 전에 날짜를 파일에 출력한다. 

scanner를 통해 읽은 값이 'x'와 같으면 반복문을 종료하고 그렇지 않으면 
파일에 출력한다. 

flush()를 통해 버퍼에 남아있는 내용을 출력한다. 
다 차지 않은 버퍼(예를 들어 10개의 byte 를 읽을 수 있는데 5개만 읽은 경우)
는 더 데이터가 쌓이기를 기다리는데 더 이상 값이 없으므로 바로 출력시키는 
역할을 하는 것이 flush()이다. 

FileReader를 통해 읽은 내용을 문자열로 변환 후 모니터에 출력한다. 

----------------------------------------------------
2.5 다른 스레드와의 통신을 위한 스트림 

606 20/53

스레드 간의 통신을 위해서는 PipedInputStream/PipedOutputStream이나 
Piped Reader/PipedWriter 가 사용된다. 이들이 다른 스트림과 다른 점은 
사용 전 connect() 메서드를 이용해서 서로 연결해줘야 한다는 점이다 

ex) Pipe 계열의 스트림 사용 
ReadThread	    WriteThread
PipeReader->connect()->PipedWriter

또한, 한쪽의 스트림을 close()로 종료시키면 연결된 반대쪽의 스트림은 
자동으로 종료된다. 데이터를 읽고 쓰는 과정은 다름 스트림과 동일하다. 

ex)
package ch15.node.piped;

import java.io.IOException;
import java.io.PipedReader;
import java.io.PipedWriter;

public class PipedTest {

	public static void main(String[] args) throws IOException {
		PipedReader pReader = new PipedReader();
		PipedWriter pWriter = new PipedWriter();
		pReader.connect(pWriter);

		new ReadThread(pReader).start();
		new WriteThread(pWriter).start();
	}
	static class WriteThread extends Thread{
		PipedWriter pWriter;
		
		public WriteThread(PipedWriter writer) {
			this.pWriter = writer;
		}
		public void run() {
			try{
				pWriter.write(Thread.currentThread().getName()+"에서 출력함");
				pWriter.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}

	static class ReadThread extends Thread {
		PipedReader pReader;
		
		public ReadThread(PipedReader reader) {
			this.pReader = reader;
		}
		public void run() {
			char [] buffer = new char[20];
			int read = -1;
			try {
				while((read = pReader.read(buffer))>0) {
					System.out.println("입력 받음: "+new String(buffer, 0, read));
				}
				pReader.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}
}
//
입력 받음: Thread-1에서 출력함

PipedReader와 PipedWriter 객체를 생성한다. 

스레드가 start() 되기 전에 connect()를 통해 두개의 스트림을 연결한다. 

----------------------------------------------------
3. 보조 스트림 

3.1 보조 스트림의 개념과 종류 


노드 스트림과 달리 노드에 직접 연결되지 않고 다른 스트림과 연결되는 스트림이 
있는데 이를 보조 스트림이라고 한다. 보조 스트림은 노드와 직접 연결할수 없고 
노드 스트림을 비롯한 다른 스트림과 연결된다. 노드 스트림들이 순수하게 
다양한 노드에서 byte나 char 의 전달기능을 수행한다면 보조 스트림들은 
부가적인 기능을 제공한다. 그래서 보조 스트림을 필터 스트림(Filter Stream)
또는 프로세싱 스트림(Processing Stream)이라고도 부른다. 

ex) 노드 스트림과 보조 스트림 
노드 -->(노드스트림:단순한 byte,char의 전달 )--->(보조스트림:부가기능 수행 )-->프로그램
노드<--(노드스트림:단순한 byte,char의 전달 )<--(보조스트림:부가기능 수행 )<--프로그램

보조 스트림들이 하는 기능에는 문자셋(character set) 변환, 버퍼링, 기본 데이터형의 
전송, 객체 입출력 등이 있다. 이 기능들은 역시 입력과 출력의 쌍으로 존재하며 
필요에 따라 여러 개의 보조 스트림을 연결해서 사용할수 있다. 
이를 스트림 체이닝(Stream Chaining ) 이라고 한다. 

ex)
node ---(노드스트림)--보조스트림1-보조스트림2->프로그램 

(2) 보조 스트림의 종류 
기능별로 어떤 보조 스트림들이 존재하는지 알아보자. 

보조 스트림의 종류 

기능 : char 기반 : byte 기반 

byte 스트림을 char 스트림으로 변환 : InputStreamReader, OutputStreamWriter

버퍼링을 통한 속도 향상 : BufferedReader, BufferedWriter : 
BufferedInputStream, BufferedOutputStream

기본 데이터형 전송 : : DataInputStream, DataOutputStream

객체 전송 : : ObjectInputStream, ObjectOutputStream

문자열 표현으로 출력 : PrintWriter : PrintStream

안선 예제에서 Reader 나 Writer 를 사용하기 위해 이미 InputStreamReader 
또는 OutputStreamWriter를 사용한 바 있다. PrintWriter 역시 System.out
의 타입으로 그 동안 계속 사용해 왔으므로 새로울바가 없다. 

(3) 보조 스트림의 생성과 종료 
보조 스트림을 생성할 때에는 시작만 노드 스트림으로 설정하면 우선순위는 없다. 
단지 앞 단계의 스트림을 생성자로 넣어 주면 된다. 

ex)
new BufferedInputStream(System.in);
//키보드에 연결된 노드 스트림을 강화해 버퍼 기능추가 

new DataInputStream(new BufferedInputStream(new FileInputStream());
//계속해서 기본 데이터형 전송 기능 추가. //파일에 연결된 노드 스트림을 
강화해 버퍼 기능 추가. 

종료할 때는 보조 스트림에서만 close()를 호출하면 노드 스트림까지 알아서 
close()처리가 완료된다. 

----------------------------------------------------
3.2 byte 기반 스트림을 char 기반 스트림으로 변경하는 스트림 

키보드나 모니터가 기본적으로 발생시키거나 소모하는 데이터 형태는 
byte이다. 하지만 문자를 처리하는 경우 byte는 처리하기가 번거롭기 때문에 
Reader나 Writer를 선호한다. 
InputStreamReader와 OutputStreamWriter는 byte 기반의 스트림을 지정된 
캐릭터셋의 char 기반 스트림으로 변경해준다. 

byte 스트림이 단순한 데이터의 나열이라면 문자는 두개 또는 세개의 바이트를 
모아서 생성된다. 이처럼 일련의 byte 코드 덩어리를 문자로 또는 문자를 byte 
덩어리로 해석하기 위한 과정을 각각 디코딩과 인코딩이라고 한다. 이 과정에서 
주어진 값을 어떻게 해석 할 것인지 결정해야 하는데 이때 적용되는 기준이 캐릭터셋이다. 
이 인코딩과 디코딩 과정이 잘못되면 흔히 말하는 문자가 깨지는 증상이 나타난다. 

다음 예는 "안녕" 이란 문자열을 utf-8 캐릭터셋을 이용해서 byte[] 로 변경 후 다시 
문자로 변경한다. 이 과정에서 최초 캐릭터셋과 달리 ms949 를 이용하면 깨지지만 
utf-8을 이용하면 정상적인 문자 확인이 가능하다. 

ex)
String data ="안녕";
byte [] bytes = data.getBytes("utf-8"); // utf-8을 이용해서 인코딩 처리 
String redata = new String(bytes, "ms949"); //ms949를 이용해서 디코딩 처리 
System.out.println("ms949: "+ redata); // ms949 : 이상한 문자 출력 

redata = new String(bytes, "utf-8"); // utf-8을 이용해서 디코딩 처리 
System.out.println("utf-8: " + redata); // utf-8 : 안녕 

610 24/53

한글을 표현할 때 사용되는 캐릭터셋은 euc-kr, ms949, utf-8 
등으로 다양하다. 표준으로 정해진것은 아니지만, 묵시적인 표준으로 utf-8
을 사용하기를 권장한다.  utf-8은 한글뿐아니라 전 세계의 문자를 표현할 
수 있다. 처음 이클립스 환경설정에서 워크스페이스의 텍스트 파일 인코딩을 
utf-8로 설정했던 것을 기억하자. 

InputStreamReader와 OutputStreamWriter는 객체 생성 시점에서 
캐릭터셋을 지정할수 있다. 

InputStreamReader와 OutputStreamWriter의 생성자 

생성자명 : 선언부와 설명 

InputStreamReader() : public InputStreamReader(InputStream in)
기본 캐릭터셋을 이용해서 InputStreamReader를 생성한다. 

public InputStreamReader(
InputStream in , String charsetName) throws UnsupportedEncodingException
charsetName을 이용해 InputStreamReader를 생성한다. 

public InputStreamReader(InputStream in , Charset cs)
cs를 이용해 InputStreamReader를 생성한다. 

OutputStreamWriter() : public OutputStreamWriter(OutputStream out)
기본 캐릭터셋을 이용해 OutputStreamWriter를 생성한다. 

public OutputStreamWriter( OutputStream out, String charsetName)
throws UnsupportedEncodingException
charsetName을 이용해 OutputStreamWriter를 생성한다. 

public OutputStreamWriter( OutputStream out, Charset cs)
cs를 이용해 OutputStreamWriter를 생성한다. 

이들의 활용은 노드 스트림에서 Reader와 Writer를 참조한다. 

----------------------------------------------------
3.3 버퍼를 이용하는 성능 향상 스트림

가끔 네트워크가 좋지 않은 상태에서 동영상을 재생하다 보면 '버퍼링 중'이라는 
메시지를 볼수 있다. 

네트워크 너머에 있는 비디오를 보려면 소스 영상을 다운로드하고 처리하는 과정이 
필요한데 원격지에 있는 파일을 바로 비디오 플레이어에서 처리하려면 성능상 문제가 
발생 할수 있다. 대부분 먼저 파일을 애플리케이션의 메모리에 다운로드한 후 메모리의 
파일을 비디오 플레이어에서 처리하는데 이때 애플리케이션의 메모리를 버퍼라고 한다. 
버퍼링은 이 버퍼에 데이터를 쌓는 과정이다. 

ex)
비디오소스 --네트워크 -- 전송-->애플리케이션 버퍼(buffer)
전송+처리: 성능문제  비디오 플레이어 처리 

I/O 과정도 마찬가지다. 하드디스크에 있는 자료를 직접적으로 읽어서 
처리하기보다는 일단 메모리에 올린 후 처리하는 것이 효율적이다.
메모리보다 빠른 저장장치는 없다. 보조 스트림 중 BufferedInputStream과 
BufferedOutputStream, BufferedReader, BufferedWriter는 
내부적으로 버퍼를 이용하기 때문에 I/O 성능을 획기적으로 개선해준다. 
이들은 내부적으로 8192 byte 크기의 버퍼를 내장하고 있다. 

BufferedInputStream 과 BufferedOutputStream 생성자 

생성자명 : 선언부와설명

BufferedInputStream() :
public BufferedInputStream(InputStream in)
in 을 이용해 크기가 8192 인 버퍼를 갖는 
BufferedInputStream을 생성한다. 

public BufferedInputStream(InputStream in , int size)
in을 이용해 크기가 size인 버퍼를 갖는 BufferedInputStream을 생성한다. 

BufferedOutputStream():
public BufferedOutputStream(OutputStream out)
out을 이용해 크기가 8192 인 버퍼를 갖는 
BufferedOutputStream을 생성한다. 

public BufferedOutputStream(OutputStream out, int size)
out을 이용해 크기가 size 인 버퍼를 갖는 
BufferedOutputStream을 생성한다. 

단순한 FileInputStream, FileOutputStream을 사용했을 때와 
버퍼 기능이 강화된 
BufferedInputStream, BufferedOutputStream을 사용했을 때 파일을 
복사하는 성능을 비교해보자. 

ex)
package ch15.processing.buffer;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

public class BufferPerformanceTest {

	public static void main(String[] args) {
		File src = new File("c:/Windows/explorer.exe");
		File target = new File("c:/Temp/copied_explorer.exe");
		try (FileInputStream fi = new FileInputStream(src);
				FileOutputStream fo = new FileOutputStream(target);
				BufferedInputStream bi = new BufferedInputStream(fi);
				BufferedOutputStream bo = new BufferedOutputStream(fo);) {
			copy("노드", fi, fo);
			copy("보조", bi, bo);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public static void copy(String type, InputStream input, OutputStream output) throws IOException {
		long start = System.nanoTime();
		byte[] cart = new byte[1024];
		int read = -1;
		while ((read = input.read(cart)) > 0) {
			output.write(cart, 0, read);
		}
		long end = System.nanoTime();
		System.out.println(type + ", 소요 시간: " + (end - start) + "ns");
	}
}
//
노드, 소요 시간: 107286600ns
보조, 소요 시간: 34701ns

기본 노드 스트림인 FileInputStream fi 와 FileOutputStream fo를 생성한다. 

fi와 fo를 이용해 BufferedInputStream bi 와 BufferedOutputStream bo를 생성한다. 

나머지 코드는 앞서 살펴봤던 파일 복사 (ch15.node.file.CopyTest.java)와 
동일하다. 스트림만 바꿨음에도 500배가 넘는 성능의 차이를 보인다. 
물론 상황에 따라 다양한 결과가 나올수 있다. 

BufferedReader와 BufferedWriter도 같은 방식으로 사용할수 있다. 
단지 FileReader와 FileWriter를 파라미터로 생성되며 이동되는 데이터가 
char일 뿐이다. 

BufferedReader와 BufferedWriter 생성자 
생성자명 : 선언부와설명

BufferedReader() : public BufferedReader(Reader in)
in을 이용해 크기가 8192 인 버퍼를 갖는 BufferedReader를 생성한다. 

public BufferedReader(Reader in, int sz)
in을 이용해 크기가 sz인 버퍼를 갖는 BufferedReader를 생성한다. 

BufferedWriter() : public BufferedWriter(Writer out)
out을 이용해 크기가 8192인 버퍼를 갖는 BufferedWriter를 생성한다. 
public BufferedWriter(Writer out, int sz)
out을 이용해 크기가 sz인 버퍼를 갖는 BufferedWriter를 생성한다. 

BufferedReader에 있는 readLine() 메서드는 눈여겨볼만 한데 메서드 이름처럼 
데이터를 한 줄씩 읽어서 리턴한다. BufferedReader를 이용해 파일을 읽고 
화면에 출력해보자. 

ex)
package ch15.processing.buffer;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;

public class BufferTextTest {

	public static void main(String[] args) {
		File src = new File("./pom.xml");
		try (BufferedReader br = new BufferedReader(new FileReader(src));) {
			String line = null;
			while ((line = br.readLine()) != null) {
				System.out.println(line);
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}
//
파일이 있어야 함. 

src를 이용해 FileReader를 만들고 다시 이를 이용해 BufferedReader를 생성한다. 
src로 부터 한 줄씩 데이터를 읽는다. 만약 이 값이 null이면 더이상 읽을 데이터가 
없는 것이고 반복문은 종료된다. 

----------------------------------------------------
3.4 기본 데이터형 전송을 위한 스트림 

일반적으로 스트림을 이용해서 데이터를 읽거나 쓸 때는 byte 또는 char 형태로만 
가능하다. 따라서 int 나 double을 저장하고 싶어도 문자열 형태로 저장하게 되며 
읽을 때도 형변환을 해야 사용할수 있다. 

DataInputStream과 DataOutputStream은 기본형 데이터를 있는 그대로 저장해서 
별도의 형변환 없이 사용할수 있게 하며 이를 위해 데이터 타입별로 다양한 메서드 
들을 제공한다. 이 스트림은 byte 데이터만을 대상으로 한다. 

DataInputStream과 DataOutputStream은 주요 메서드 

메서드명 : 선언부와 설명 

readP#() : public final P# readP#() throws IOException
DataInputStream을 통해 P# 타입의 값을 스트림에서 읽어 들인다. 

writeP#() : public final void writeP#(p v)
DataOutputStream을 이용해 p 타입의 값을 출력 한다. 

p는 boolean, byte, short, int, long, float, double, char, String 을 나타내며, 
P# 는 Boolean, Byte, Short, Int, Long , Float , Double, Char, UTF로 나타낸다. 

문자열을 처리할 때 메서드 이름에 String이 아니라 UTF를 사용하는 점에 
주의 하자. 

DataOutputStream으로 저장한 값은 DataInputStream을 통해서만 읽을 수 있다. 
또한, 데이터를 읽은 후에는 타입을 판별할 수 없기 때문에 쓴 순서대로 읽어야 한다. 

ex)
package ch15.processing.data;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class DataStreamTest {

	public static void main(String[] args) throws IOException {
		File src = new File("c:/Temp/streamtest.dat");
		// 데이터 쓰기
		try (DataOutputStream dos = new DataOutputStream(new FileOutputStream(src))) {
			dos.writeUTF("홍길동");
			dos.writeInt(30);
			dos.writeDouble(170.5);
		}
		// 데이터 읽기
		try (DataInputStream dis = new DataInputStream(new FileInputStream(src))) {
			String name = dis.readUTF();
			int age = dis.readInt();
			double weight = dis.readDouble();
			System.out.println(name + " : " + age + " : " + weight);
		}
	}
}
//
홍길동 : 30 : 170.5

src 파일에 출력하기 위한 FileOutputStream을 이용한 DataOutputStream
dos를 생성한다. 

dos를 이용해 문자열(UTF)-> int -> double 의 순서로 데이터를 출력한다. 

src로 부터 값을 읽기 위한 FileInputStream을 이용한 DataInputStream dis를 
생성한다. 

dis를 이용해 UTF->int -> double 의 순서로 데이터를 읽어서 출력한다. 

----------------------------------------------------
3.5 객체 저장을 위한 스트림 

616 30/53

DataInputStream 과 DataOutputStream이 기본형과 문자열을 입력/출력하기 
위한 스트림이라면 객체를 입력/출력할 수 있는 스트림으로는 
ObjectInputStream과 ObjectOutputStream이 있다. 

(1) 직렬화와 역직렬화 
메모리상의 객체를 다른 노드에 전송할 때 참조 값을 전송하는 것은 아무런 의미가 
없다. 애플리케이션이 종료되면 메모리는 다 초기화되기 때문이다. 또한, 객체의 
메서드나 생성자도 의미 없다. 이들은 객체를 구별하는 요소가 아니기 때문이다. 
객체 전송에서 필요한 것은 단지 객체가 가진 데이터 즉 멤버 변수들 뿐이다. 

객체의 멤버 변수들을 전송하기 위해서는 연속적인 데이터 형태로 변환해야 
하는데 이 과정을 객체 직력화(Serialization)라고 한다. ObjectOutputStream은 
객체를 직렬화 시켜서 노드로 출력한다. 반대로 ObjectInputStream은 직렬화된 
객체 정보 즉 멤버 변수를 읽어서 다시 객체화시킨다. 이 과정을 역직렬화된 객체 정보 
즉 멤버 변수를 읽어서 다시 객체화시킨다. 이 과정을 역직렬화(Deserialization)라고 
한다. 

ex)
0x100(Person p : 스택)->0x100 (힙 : name:, age: 세로 되어 있네 )
->직렬화 (name:.. : age : .. 가로로)(반대로는 역직렬화 )
-> output ->파일 
파일-> input 

직렬화되기 위한 클래스는 반드시 Serializable 인터페이스를 구현해야 한다. 
Serializable 인터페이스에는 구현해야 할 메서드는 없다. 단지 
implements Serializable이 추가되면 충분하다. 
단 이때 소속 멤버 변수들도 모두 직렬화될 수 있어야 한다. 

다음예에서 Person을 직렬화하기 위해서는 Person의 멤버 타입들인 
String name 이나 LoginInfo Info 역시 직렬화될 수 있어야한다. 
String 클래스는 이미 Serializable을 구현하고 있으며 LoginInfo는 
작성 시 Serializable을 구현해야 한다. 

객체의 멤버 변수 중 외부로 유출되지 말아야 할 내용이 있을 수 있다. 
예를 들어 주민등록번호 등 민감한 정보가 파일로 저장되는 것은 바람직 하지 
않다. 이런 멤버 변수에는 transient 키워드를 사용하면 직렬화에서 제외된다. 

ex)
class Person implements Serializable { // 직렬화 필수 조건 
private String name;
private int age;

private transient String ssn; // 직렬화 제외 
private LoginInfo IInfo;
}

(2)serialVersionUID 
직렬화 가능한 클래스에는 static final long 타입의 serialVersionUID 
멤버 변수를 추가하는 것이 좋다. 이 변수는 클래스 변경 여부를 파악하기 위한 
키이다. 어느 날 serialVersionUID가 001인 버전의 Person 타입 객체를 직렬화해서 
파일로 저장한 후 멤버 변수 age를 제거한 002 버전으로 만들었다고 생각해보자. 
역직렬화가 가능할까? 당연히 age가 없어졌으므로 문제가 될것이다. 

ex) class Person{} : 001 버전 -> 직렬화 , name:.. | age:.. ->output -> 파일 
파일 -> input : 역직렬화 -> 예외발생 : class Person{} : 002 버전.

역직렬화 과정에서 클래스의 버전 확인에 사용되는 것이 serialVersionUID이다. 
직렬화 할 때의 serialVersionUID와 역직렬화할 때의 serialVersionUID가 맞지 않으면 
java.io.InvalidClassException 이 발생한다. 

주의할 점은 직렬화되는 클래스에 serialVersionUID가 설정되지 않았을 경우 
컴파일러가 자동으로 생성한다는 것이다. 즉 컴파일 할 때마다 serialVersionUID가 
변경돼서 기존에 직렬화돼서 저장된 내용을 역직렬화해서 사용할수 없게 된다. 
따라서 직렬화되는 객체에는 serialVersionUID를 설정하기를 권장한다. 

serialVersionUID
직렬화 대상 객체에 serialVersionUID가 설정되지 않으면 'serial'경고 (warning)가 
발생한다. 이 경우 이클립스에서는 클래스 이름에 커서를 올리면 serialVersionUID를 
설정하는 기능을 제공한다. Add default serial version ID는 기본값이 1L 로 
설정된 serialVersionUID를 추가해주고 Add generated serial version ID는 
고유한 값을 생성해서 추가한다. 또는 @SupressWarnings로 이 경고를 무시할 수도 있다. 

다음은 직렬화 대상인 Person과 Person이 has-a 관계를 가지는 LoginInfo
클래스이다. 

ex)
package ch15.processing.object;

import java.io.Serializable;

public class Person implements Serializable {
	private static final long serialVersionUID = 3075830113306886480L;// 생성된 UID
	private String name;
	private int age;
	private transient String ssn;
	private LoginInfo lInfo;

	public Person(String name, int age, String ssn, String userId, String userPass) {
		this.name = name;
		this.age = age;
		this.ssn = ssn;
		this.lInfo = new LoginInfo(userId, userPass);
	}

	@Override
	public String toString() {
		return "Person [name=" + name + ", age=" + age + ", ssn=" + ssn + ", lInfo=" + lInfo + "]";
	}
}

class LoginInfo implements Serializable {
	private static final long serialVersionUID = 1L; // 기본값 사용
	private String userId;
	private transient String userPass;

	public LoginInfo(String userId, String userPass) {
		super();
		this.userId = userId;
		this.userPass = userPass;
	}

	public String toString() {
		return "LoginInfo [userId=" + userId + ", userPass=" + userPass + "]";
	}
}
//
Serializable 인터페이스를 구현한 Person 클래스이다. 

클래스의 버전을 관리하기 위해 serialVersionUID를 설정한다. 

민감한 정보인 ssn은 직렬화에서 제외하기 위해 transient 키워드를 추가한다. 

멤버 변수인 LoginInfo역시 Serializable 인터페이스 의 구현이 필요하다. 

(3) ObjectOutputStream과 ObjectInputStream
객체 직렬화에 사용되는 ObjectOutputStream의 메서드를 살펴보자. 

ObjectOutputStream의 주요 API 

메서드명 : 선언부와설명

ObjectOutputStream() 
:public ObjectOutputStream(OutputStream out) throws IOException
out을 이용해 ObjectOutputStream 객체를 생성한다. 

writeObject()
:public final void writeObject(Object obj) throws IOException
obj를 직렬화해서 출력한다. 

defaultWriteObject()
:public void defaultWriteObject() throws IOException
객체에서 선언한 non-static, non-transient 멤버 변수를 직렬화해서 출력한다. 
이 메서드는 직렬화되는 클래스의 writeObject(ObjectOutputStream)
메서드에서만 호출된다. 

writeP#() 
:public void writep#(p# val) throws IOException
val 값을 출력한다. 이 메서드는 직렬화되는 클래스의 writeObject(ObjectOutputStream)
메서드에서 호출된다. 
P# : boolean, byte, short, int , long, float, double, char, String 
P* : Boolean, Byte, Short, Int, Long, Float, Double, Char, UTF를 나타낸다. 

ObjectInputStream의 주요 API 
ObjectInputStream() 
:public ObjectInputStream(InputStream in) throws IOException
in을 이용해 ObjectInputStream 객체를 생성한다. 

readObject()
:public final Object readObject() throws IOException, ClassNotFoundException
직렬화된 데이터를 역직렬화해서 Object로 리턴한다. 

defaultReadObject()
:public void defaultReadObject() throws IOException,ClassNotFoundException
객체에서 선언한 non-static, non-transient 멤버 변수를 역직렬화한다.
이 메서드는 역직렬화되는 클래스의 readObject(ObjectInputStream)
메서드에서만 호출된다. 

readP#() 
:public P*  readP#() throws IOException
p 타입의 값을 읽어서 리턴한다. 이 메서드는 역직렬화되는 클래스의 
readObject(ObjectInputStream) 메서드에서 호출된다.
메서드에서 호출된다. 
P# : boolean, byte, short, int , long, float, double, char, String 
P* : Boolean, Byte, Short, Int, Long, Float, Double, Char, UTF를 나타낸다. 

ex) 
다음은 Person 클래스를 직렬화해서 파일로 저장하고 다시 역직렬화 과정을 
거쳐 사용하는 예이다. 

package ch15.processing.object;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

public class ObjectStreamTest {

	public static void main(String[] args) {
		File target = new File("c:/Temp/objPerson.dat");
		Person person = new Person("홍길동", 20, "111111-2222222", "hong", "1234");
		try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(target));
				ObjectInputStream ois = new ObjectInputStream(new FileInputStream(target));) {
			//객체 저장
			oos.writeObject(person);
			// 객체 로딩
			Object readed = ois.readObject();
			if (readed != null && readed instanceof Person) {
				Person casted = (Person) readed;
				System.out.println(casted);
			}
		} catch (IOException | ClassNotFoundException e) {
			e.printStackTrace();
		}
	}
}
//Person [name=홍길동, age=20, ssn=null, lInfo=LoginInfo [userId=hong, userPass=null]]

FileInputStream과 FileOutputStream을 노드 스트림으로 하는 
ObjectInputStream과 ObjectOutputStream을 생성한다. 

ObjectOutputStream의 writeObject()를 이용해서 직렬화된 객체를 파일에 
저장한다. 

ObjectInputStream의 readObject()를 이용해서 역직렬화 후 객체를 반환한다. 

객체를 Person으로 형변환후 출력한다. 

출력된 내용을 살펴보면 처음 만들었던 객체의 정보를 그대로 확인할수 있다. 
단 transient 선언된 Person의 ssn이나 LoginInfo의 userPass는 null 인 상태이다 

(4) 상속 관계에서의 객체 직렬화 
Parent 클래스와 이를 상속받은 Child 클래스가 있을 때 Child 객체의 직렬화에 대해 
알아보자. 만약, Parent 클래스가 Serializable 인터페이스를 구현하고 있다면 
자식은 자동으로 직렬화가 가능하기 때문에 모든 Child의 멤버 변수 모두가 직렬화 
대상이다. 하지만, 조상이 Serializable 인터페이스를 구현하지 않고 자식만 구현한 
상태라면 자식의 멤버 변수만 직렬화 대상이다. 

조상 클래스를 수정할수 없는 상태라면 자식에서 조상에 대한 직렬화를 직접 처리해야 
한다. 이를 위해 자식 클래스에 다음과 같이 readObject()와 writeObject() 메서드를 
만들어야 한다. 

ex)
private void writeObject(ObjectOutputStream out) throws IOException{
out.writeP#(부모의 멤버 변수);
...
out.defaultWriteObject();
}

private void readObject(ObjectInputStream in)
throws IOException, ClassNotFoundException{
부모의 멤버 변수 = in.readP#();
...
in.defaultReadObject();
}
메서드의 접근 제한자가 private임을 유의하자. 이 과정에서 
조상의 멤버 변수를 처리할 때 readP#()와 writeP#()를 사용하는데 
DataInputStream, DataOutputStream에서의 용법과 동일하다. 
writeObject()에서는 출력을 처리하는데 writeP#()를 통해서 부모의 멤버들을 
직렬 처리한다. defaultWriteObject() 클래스 자체에서 선언된 non-static,
non-transient 멤버들을 직렬화한다. readObject()에서는 입력을 처리하는데 
readP#()를 통해서 부모의 멤버들을 역직렬화해서 할당한다. 
defaultReadObject()는 클래스 자체에서 선언된 non-static, non-transient
멤버들을 역직렬화한다. 이때 readObject()에서 역직렬화하는 순서는 반드시 
writeObject ()에서 직렬화한 순서와 같아야 한다. 

다음은 Serializable을 구현하지 않은 Parent 를 상속받은 Child 클래스를 직렬화하는 
예이다. 

ex)
package ch15.processing.object;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

public class InheritSerializeTest {

	public static void main(String[] args) {
		File target = new File("c:/Temp/objParent.dat");
		Child child = new Child("홍길동", 20);
		try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(target));
				ObjectInputStream ois = new ObjectInputStream(new FileInputStream(target));) {
			//객체 저장
			oos.writeObject(child);
			// 객체 로딩
			Object readed = ois.readObject();
			if (readed != null && readed instanceof Child) {
				Child casted = (Child) readed;
				System.out.println(casted);
			}
		} catch (IOException | ClassNotFoundException e) {
			e.printStackTrace();
		}

	}
	static class Parent{
		protected String name;
	}
	static class Child extends Parent implements Serializable{
		private static final long serialVersionUID = 4261512421193094142L;
		private int age;

		public Child(String name, int age) {
			this.name = name;
			this.age = age;
		}

		@Override
		public String toString() {
			return "Child [age=" + age + ", name=" + name + "]";
		}
		
		private void writeObject(ObjectOutputStream out) throws IOException{
			out.writeUTF(name);
			out.defaultWriteObject();
		}
		private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException{
			name = in.readUTF();
			in.defaultReadObject();
		}
	}
}
//
Child [age=20, name=홍길동]

writeObject() 메서드에서 직접 직렬화 코드를 작성한다. 
먼저 조상의 멤버인 name을 직렬화하고 defaultWriteObject()를 
통해 Child에서 선언한 멤버 변수를 직렬화한다. 

readObject() 메서드에서 직접 역직렬화 코드를 작성한다. 이때 순서는 
writeObject()에서 직렬화한 순서를 그대로 따라야 한다. 따라서 먼저 
name을 readUTF()로 처리하고 나머지 멤버 변수들을 defaultReadObject()로 
처리한다. 

----------------------------------------------------
4 NIO(New Input Output) 

4.1 NIO 의 특징 

NIO는 JDK 1.4에 처음 등장했으며 자바 7 버전에서 대폭 강화된 I/O 관련 패키지로 
기존의 I/O를 대체하는 개념이 아니라 다른 특성을 가진 I/O이다. 

기존 I/O와 대비되는 NIO의 차이점을 알아보자. 

입출력 방식 : I/O 는 스트림을 이용한다. 스트림은 단방향으로 입력을 위한 
스트림과 출력을 위한 스트림이 필요하다. NIO에서는 채널(Channel)을 사용한다. 
채널은 양방향으로 하나의 채널로 입력과 출력을 모두 처리한다. 

버퍼 방식 : I/O는 기본적으로 버퍼를 제공하지 않는다. 버퍼가 필요하다면 
Buffered 계열의 보조 스트림을 추가해서 사용해야 한다. NIO 방식에서는 버퍼를 
기본으로 제공한다. 따라서 모든 데이터는 버퍼를 통해서 가져온다. 

블로킹 방식 : I/O는 언제나 블로킹(blocking)을 유발하므로 스레드가 대기상태로 
이동한다. 즉 read()나 write() 를 호출할 때 스레드가 블로킹되고 close() 를 호출하면 
블로킹이 풀린다. 이 과정에서는 다른 블로킹 상태와 달리 interrupt()를 호출해서 
중단시킬수도 없다. NIO는 블로킹과 넌-블로킹(non-blocking)을 모두 지원한다. 
블로킹에서 조차 interrupt()를 통해서 중단시킬수 있다. 

결과적으로 정리해보면 NIO는 여러 클라이언트 연결을 넌-블로킹 상태로 
처리하고 운영체제의 버퍼를 이용함으로써 성능상 장점이 많다. 특히 다수의 
클라이언트 환경, 짧은 입출력 작업에 적합하다. 하지만 스레드 병렬처리를 
기본으로 하기 때문에 I/O에 비해 복잡해졌고 대용량 처리, 소수의 클라이언트
환경에서는 I/O가 오히려 유리하다. 

----------------------------------------------------
4.2 Path 와 Files 

I/O가 File 하나로 파일 관련 요소들을 관리하던 것을 NIO에서는 Path와 
Files 로 분리해서 관리한다. 

(1) java.nio.file.Path 인터페이스
Path는 파일 또는 디렉터리의 경로를 지정하기 위해서 사용된다. 
Path를 얻기 위해서는 Paths가 제공하는 정적 메서드인 get()을 이용한다. 

Paths의 메서드 

메서드명 : 선언부와설명

get() : public static Path get(String first, String ... more)
first와 more로 구성된 Path 객체를 리턴한다. .

public static Path get(URI uri)
uri에 위치한 Path 객체를 리턴한다. 

다음은 get() 메서드를 이용해 Path 객체를 얻는 예로 모두 하나의 
파일을 나타낸다. 

ex)
Path path1 = Paths.get("C:/windows/explorer.exe");
Path path2 = Paths.get("C:",:indows", "explorer.exe"));
Path path3 = Paths.get(new URI("file:///C:/windows/explorer.exe"));

Path에는 Path 객체의 기본 정보를 얻는 메서드, 경로 변환과 관련된 메서드, 
경로 비교와 관련된 메서드가 제공된다. 

다음은 Path 객체의 기본 정보를 얻기위한 메서드들과 사용 예이다. 

Path의 주요 메서드 

getFileName(): Path getFileName()
부모 경로를 제외한 파일 또는 디렉토리 이름을 갖는 Path를 리턴한다. 

getNameCount() : int getNameCount()
루트 경로 이후 구분자로 나뉘는 이름의 개수를 리턴한다. 
예를 들어 C:/windows/explorer.exe 의 경우는 2이다. 

getName() : Path getName(int index)
특정 인덱스의 이름을 리턴한다. 예를 들어 C:/windows/explorer.exe
의 경우 getName(0)은 windows 이다. 

subpath(): Path subpath(int beginIndex, int endIndex)
현재 Path에서 beginIndex 부터 endIndex 까지 만으로 구성된 Path를 
리턴한다. 

getParent() : Path getParent()
상위 Path 객체를 리턴한다. 

getRoot() : Path getRoot()
최상위 Path 객체를 리턴한다. 

toAbsolutePath() : Path toAbsolutePath()
상대경로의 Path를 절대경로의 Path로 리턴한다. 

normalize() : Path normalize()
경로명 중간에 불필요한 상대경로로 표현을 제거하고 리턴한다. 

toFile() : File toFile()
Path를 java.io.File 객체로 리턴한다. 

toUri() : URI toUri()
file://로 시작하는 URI 형태로 리턴한다. 

ex)
package ch15.nio.path;

import java.io.File;
import java.net.URISyntaxException;
import java.nio.file.Path;
import java.nio.file.Paths;

public class PathTest {

	public static void main(String[] args) throws URISyntaxException {
		Path path1 = Paths.get("c:/windows/explorer.exe");
		System.out.printf("파일명: " + path1.getFileName());
		System.out.println();
		System.out.println("이름의 개수: " + path1.getNameCount());
		System.out.println("0번째 이름의 개수: " + path1.getName(0));
		System.out.println("0~2의 패스: " + path1.subpath(0, 2));
		System.out.println("상위 경로: " + path1.getParent());
		System.out.println("루트 경로: " + path1.getRoot());

		Path relative = Paths.get("./src");
		System.out.println("절대 경로로: " + relative.toAbsolutePath());
		System.out.println("상대 경로 표시 삭제: " + relative.normalize().toAbsolutePath());
		// java.io 패키지로의 연결
		File file = relative.toFile();
		System.out.println("URI 표현: " + relative.toUri());
	}
}
//
파일명: explorer.exe
이름의 개수: 2
0번째 이름의 개수: windows
0~2의 패스: windows\explorer.exe
상위 경로: c:\windows
루트 경로: c:\
절대 경로로: C:\Users\itwill-cisco1205\git\java-kame2\.\src
상대 경로 표시 삭제: C:\Users\itwill-cisco1205\git\java-kame2\src
URI 표현: file:///C:/Users/itwill-cisco1205/git/java-kame2/./src/

(2) java.nio.files.Files 클래스 

Files 클래스는 파일과 디렉토리의 생성및 속성을 읽는 정적 메서드를 제공한다. 
대부분 java.io.File이 가지고 있는 메서드들과 유사한데 파일을 복사하는 
copy()나 파일과 연결된 스트림을 리턴하는 newXXX() 계열의 메서드는 
상당히 편리하다. 

Files 의 주요 메서드 

메서드 명 : 선언부와설명

newInputStream() 
:public static InputStream newInputStream(Path path, OpenOption...options)
throws IOException
path 와 연결된 InputStream을 리턴한다. 

getNameCount()
public static OutputStream newOutputStream(
Path path, OpenOption ... options) throws IOException
)
path와 연결된 OutputStream을 리턴한다. 

newBufferedReader() 
:public static BufferedReader newBufferedReader(Path path, OpenOption...options)
throws IOException
path와 연결된 BufferedReader를 리턴한다. 

newBufferedWriter() 
:public static BufferedWriter newBufferedWriter(Path path, OpenOption...options)
throws IOException
path와 연결된 BufferedWriter를 리턴한다. 

newDirectoryStream() 
public static DirectoryStream<Path> newDirectoryStream(Path dir)
throws IOException
path와 연결된 DirectoryStream을 리턴한다. 

SeekableByteChannel() 
:public static SeekableByteChannel newByteChannel(
Path path, OpenOption... options) throws IOException)
path 와 연결된 SeekableByteChannel을 리턴한다. 

createFile()
public static Path createFile(Path path, FileAttribute<?>...attrs) throws IOException
path 위치에 빈 파일을 생성한다. 

createDirectory()
:public static Path createDirectory( 
Path dir, FileAttribute<?> ... attrs)throws IOException
dir 위치에 디렉토리를 생성한다. 

delete()
: public static void delete(Path path) throws IOException
path 위치의 디렉토리 또는 파일을 삭제한다. 

copy() 
: public static Path copy(Path source, Path target, CopyOption... options)
throws IOException
source를 target 으로 복사한다. 

move() 
: public static Path move(Path source, Path target, CopyOption...options)
throws IOException
source 를 target으로 이동 시킨다. 

readAllLines() 
: public static List<String>readAllLines(Path path) throws IOException
path 의 모든 행을 읽어서 List<String> 으로 리턴한다. 

위에 소개한 메서드들 이외에도 파일의 정보를 확인하는 다양한 메서드들이 
제공된다. 

ex) 
package ch15.nio.path;

import java.io.BufferedReader;
import java.io.IOException;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.Date;
import java.util.List;

public class FilesTest {
	public static void main(String[] args) throws IOException {
		FilesTest ft = new FilesTest();
		ft.copyTest();
		ft.dirInfo();
		ft.readTextFile();
		ft.deleteTest();
	}
	
	public void copyTest() throws IOException {
		Path src = Paths.get("c:/windows/explorer.exe");
		Path target = Paths.get("c:/Temp/files_copy_explorer.exe");
		if (Files.isReadable(src)) {
			Files.copy(src, target, StandardCopyOption.REPLACE_EXISTING);
			System.out.println("복사 완료!!");
		}
	}
	
	public void dirInfo() throws IOException {
		Path target = Paths.get(".");
		DirectoryStream<Path> directoryStream = Files.newDirectoryStream(target);
		for(Path path: directoryStream) {
			Date time = new Date( Files.getLastModifiedTime(path).toMillis());
			String name = path.getFileName().toString();
			long length = Files.size(path);
			if (Files.isDirectory(path)) {
				name = "[" + name + "]";
			}
			System.out.printf("%-20s\t%tF %<tT\t%s%n", name, time, length);
		}
	}
	
	public void readTextFile() throws IOException{
		Path target = Paths.get("./pom.xml");
		BufferedReader reader = Files.newBufferedReader(target);
		String line = null;
		while((line=reader.readLine())!=null) {
			System.out.println(line);
		}
		
		List<String> lines = Files.readAllLines(target);
		for(String line2: lines) {
			System.out.println(line2);
		}
	}
	
	public void deleteTest() throws IOException{
		Path target = Paths.get("c:/Temp/files_copy_explorer.exe");
		boolean result = Files.deleteIfExists(target);
		String resultStr = result?"삭제 성공":"삭제 실패";
		System.out.println(resultStr);
	}
}
//
복사 완료!!
.classpath          	2019-03-12 14:09:37	644
[.git]              	2019-03-12 14:09:38	4096
.gitignore          	2019-03-12 14:09:36	893
.project            	2019-03-12 14:09:37	386
[.settings]         	2019-03-12 14:09:36	0
config.properties   	2019-05-02 17:58:34	103
mylog_0.log         	2019-03-25 09:19:49	1593
pom.xml             	2019-05-13 17:45:49	0
[src]               	2019-03-28 11:02:50	4096
[target]            	2019-03-12 14:09:35	0
삭제 성공

Files.copy()를 이용해 별도의 스트림을 생성하지 않고도 간단히 파일을 복사 
할수 있다. CopyOption의 구현체인 StandardCopyOption 중 REPLACE_EXISTING
을 이용하면 기존 파일이 있더라도 덮어쓴다. 

DirectoryStream<>는 디렉토리 내부 요소들을 사용할 때 유용하다. 
구현 내용은 ch15.node.file.UseFileTest.java를 Files 기반으로 변경한 것이므로 
자세한 설명은 생략한다. 

텍스트 파일을 읽는 두 가지 방법을 소개한다. 처음 방식은 newBufferedReader()
를 이용해서 기존의 I/O의 BufferedReader를 얻은 후 읽는 방법이다. 
두번째 방법은 간단한 파일 읽기를 위해 readAllLines()를 이용한 예이다. 

파일을 삭제할 때는 deleteIfExists() 나 delete()를 사용할수 있다. 

----------------------------------------------------
4.3 Buffer 

629 43/53

버퍼는 I/O에서 알아봤듯이 read/write 가 가능한 메모리상의 배열로 I/O의 
성능 향상을 위해 사용되며 NIO에서는 모든 입출력이 버퍼를 통해서 
이뤄진다. 

(1) 버퍼의 종류 
Buffer는 최상위 Buffer 클래스를 기반으로 처리하는 데이터 타입에 따라서 
ByteBuffer, ShortBuffer, CharBuffer, IntBuffer, LongBuffer, FloatBuffer,
DoubleBuffer가 제공된다. 

버퍼가 사용하는 메모리의 위치에 따라서는 다이렉트 버퍼 (Direct Buffer)와 
넌-다이렉트 버퍼(Non Direct Buffer)로 구별할 수 있다. OS의 메모리를 직접 
사용하는 형태가 다이렉트 버퍼, JVM의 메모리를 사용하는 형태가 넌-다이렉트 
버퍼이다. 이 둘의 특징에 대해 알아보자. 

다이렉트 버퍼와 넌-다이렉트 버퍼의 차이 
항목 : 다이렉트 버퍼 : 넌-다이렉트 버퍼 
메모리위치 : OS 메모리 : JVM 메모리(힙)
버퍼 생성 시간 : native C 코드 호출 등 OS와의 통신 비용이 추가로 발생하므로 느림 : 빠름 
사용 가능 크기 : 큼 : JVM의 제한된 메모리만 사용 가능 
입출력 성능 : 좋음 : 나쁨 

다이렉트 버퍼를 사용하기 위해서는 OS와의 추가적인 통신 비용이 발생한다. 
따라서 초기 생성 시간이 오래 걸리는 단점이 있지만, 사용 가능한 메모리 
공간이 크고 입출력 성능도 좋다. 반대로 넌-다이렉트 버퍼는 JVM의 힙을 
사용하기 때문에 버퍼 생성 소요 시간은 짧지만 사용할 수 있는 공간도 작고 
성능도 좋지 않다. 

따라서 대용량 데이터의 이동을 위해서는 다이렉트 버퍼가 유리하다. 
단 빈번히 생성하기 보다는 하나를 만들어서 재사용하는 것이 좋다. 

(2) 버퍼의 생성 

630 44/53

Buffer를 만들 때는 각 Buffer 클래스의 정적 메서드를 이용해서 생성한다. 

allocate() : 모든 타입의 버퍼 클래스들은 allocate() 메서드가 있다. 
이 메서드는 넌-다이렉트 버퍼를 생성한다. 파라미터로 버퍼에 저장할 
데이터의 개수를 지정한다. 다음은 1024*1024 즉 1M의 char를 
저장할 수 있는 다이렉트 버퍼를 생성하는 예이다. 

ex)
CharBuffer cUdBuffer = CharBuffer.allocate(1024*1024);

wrap() : 역시 모든 타입의 버퍼클래스들은 wrap() 메서드가 있다. 
wrap()은 이미 생성된 배열을 이용해서 버퍼 객체를 생성한다. 
기존의 배열을 이용하기 때문에 당연히 넌-다이렉트 버퍼이다. 
다음은 int의 배열인 ints[] 를 이용해 IntBuffer를 생성하는 예이다. 

ex)
int [] ints = {1,2 ,3, 4, 5, 6};
IntBuffer iUdBuffer = IntBuffer.wrap(ints);

allocateDirect() : allocateDirect() 는 ByteBuffer에만 존재하는 메서드로 
다이렉트 버퍼를 생성한다. 다음은 ByteBuffer 타입의 다이렉트 버퍼를 
생성하는 예이다. 

ex)
ByteBuffer bDBuffer = ByteBuffer.allocateDirect(1024*1024);

직접적으로 다이렉트 버퍼를 만드는 방법은 ByteBuffer에서 allocateDirect()
메서드를 사용하는 방법뿐이다. 다른 타입의 버퍼는 일단 다이렉트 버퍼인 
ByteBuffer를 생성한 후 asP#Buffer() 메서드를 이용해서 타입별 다이렉트
버퍼를 얻을수 있다. 

ByteBuffer의 버퍼 변환 메서드 

메서드 명 : 선언부와설명
asP#Buffer() : public abstract PBuffer asP#Buffer()
ByteBuffer를 P#Buffer 로 변환 후 리턴한다. 
P#는 Short, Int, Long, Char, Double, Float 을 나타낸다. 

ex)
ByteBuffer bDBuffer = ByteBuffer.allocateDirect(1024*1024);
CharBuffer cDBuffer = bDBuffer.asCharBuffer();

(3) 버퍼의 사용 
버퍼를 사용하기 위해서는 먼저 버퍼의 위치 속성을 
제어할수 있어야 한다. 

Buffer 클래스에는 버퍼 제어와 관련된 4가지 속성이 있다. 

Buffer의 크기와 위치 관련 속성 

속성 명 : 설명 
capacity : 버퍼의 최대 개수로 버퍼를 만들 때 지정한 크기를 말한다. 

limit : 버퍼에 있는 데이터의 한계로 처음에는 capacity와 같은 값을 갖는다. 
이후 flip() 을 실행하면 버퍼의 position이 limit에 할당된다. 

position : 버퍼에서 현재 커서의 위치 값으로 인덱스와 같다. 

mark : reset()을 실행 했을 때 돌아오기 위해 표시해 놓은 인덱스이다. 

위 값의 크기는 0 <= mark <= position <= limit <= capacity이다. 

다음은 position을 제어하기 위한 메서드들이다. 

메서드명 : 선언부와설명

flip() : public final Buffer flip()
현재의 position을 limit로 설정하고 position을 0으로 변경한다. 

mark() : public final Buffer mark()
현재 position 위치에 mark를 설정하고 reset() 시 이동할수 있게 한다. 

reset() : public final Buffer reset()
mark 가 표시된 위치로 position을 이동시킨다.

rewind() : public final Buffer rewind()
position을 0으로 이동하고 모든 mark를 제거한다. 

clear() : public final Buffer clear() 
position 을  0으로 이동하고 모든 mark를 제거하며 limit를 capacity로 설정한다. 

버퍼에서 데이터를 읽을 때는 get() 계열의 메서드를 사용한다. 

Buffer 타입별 get() 메서드 

구분 : ByteBuffer : P#Buffer 
상대적 : get() : get()
상대적 : get(byte [] dest) : get(p* [] dest)
상대적 : get(byte [] dest, int offset, int length) : get(p* [] dest, int offset, int length)
상대적 : putP#(p* value) :

절대적 : get(int index) : get(int index) 
절대적 : getP#(int index)

P#는 Short, Int, Long, Char, Double, Float을 나타내며, 
p*는 short, int, long, char, double, float

위 표에서 상대적이라는 말은 버퍼의 현재 position에서 데이터를 읽고 
저장하는 경우이고 position과 관계없이 특정 위치(index)에서 
데이터를 읽고 쓰는 경우가 절대적이다. 

처음 버퍼를 사용할 때 position 은 0을 가리키다가 상대적 메서드인 
get()이 호출되면 0 위치의 데이터를 리턴하고 1증가해서 1을 가리키게 된다. 
하지만 절대적 메서드들은 position의 증가가 발생하지 않는다. 

절대적 메서드를 통해서 버퍼의 내용을 조회할 때 index는 limit -1 을 
초과할수 없다.  버퍼에 데이터를 넣을 때는 put() 계열의 메서드를 사용한다. 

Buffer 타입별 put() 메서드 
구분 : ByteBuffer : P#Buffer
상대적 : put(byte value) : put(p* value)
상대적 : put(byte [] src) : put(p* [] src)
상대적 : put(byte [] src, int offset, int length) : put(p* [] src, int offset, int length)
상대적 : put(ByteBuffer src) : put(P#Buffer src)
상대적 : putP#(p* value)

절대적 : put(int index, byte b) : put(int index, p* value)
절대적 : putP#(int index, p* value)
P#는 Short, Int, Long, Char, Double, Float을 나타내며, 
p*는 short, int, long, char, double, float

상대적 및 절대적 메서드의 구분은 get() 계열과 동일하다. 
절대적 메서드를 통해서 값을 설정할 때 index는 capacity -1을 
초과할수 없다. 

버퍼의 사용법을 단계별로 알아보자. 

최초 버퍼를 만들면서 capacity를 지정하면 버퍼의 limit는 
capacity 와 같고, position은 0이다. 

ex)
ByteBuffer buffer = ByteBuffer.allocate(10);

[][][][][][][][][][][][][] -> limit, capacity : 끝
position

버퍼에 상대적 메서드를 이용해 데이터를 넣으면 값이 저장되며 
position이 이동한다.

ex)
buffer.put(new byte[] {1,2,3,4,5});

[1][2][3][4][5][][][][][] -> limit, capacity : 끝
5:position

하지만 절대적 메서드를 이용해 데이터를 넣으면 position이 이동하지 않는다. 

ex)
buffer.put(0, (byte)11);
buffer.put(7, (byte)7);

[1][2][3][4][5][][7][][][] -> limit, capacity : 끝
5:position

입력이 끝났다면 flip()을 호출해서 limit를 현재 버퍼의 position으로 
이동시킨다. 따라서 7의 위치에 입력한 데이터는 접근할수 없게 된다. 

ex)
buffer.flip();

[11][2][3][4][5][][][][][] -> limit :5, capacity:끝
5:position

get() 메서드를 이용해서 값을 읽을 때도 절대적 메서드는 
position을 이동시키지 않지만, 상대적 방식은 읽을 때 마다 
position을 1씩 이동시킨다. 이때 mark()를 호출하면 현재 position에
표시(mark)할수 있다. 

ex)
System.out.println(buffer.get(2)); // 절대적 읽기:3
System.out.println(buffer.get()); // 상대적 읽기:11
buffer.mark();

[11][2][3][4][5][][][][][] -> limit :5, capacity:끝
2:position
2: mark

다시 상대적인 get() 메서드를 이용해서 버퍼의 값을 읽으면 
position이 이동한다. 

ex)
byte [] dst = new byte[3];
buffer.get(dest);
System.out.println(Arrays.toString(dest)); // 상대적 읽기 : [2,3,4]

[11][2][3][4][5][][][][][] -> limit :5, capacity:끝
4:position
2: mark

position이 이동한 상태에서 reset()을 호출하면 position이 mark()를 
호출했던 위치로 변경된다. 

ex)
buffer.reset();

[11][2][3][4][5][][][][][] -> limit :5, capacity:끝
2:position
2: mark

다시 상대적인 get() 메서드를 이용해서 버퍼의 값을 읽고 position을 
이동시킨다.

ex)
byte [] dest = new byte[3];
buffer.get(dest);
System.out.println(Arrays.toString(dest)); // 상대적 읽기 : [2,3,4]

[11][2][3][4][5][][][][][] -> limit :5, capacity:끝
5:position
2: mark

rewind() 메서드를 호출하면 position 0으로 이동되고 mark도 사라진다. 
ex)
buffer.rewind()

[11][2][3][4][5][][][][][] -> limit :5, capacity:끝
11:position

clear()를 호출하면 position은 0을 가리키고 mark도 없어지며 
limt는 capacity로 확장돼서 추가적인 공간 활용이 가능하다. 

ex)
buffer.clear();

[11][2][3][4][5][][][][][] -> limit , capacity:끝
11:position

(4) 버퍼의 변환 
다양한 타입의 버퍼가 존재하지만 사실 채널은 ByteBuffer를 통해서만 
데이터를 읽고 쓸수 있다. 따라서 채널을 통해 데이터를 쓰고 읽기 전에 
ByteBuffer로 변환한 뒤에 처리해야 한다. 

635 49/53

int [] 데이터를 채널을 통해 다른 곳으로 전달하는 경우를 생각해보자. 
int []는 IntBuffer 가 가장 잘 처리 할수 있다. 하지만 채널을 통해서 
전달될 수 없기 때문에 ByteBuffer로 변경해야 한다. 이 때 
int는 4byte에 해당하기 때문에 ByteBuffer의 용량(capacity)은 
IntBuffer의 4배가 필요하다. 따라서 IntBuffer의 capacity * 4의 
capacity를 가진 ByteBuffer를 만들고 데이터를 putInt() 메서드를 
이용해서 데이터를 추가한다. 만약 데이터가 int 가 아니라면 각 타입에 
맞도록 ByteBuffer의 capacity나 putP#() 메서드를 변경해서 사용하면 된다. 

ex)
int [] src = {1024, 2048, 3072};
IntBuffer iBuffer = IntBuffer.wrap(src);
ByteBuffer bBuffer = ByteBuffer.allocate(iBuffer.capacity()*4);
for(int i=0; i < iBuffer.capacity(); i++){
bBuffer.putInt(iBuffer.get(i);
}

다시 채널을 통해 데이터를 받은 곳에서 ByteBuffer의 asP#Buffer()
메서드를 이용해 원하는 형태의 버퍼로 변경 후 사용한다. 

ex)
bBuffer.rewind();
IntBuffer iBuffer2 = bBuffer.asIntBuffer();
int [] target = new int[iBuffer2.capacity()];
iBuffer.get(target);
System.out.println("결과 : "+Arrays.toString(target)); 
// 결과 : [1024, 2048, 3072]

위와 같이 버퍼 변환을 위해서는 상당히 번거로운 과정을 거쳐야 한다. 
가장 빈번한 문자열 즉 CharBuffer와의 변환에는 좀 더 편리한 방법이 있다. 
java.nio.charset.Charset 클래스의 encode()와 decode() 메서드는 
ByteBuffer와 CharBuffer 간 손쉬운 변환 기능이 제공한다. 

Charset 을 이용한 ByteBuffer와 CharBuffer 간의 변환 

메서드 명 : 선언부와설명

forName() : public static Charset forName(String charsetName)
charsetName에 해당하는 Charset 객체를 리턴한다. 

encode() : public final ByteBuffer encode(String str)
str 데이터를 이용해 ByteBuffer를 생성하고 리턴한다. 

public final ByteBuffer encode(CharBuffer cb)
cb를 ByteBuffer로 변환 후 리턴한다. 

decode() : public final CharBuffer decode(ByteBuffer bb)
bb를 CharBuffer로 변환 후 리턴한다. 

ex)
String src = "안녕 Java World";
Charset charset = Charset.forName("utf-8");
ByteBuffer bBuffer = charset.encode(src);
CharBuffer cBuffer = charset.decode(bBuffer);
System.out.println(new String(cBuffer.array()));
// "안녕 Java World"

----------------------------------------------------
4.4 FileChannel 

Channel 의 예로 가장 많이 사용되는 FileChannel을 살펴보자. 
java.nio.channel.FileChannel은 파일 읽기와 파일 쓰는데 사용되는 채널이다. 
FileChannel은 동기화 처리되어 있으므로 멀티스레드 환경에서 안전하다. 
스트림과 달리 read()와 write()가 같이 있는 점이 큰 차이점이다. 

FileChannel의 주요 메서드 

메서드 명 : 선언부와설명

open() : public static FileChannel open(
Path path, OpenOption... options) throws IOException)
path에 연결된 FileChannel의 객체를 생성한다. 

close() : public final void close() throws IOException
FileChannel을 닫는다. 

read() : public abstract int read(ByteBuffer dst) throws IOException
FileChannel을 통해 읽은 파일의 내용을 dst에 저장한다. 

public final long read(ByteBuffer[] dsts) throws IOException
FileChannel을 통해 읽은 파일의 내용을 dsts에 저장한다. 

public abstract long read(
ByteBuffer[] dsts, int offset, int length)throws IOException
FileChannel을 통해 읽은 파일의 내용을 dsts의 offset부터 
length -1 까지에 저장한다. 

636 50/53

wirte() : public abstract int write(ByteBuffer src) throws IOException
src 의 내용을 FileChannel을 이용해 출력한다. 

public final long write(ByteBuffer src) throws IOException
srcs의 내용을 FileChannel을 이용해 출력한다. 

public abstract long write(
ByteBuffer[] srcs, int offset, int length) throws IOException
srcs의 offset부터 length -1 까지의 내용을 FileChannel을 이용해 
출력한다. 

transferTo() : public abstract long transferTo(long position, long count,
WritableByteChannel target) throws IOException
bb를 CharBuffer로 변환 후 리턴한다. 

transferFrom() : public abstract long transferFrom(ReadableByteChannel src, 
long position, long count) throws IOException
bb를 CharBuffer로 변환 후 리턴한다. 

(1) 파일 열기와 닫기 

637 51/53

FileChannel의 open()과 close() 메서드는 FileChannel을 열거나 닫는다. 
open()시에는 OpenOption을 파라미터로 전달할수 있다. 
OpenChannel의 구현체로 enum인 SharedOpenOption을 사용한다. 

다음은 SharedOpenOption에 정의된 enum 상수 값이다. 

SharedOpenOption의 enum 상수값 

enum 상수값 : 설명 

READ : 읽기용으로 파일을 오픈한다. 
WRITE : 쓰기용으로 파일을 오픈한다. 
CREATE : 파일이 없으면 새로운 파일을, 있으면 기존 파일을 오픈한다. 
CREATE_NEW : 새 파일을 만들며 기존 파일이 있으면 
java.nio.FileAlreadyExistsException 예외가 발생한다. 
APPEND : 파일 뒤에 내용을 추가한다. 
DELETE_ON_CLOSE : 주로 임시 파일에 사용되며 
채널을 닫을 때 파일을 삭제한다. 

실제 FileChannel을 열기 위해서는 SharedOpenOption을 조합해서 사용한다. 
읽기 전용으로 사용하려는 경우는 SharedOpenOption.READ가 사용되고 
파일을 생성하고 내용을 쓰기 위해서는 SharedOpenOption.CREATE_NEW 와 
SharedOpenOption.WRITE를 사용한다. 

(2) 파일 읽기와 쓰기 
파일 읽기와 쓰기에는 앞서 학습한 Buffer를 파라미터로 read()와 
write() 메서드를 사용한다. 기본적인 사용법은 스트림과 유사하다. 
read() 할 때에는 읽은 데이터의 개수가 리턴되는 데 더 이상 읽을 
데이터가 없을 때에는 -1이 리턴된다. 

다음은 FileChannel을 이용해서 데이터를 읽고 쓰는 예이다. 

ex)
package ch15.nio.channel;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.Charset;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;

public class FileChannelTest {

	public static void main(String[] args) {
		FileChannelTest fct = new FileChannelTest();
		fct.writeToFile();
		fct.copyFile();
	}

	public void writeToFile() {
		Path srcPath = Paths.get("c:/Temp/byChannel.txt");
		Charset utf8 = Charset.forName("utf-8");
		try (FileChannel writeChannel = FileChannel.open(srcPath, StandardOpenOption.CREATE, StandardOpenOption.WRITE);) {
			String src = "안녕 FileChannel. 일반 I/O 대비 쉽나요?";
			ByteBuffer bBuffer = utf8.encode(src);

			int byteCnt = writeChannel.write(bBuffer);
			System.out.println(byteCnt + "byte 출력 완료!");
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public void copyFile() {
		Path srcPath = Paths.get("c:/Temp/byChannel.txt");
		Path targetPath = Paths.get("c:/Temp/byChannel2.txt");
		try (FileChannel readChannel = FileChannel.open(srcPath, StandardOpenOption.READ);
			 FileChannel writeChannel = FileChannel.open(targetPath, StandardOpenOption.CREATE, StandardOpenOption.WRITE);) {
			int read = -1;
			ByteBuffer readBuffer = ByteBuffer.allocate(20);
			while ((read = readChannel.read(readBuffer)) > 0) {
				readBuffer.flip();// position을 다시 0으로 변경 필요
				writeChannel.write(readBuffer);
				readBuffer.clear();
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}
//
48byte 출력 완료!

문자열을 저장할 Path 객체 srcPath를 생성한다. 

문자열을 ByteBuffer로 변경하기 위해 utf-8을 기반으로 하는 Charset을 
생성한다. 

파일 생성 + 쓰기 옵션을 이용해 FileChannel인 writeChannel을 생성한다. 

Charset을 이용해 문자열을 ByteBuffer bBuffer로 변환한다. 

writeChannel을 이용해 bBuffer의 내용을 출력하면 srcPath에 
내용이 저장된다. 

읽고 쓰기 위한 readChannel과 writeChannel을 생성한다. 
readChannel은 읽기 전용, writeChannel은 생성 및 쓰기 옵션을 
적용한다. 

크기가 20byte인 ByteBuffer를 다이렉트 모드로 생성한다. 

readChannel을 이용해 읽은 내용을 readBuffer에 저장한다. 
이때 읽은 개수가 -1이면 반복을 벗어난다. 이 때 readBuffer에 쓰는 작업이 
일어나므로 position은 19까지 이동한 상태이다. 

flip() 메서드를 이용해 position을 0으로 이동시킨다. 

writeChannel의 write() 를 통해 readBuffer의 내용을 출력한다. 

readBuffer의 clear()를 통해 버퍼를 초기화한다. 



===================================
[자바 해바라기 정리] 16 스트림 API

1. 스트림 API 소개 

스트림 API란 자바 8에서부터 추가된 java.util.stream 패키지로 I/O의 스트림과는 
전혀 무관하다. 
스트림 API의 주요 목적은 배열을 포함 컬렉션(데이터 소스)의 저장 요소를 
하나씩 참조해서 람다식으로 처리할수 있도록 해주는데 있다. 
사실 스트림 API가 하던 일들은 기존에도 개발자의 코드를 통해서 
처리하던 일이다. 그 럼 왜 스트림 API가 필요한지 스트림 API의 주요 역할과 
특징에 대해 알아보자. 

1.1 스트림 API 의 주요 역할과 특징 

(1)간결한 코드. 

640 1/42

스트림 API가 나오기 전과 후의 코드를 비교해보자. 

자바 7까지 컬렉션에서 List<String>에 담긴 요소 중 3글자 이상인 요소를 
순차적으로 출력하기 위한 코드는 다음과 같다. 

ex)
List<String> heroes = Arrays.asList("아이언맨","스파이더맨","헐크","토르");
List<String> sub = new ArrayList<>();
for (String hero : heroes) {
if ( hero.length() > 3) {
sub.add(hero);
}
}
for (String hero : sub) {
System.out.println(hero);
}

요소들을 검증하고 출력하기 위해 매번 반복문을 이용해야 하고 
반복문 내에서 처리할 비즈니스 로직을 작성한다. 

이 코드를 자바 8에서부터 지원하는 스트림 API를 이용해서 
변경해보면 다음과 같다. 

ex)
List<String> heroes = Arrays.asList("아이언맨","스파이더맨","헐크","토르");
Stream<String> stream = heroes.stream();
stream.filter(hero -> {
return hero.length() > 3;
}).forEach(System.out::println);

Stream 객체를 얻은 후 filter() 나 forEach()같은 메서드가 물 흐르듯이 
계속 이어지는 형태로 되어 있다. 스트림 API는 내부 반복자를 이용하기 
때문에 별도의 반복문이 노출 되지 않는다. 
filter()와 forEach()는 각각 Predicate와 Consumer 타입의 함수형 인터페이스
를 파라미터로 받는다. 이처럼 스트림 API를 사용하면 기존 방식 대비 
코드가 매우 간결해짐을 알수 있다. 

(2) 컬렉션과 배열 등 데이터 소스에 대한 공통된 접근 가능 
자바의 컬렉션은 처음부터 완성된 모습으로 등장하지 않고 계속해서 
업그레이드되었다. 그러다 보니 Collection과 같은 인터페이스로 
표준화하기는 했지만 아무래도 표준화된 접근이 쉽지 않다. 
예를 들어 List를 정렬할 때는 Collection.sort(List)를 사용할수 있지만, 
Set 계열은 불가능하다. Set 계열은 TreeSet을 사용해야 한다. 
배열의 정렬에는 Arrays.sort()가 사용된다. 하지만 이들은 모두 스트림
객체를 제공하고 스트림의 sorted()메서드를 통해 공통된 방식으로 정렬
처리가 가능하다. 

ex) 스트림 API를 이용한 정렬
List<String> --> Collection.sort(List) => List<String>->Stream->sorted()
String[] --> Arrays.osrt(String[]) => String [] -> Stream ->sorted()
Set<String> --> TreeSet<String> => Set<String> -> Stream ->sorted()

(3) 중간 처리와 최종 처리를 조합해서 처리 가능 

스트림 API가 제공하는 다양한 메서드를 이용하면 복잡한 작업을 간단히 
처리할수 있다. 이 메서드들은 중간 처리와 최종 처리 둘로 나뉜다. 여기서 
중간 처리는 매핑, 필터링, 정렬 등 데이터 가공을 담다하고 최종 처리는 반복, 
카운팅, 평균, 총합 등 집계 처리를 담당한다. 이때, 중간 처리는 필요한 만큼 
여러 개를 사용할수 있고 최종 처리는 하나만 사용된다. 

ex) 스트림 API의 조합
데이터소스->Stream->필터링->정렬->매핑->카운팅,...,평균 (최종처리1개)
//필터링 부터 ~ 매핑 : 중간처리 n개 

(4) 병렬처리 작업이 용이 
스트림 API의 stream() 메서드는 내부 반복자를 이용해 순차적으로 처리한다. 
여기에 단순히 stream() 메서드 대신 parallelStream() 메서드를 사용하면 순차 
처리를 병렬처리로 전환할수 있다. 이렇게 하면 내부적으로는 스레드 풀을 
이용해 병렬적으로 요소를 처리한다. 

ex)
set.stream().forEach(System.out::println); // 순차처리 
set.parallelStream().forEach(System.out::println); // 병렬처리 

(5) 연산의 결과를 원본에 반영하지 않음 
스트림 API는 원본 데이터에 대한 뷰처럼 데이터 소스로부터 읽기만 할 뿐 
변경하거나 별도로 저장하지 않는다. 다만 필요하다면 결과를 새로운 컬렉션이나 
배열에 담아서 반환할 수 있다. 

ex) 
List<String> sorted =
stream.sorted(String::compareTo).collect(Collectors.toList());

----------------------------------------------------
2. 스트림 API 자료 처리 

스트림 API는 언제나 생성 -> 중간 처리 -> 최종 처리의 3단계를 거친다. 
중간 처리는 스트림을 변환(map) 시키는 단계이고 최종 처리는 스트림을 
사용하는 단계이다. 단계별 특징을 알아보자. 

2.1 스트림 API의 종류와 획득 

스트림 API는 java.util.stream 패키지에서 제공되며 최상위에 BaseStream 인터페이스
를 비롯해 처리하는 타입별로 Stream, IntStream, LongStream, DoubleStream이 있다. 

ex) 스트림의 종류 
BaseStream : Stream, IntStream, LongStream, DoubleStream

이 중 Stream 은 일반적인 모든 객체를 처리할 때 사용되고 IntStream, LongStream,
DoubleStream은 각각 int, long, double 타입의 데이터를 처리하는데 
사용된다. 

스트림의 소스로는 일반적으로 배열이나 컬렉션이 사용되지만 다른 스트림이나 
Path, int 나 long 의 범위, 랜덤 숫자 등에서도 얻을 수 있다. 
이런 소스들의 stream(), parallelStream()등 메서드는 Stream 객체를 리턴한다. 

ex) Collection과 배열에서의 스트림 생성 
소스 : 메서드 

Collection
1) default Stream<E> stream()
2) default Stream<E> parallelStream()

Arrays 
1) public static <T> Stream<T> stream(T[] array)
2) public static <T> Stream<T> of(T...values)
3) public static IntStream stream(int [] array)
4) public static IntStream of(int ... values)
5) public static LongStream stream(long [] array)
6) public static LongStream of(long ... values)
6) public static DoubleStream stream(double [] array)
7) public static DoubleStream of(double ... values)

다음은 배열과 컬렉션에서 스트림을 얻는 예이다. 

ex)
package ch16.getstream;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;

public class FromCollectionTest {

	public static void main(String[] args) {
		String[] heroes = { "아이언맨", "스파이더맨", "헐크", "토르" };
		Stream<String> fromArray = Arrays.stream(heroes);

		List<String> heroList = Arrays.asList(heroes);
		Stream<String> fromList = heroList.stream();
		fromList.forEach(a -> System.out.print("[" + a + "], "));
	}
}
//
[아이언맨], [스파이더맨], [헐크], [토르], 

데이터 소스로 사용할 String 의 배열을 만들고 Arrays.stream()을 
통해 스트림을 생성한다. 
String 배열을 이용해 List<String> 객체를 만들고 Collection의 stream()으로 
스트림을 생성한다. 
스트림의 최종 처리 메서드인 forEach()문으로 스트림의 요소들을 하나씩 
출력한다. 

정수의 범위와 Random을 통해서 스트림을 생성하는 방법에 대해 알아보자. 

범위와 관련된 스트림 생성 

ex) 범위와 관련된 스트림 생성 
소스 : 메서드 

int 범위 
1) public static IntStream range(int startInclusive, int endExclusive)
2) public static IntStream rangeClosed(int startInclusive, int endExclusive)

long 범위 
1) public static LongStream range(long startInclusive, final long endExclusive)
2) public static LongStream rangeClosed(long startInclusive, final long endExclusive)

Random 
1) public P#Stream p*s()
1) public P#Stream p*s(long streamSize)
1) public P#Stream p*s(long streamSize , p* origin, p* bound)
P#는 Int, Long, Double, 을 
p* int, long, double을 나타낸다. 

range()와 rangeClosed()의 차이는 두번째 파라미터를 범위에 포함할 것인지의 
차이이다. range()는 startInclusive <= x < endExclusive 이지만 
rangeClosed()는 startInclusive <= x <= endtInclusive 이다. 

다음은 범위와 Random을 이용한 스트림 생성 예이다. 

ex)
package ch16.getstream;

import java.util.Random;
import java.util.stream.IntStream;
import java.util.stream.LongStream;

public class FromRangeTest {

	public static void main(String[] args) {
		IntStream iStream = IntStream.rangeClosed(1, 6);
		System.out.println("데이터 개수: "+iStream.count());
		
		Random random = new Random();
		LongStream lStream = random.longs(7, 1, 46);
		System.out.println("합: "+lStream.average().getAsDouble());
	}
}
//
데이터 개수: 6
합: 15.857142857142858

마지막으로 파일과 관련된 스트림의 생성에 대해 알아보자. 

파일과 관련된 스트림 생성 
소스 : 메서드 
Files 
1) public static Stream<Path> find(Path start, int maxDepth,
BiPredicate<Path, BasicFileAttributes> matcher, FileVisitOpion...options)

2) public static Stream <Path> list(Path dir) throws IOException

3) public static Stream<String> lines(Path path, Charset cs) throws IOException

4) public static Stream<String> lines(Path path) throws IOException

BufferedReader 
1) public Stream<String> lines()

Stream<Path> 의 경우 Path 의 목록을 관리하며 Stream<String>의 경우 
텍스트 기반의 파일의 내용을 관리한다. 
다른 스트림들과 달리 파일과 관련된 스트림은 close()를 호출해서 
리소스 릭(resource leak)을 막아주어야 한다. 

ex)
package ch16.getstream;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.function.BiPredicate;
import java.util.stream.Stream;

public class FromFile {

	public static void main(String[] args) throws IOException {
		Path current = Paths.get(".");
		BiPredicate<Path, BasicFileAttributes> matcher = (t, u) -> {
			return Files.isDirectory(t);
		};
		Stream<Path> pStream = Files.find(current, 1, matcher);
		pStream.forEach(System.out::println);
		pStream.close();

		Path pom = Paths.get("./pom.xml");
		Stream<String> lines = Files.lines(pom);
		System.out.println("총 라인 수: " + lines.count());
		lines.close();
	}
}
//
.
.\.git
.\.settings
.\src
.\target
총 라인 수: 0

현재 경로를 이용하는 Path current를 만든다. 

필터 역할을 수행할 BiPredicate 타입의 matcher 객체를 생성한다. 
Path에 해당하는 파일이 디렉터리인 경우 true를 리턴한다. 

current를 기반으로 스트림 pStream을 생성한다. 이 때 1단계 하위
경로까지 검색하며 matcher에 의해 디렉터리인 경우만 스트림에 반영된다. 

스트림의 내용을 출력하고 close() 처리한다. 

현재 경로 아래 pom.xml 파일을 이용한 Path pom을 생성한다. 

lines()를 통해  pom.xml 의 모든 행을 사용하는 스트림 lines 를 생성한다. 

lines가 사용하는 요소의 개수를 출력하고 close() 처리한다. 


----------------------------------------------------
2.2 맵/리듀스(Map/Reduce) 모델 지원 

646 7/42

스트림 소스에서 스트림을 생성하면 본격적으로 스트림 API를 사용할수 있다. 
스트림 API는 맵/리듀스 모델을 지원하는데 맵/리듀스 모델은 대규모의 
데이터 집합을 처리하기 위한 모델이다. 

맵은 중간 처리 과정으로 데이터들을 다양한 메서드에 매핑시켜서 원하는 형태로 
가공하고 걸러낸다. 필요에 따라서 여러 메서드를 연결해서 사용할수 있다. 
이 중간 처리의 예 로는 중복 제거, 필터링, 생략, 변환, 정렬 등을 들수 있다. 

리듀스는 최종 처리 과정으로 맵의 결과를 줄여서 원하는 결과로 반환하는 것이다. 
최종 처리는 중간 연산과 달리 한번만 사용한다. 최종 처리의 예로 각 요소에 
대해 지정된 작업을 수행하거나 최대, 최소를 구하는 등을 들수 있다. 

중간 처리 과정 메서드들은 스트림을 리턴하는데 이는 기존 스트림을 바탕으로 
한 새로운 스트림 객체이다. 즉 String 과 마찬가지로 스트림도 한 번 만들어지면 
변경되지 않는다. 최종 처리 과정은 스트림이 아니라 메서드에 적합한 값을 
리턴한다. 

단계별 주요 처리 메서드들을 알아보자. 

ex)단계별 주요 메서드 

중간 처리 
용도 : 메서드
필터링 : distinct(), filter()
자르기 : skip(), limit()
정렬 : sorted()
매핑(변환) : flatMap(), flatMapToP#(),
map(), mapToP#(),asDoubleStream(),
asLongStream()
조회 : peek()

최종처리 
용도 : 메서드 
매칭 : allMatch(), anyMatch(), noneMatch()
수집 : collect()
루핑 : forEach()
집계 : count(), max(), min(), average(), sum(), reduce()
조사 : findFirst(), findAny() 

P#는 Int, Long, Double 을 나타낸다. 

또 한 가지 특이한 점은 스트림 API는 최종 처리가 진행될 때까지 
중간 처리는 지연된다는 점이다. 
다음 코드는 mapToInt()라는 중간 처리 메서드를 사용했지만, 
최종 처리가 아직 없다. 따라서 아무것도 출력되지 않는다. 

ex) 
list.stream().mapToInt(data -> {
System.out.println("문자열의 길이: " + data);
return data.length();
});

다음 예처럼 최종 처리 메서드를 호출할 경우 비로소 중간 처리 메서드가 
동작한다. 

ex)
list.stream().mapToInt(data -> {
System.out.println("문자열의 길이 :  "+ data);
return data.length();
}).sum();

이제 본격적으로 스트림 API를 이용한 자료 처리 방식에 대해 알아보자. 
참고로 API에 대한 설명은 Stream 클래스를 기준으로 일부만 진행하며 
대부분 경우 IntStream, LongStream, DoubleStream에도 유사한 
메서드가 제공된다. 
----------------------------------------------------
3. 중간 처리 

3.1 필터링 

필터링은 스트림의 요소 일부를 줄이는 역할을 한다. 

ex) 필터 역할을 하는 Stream의 중간 처리 메서드 

메서등 명 : 선언부와설명
distinct() : Stream<T> distinct()
스트림 요소의 중복을 제거한 스트림을 리턴한다. 

filter() : Stream<T> filter(Predicate< ? super T> predicate)
Predicate의 test()가 true를 리턴하는 요소로 구성된 스트림을 리턴한다. 

distinct() 가 중복으로 판단하는 기준은 Object의 equals() 결과가 true이고 
hashCode()가 같은 값을 리턴할 때이다. 
----------------------------------------------------
3.2 자르기 
자르기는 스트림의 일부 요소를 생략한다. 

ex) 자르기 역할을 하는 Stream의 중간 처리 메서드 

메서드 명 : 선언부와 설명 
limit() : Stream<T> limit(long maxSize)
스트림 요소에서 maxSize 까지만으로 구성된 스트림을 리턴한다. 

skip() : Stream<T> skip(long n) 
스트림 요소에서 상위 n 개가 생략된 스트림을 리턴한다. 

----------------------------------------------------
3.3 정렬 

정렬은 스트림의 요소들을 내장 또는 사용자 정의 Comparator를 이용해 
정렬 처리한다. 

ex) 자르기 역할을 하는 Stream 의 중간 처리 메서드 
메서드명 : 선언부와 설명 
sorted() : Stream<T> sorted()
스트림의 요소가 Comparable 타입일 때 요소의 compare() 메서드를 이용해 
정렬된 스트림을 리턴한다. 

Stream<T> sorted(Comparator<? super T> comparator)
Comparator에 의해 정렬된 요소의 스트림을 리턴한다. 

(1) Comparator의 static , default 메서드 
자바 8에서부터는 Comparator에 많은 수의 static 메서드와 default 메서드가 
추가되어 편리하게 사용할수 있다. 

다음은 Comparator의 자주 사용되는 static 메서드 예시이다. 

ex)Comparator 의 static 메서드 

메서드 명 : 선언부와설명

naturalOrder() : public static <T extends Comparable < ? super T>>
Comparator<T> naturalOrder()
Comparable 타입의 T의 compareTo()에 의해 오른차순 정렬하는 
Comparator를 리턴한다. 

reverseOrder() : public static <T extends Comparable<? super T>>
Comparator<T> reverseOrder()
naturalOrder()의 역순으로 정렬하는 Comparator를 리턴한다. 

comparing() : public static <T, U extends Comparable<? super U>>
Comparator<T> comparing(Function<? super T, ? extends U>keyExtractor)
Function이 T를 파라미터로 받아서 Comparable 타입의 U를 리턴할 때 
U를 기준으로 정렬하는 Comparator<T>를 리턴한다. 

comparingP#() : public static <T> Comparator <T>
comparingT(ToP#Function<? super T> keyExtractor)
comparing()에서 U의 타입이 P일 경우 별도의 오토박싱 없이 처리하는 
메서드이다. 

nullsFirst() : public static <T> Comparator<T>
nullsFirst(Comparator<? super T> comparator)
정렬 결과 null 값을 맨 처음에 위치 시킨다. 

nullsLast() : public static <T> Comparator <T> nullsLast(
Comparator<? super T> comparator)
정렬 결과 null 값을 맨 나중에 위치시킨다. 

P#는 Int, Long, Double을 나타낸다. 

다음은 Comparator의 comparing() 메서드 사용 예로 문자열을 입력받아서 
반환되는 길이를 기준으로 정렬하는 Comparator를 반환한다.

ex)
Comparator<String> byLength =
Comparator.comparing(str -> { retrun str.length(); });

다음은 Comparator의 자주 사용되는 default 메서드 예시이다. 

ex)
Comparator 의 default 메서드 
메서드 명 : 선언부와 설명 
reversed() : default Comparator<T> reversed()
현재 Comparator의 정렬 방식의 역순으로 정렬하는 Comparable를 
리턴한다. 

thenComparing() : default Comparator<T> thenComparing(
Comparator<? super T> other)
)
1차 정렬 이후 추가적인 정렬을 위한 Comparator를 리턴한다. 

thenComparingP#() : default Comparator<T> thenComparingP#(
ToP#Function< ? super T> keyExtractor)
비교 대상이 기본형인 경우 thenComparing () 대신 사용한다. 

P#는 Int, Long, Double 을 나타낸다. 

위 메서드들은 default 메서드이기 때문에 기본 정렬 객체를 하나 두고 
거기에 연결해서 사용한다. 
즉 기본 정렬을 만든 후 역순으로 정렬하게 하거나 기본 정렬을 만든 후 
추가적인 2차, 3차 정렬 기준을 추가하는 형태다. 

다음 예는 String의 compareTo()를 이용하는 strComp를 만든다. 
여기에 역순 정렬을 위한 reversed()를 추가해 알파벳 내림차순으로
바꾼 후 thenComparing()을 통해 2차 정렬로 길이를 비교한다. 

ex)
package ch16.intermediate;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;

public class IntermediateOperation1 {
	List<String> words;

	public void setUpStream() {
		Path text = Paths.get("./src/res/강남스타일.txt");
		try {
			byte[] bytes = Files.readAllBytes(text);
			String data = new String(bytes);
			words = Arrays.asList(data.split("\\b"));
			System.out.println("초기 단어 개수: " + words.size());
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public void filterTest() {
		System.out.println("[필터 테스트]");
		System.out.println("중복 제거 결과: " + words.stream().distinct().count());
		System.out.println("필터 결과: " + words.stream().filter(a -> {
			return a.length() > 5;
		}).count());
	}

	public void limitTest() {
		System.out.println("[자르기 테스트]");
		System.out.println("중복 제거 결과: " + words.stream().limit(5).count());
		System.out.println("필터 결과: " + words.stream().skip(5).count());
	}

	public void sortTest() {
		System.out.println("[정렬 테스트]");
		words.stream().distinct().sorted((a, b) -> {
			return a.compareTo(b)*-1;
		}).limit(3).forEach(System.out::println);
	}

	public static void main(String[] args) {
		IntermediateOperation1 ft = new IntermediateOperation1();
		ft.setUpStream();
		ft.filterTest();
		ft.limitTest();
		ft.sortTest();
		Comparator.reverseOrder();
	}
}
//
초기 단어 개수: 328
[필터 테스트]
중복 제거 결과: 72
필터 결과: 2
[자르기 테스트]
중복 제거 결과: 5
필터 결과: 323
[정렬 테스트]
한잔의
품격
푸는

//단어들을 저장할 List<String> words를 선언한다. 

강남스타일.txt 파일을 읽은 후 단어별로 쪼개서 words에 저장한다. 
문서의 내용 전체를 이용해 문자열을 만든 후 split() 메서드를 이용해서 
단어 단위로 쪼갠다. split()의 파라미터인 "\\b"는 정규표현식으로 
단어의 경계문자(boundary word : 공백, 쉼표, 개행 문자등)을 
나타낸다. 출력 결과를 보면 초기 단어의 개수는 328개이다. 

스트림에 필터 처리를 해본다. 27행은 distinct()가 중간 처리, 
count() 가 최종 처리이다. 중복을 제거한 결과는 72개이다. 
28~30행에서는 filter()를 적용하는데 
Predicate에서는 문자열의 길이가 5를 넘는 경우만 대상으로 한다. 
결과는 2개이다. 

스트림에 자르기 처리를 해본다.  35행은 limit()를 이용해서 
상위 5개만을 대상으로 삼는다. 36행의 skip()에서는 5개를 
생략한다. 따라서 결과는 328에서 5개가 제외되므로 323이된다. 

스트림에 정렬 처리를 해본다. 여기서는 distinct()->sorted()->limit()
의 순서로 중간 처리 스트림을 사용한다. sorted()에서는 String의 알파벳 
내림차순으로 정렬하도록 Comparator를 제공한다. 최종 처리 메서드로 
forEach()를 사용하여 요소들을 출력한다. 

----------------------------------------------------
3.4 매핑(변환)

매핑은 스트림 요소의 값 중에서 원하는 부분만 뽑아내거나 특정 형태로 
변환할 때 사용된다. 매핑 계열을 Function 인터페이스를 파라미터로 
받는다. 매핑에는 크게 map() 계열과 flatMap() 계열이 있다. 

map()계열은 기존 스트림 요소와 1:1로 구성된 새로운 스트림을 생성한다. 
예를 들어 문자열(String)로 구성된 스트림을 문자열의 길이 (int)로 
구성된 스트림으로 변경할수 있다. 
반면 flatMap()은 기존 스트림 요소에 대해 1:n 으로 대응된 새로운 스트림을 
리턴한다. 예를 들어 문자열(String)로 구성된 스트림을 문자(char...)로 
구성된 스트림으로 변경할수 있다. 

ex) 매핑을 위한 Stream의 중간 처리 메서드 

메서드명 : 선언부와 설명 

map() : <R> Stream<R> map(Function<? super T, ? extends R> mapper)
스트림의 요소 T와 1:1로 대응되는 R로 구성된 새로운 스트림을 리턴한다. 

mapToP#() : P#Stream mapToP#(ToP#Function<? super T> mapper)
map()에서 R이 P로 한정된다. 별도의 형변환이 필요 없는 장점이 있다. 

flatMap() : <R> Stream <R> flatMap(
Function<? super T, ? extends Stream<? extends R>>mapper)
map()에서 R이 P로 한정된다. 별도의 형변환이 필요 없는 장점이 있다. 

flatMap() : <R> Stream<R> flatMap(
Function<? super T, ? extends Stream<? extends R>> mapper)
스트림의 요소 T가 1:n 으로 해체돼서 n개의 R로 구성된 새로운 스트림을 리턴한다. 

flatMapToP#() : P#Stream flatMapToP#(
Function<? super T, ? extends P#Stream> mapper) 
flatMap()에서 R이 P#로 한정된다. 별도의 형변환이 필요없는 장점이 있다. 
P#는 Int, Long, Double을 나타낸다. 

Stream의 mapToP#() 나 flatMapToP#()와 비슷하게 IntStream, LongStream,
DoubleStream은 mapToObj()와 flatMapToObj() 메서드가 존재한다. 
역할은 기본형을 객체형으로 바꿔준다. 

(1) map() 계열 
중간 연산으로 map 계열의 매핑이 사용하는 예제를 살펴보자. 

ex)
package ch16.intermediate;

import java.util.Arrays;
import java.util.List;
import java.util.stream.IntStream;

public class IntermediateOperation2 {

	public static void main(String[] args) {
		List<String> list = Arrays.asList("Hello", "Stream");
		// String -> char []
		list.stream().map(item -> item.toCharArray()).forEach(data -> {
			System.out.println(data.length);
		});
		// String -> int
		IntStream is = IntStream.range(3, 5);
		is.mapToObj(num -> {
			return "제곱: " + num * num;
		}).forEach(System.out::println);
	}
}
//
5
6
제곱: 9
제곱: 16

// String으로 구성된 스트림을 map() 메서드를 이용해 char[]로 구성된 
스트림으로 변경 후 각 요소의 length 속성값을 출력한다. 

Hello, Stream -> [H,e,l,l,o], [S,t,r,e,a,m]

int 로 구성된 스트림을 mapToObj() 메서드를 이용해 문자열(제곱: O 등)
로구성된 스트림으로 변경하고 각 요소를 출력한다. 

3, 4 -> 제곱 :9, 제곱 :16

이처럼 map() 계열은 스트림의 요소 개수는 변경되지 않는다. 

(2)flatMap() 계열 
다음은 flatMap() 계열이 필요한 경우를 생각해보자. 

단어들로 구성된 스트림에서 사용된 모든 알파벳의 개수를 알아보려면 
어떻게 해야 할까? 이요청 사항을 처리하기 위해서는 단어로 구성된 스트림보다는 
각 단어를 구성하고 있는 알파벳들로 구성된 스트림이 필요할 것이다. 
이를 위해 split()을 이용해서 문자열을 분리하고 스트림으로 만들어보자. 
이때 문자열이 map()을 이용해 알파벳으로 구성된 스트림을 변경될수 있다. 

ex)
List<String> list =Arrays.asList("Hello", "Stream");
System.out.println(list.stream().map(data -> {
return Arrays.stream(data.split("");
}).count());

기대와 달리 위 코드의 출력 결과는 2이다. map()을 통해 새롭게 구성된 
스트림은 바램과 달리 Stream <Stream <String>>의 형태이다. 

Hello, Stream -> H, e, l, l, o   S,t,r,e,a,m 

여기서는 Stream<String>의 형태의 스트림으로 구성해야 개별 문자의 개수를 
셀수 있다. 이 때 사용되는 것이 flatMap()이다. 
flatMap()은 기존의 스트림 요소를 n개로 분해한 요소들로 이뤄진 스트림을 
생성한다. 다음과 같이 map()을 flatMap()으로 변경 후 실행해보면 11이 출력된다. 

ex)
List<String> list =Arrays.asList("Hello", "Stream");
System.out.println(list.stream().flatmap(data -> {
return Arrays.stream(data.split("");
}).count());

Hello, Stream -> H, e, l, l, o,S,t,r,e,a,m 

----------------------------------------------------
3.5 조회(주석)

peek() 메서드는 스트림 처리 과정에서 처리가 잘 되고 있는지 확인 할 때 
사용되는 중간 처리이다. 일반적으로 스트림 처리를 확인하는 로그 출력의 용도로 
많이 사용된다. peek()는 Consumer를 파라미터로 받으며 전체 처리에 아무런 
영향을 끼치지 않으므로 여러 번 실행해도 무방하다. 

ex) 조회(검사)를 위한 Stream 의 중간 처리 메서드 

메서드 명 : 선언부와설명
peek() : Stream<T> peek(Consumer < ? super T> action)
스트림의 요소 T와 1:1 로 대응되는 R로 구성된 새로운 스트림을 리턴한다. 

list.stream().flatMap( data -> {
return Arrays.stream(data.split(""));
}).peek(item -> System.out.println("flat map 후 중간점검: " + item))
.distinct()
.peek(item -> System.out.println("distinct 후 중간점검 : " + item))
.forEach(System.out::println);

----------------------------------------------------
4. 최종 처리 

4.1 매칭

매칭은 요소들이 특정 조건에 만족하는지 조사하는 기능이다. 
매칭을 위해서는 allMatch(), anyMatch(), noneMatch()가 사용된다. 
이 메서드들은 파라미터로 Predicate를 전달받고 그 결과를 이용해 판단한다. 

ex)
매칭을 위한 Stream의 최종 처리 메서드 

메서드명 : 선언부와설명

allMatch() : boolean allMatch(Predicate<? super T> predicate)
스트림의 모든 요소가 Predicate의 조건을 만족하면 true를 리턴한다. 

anyMatch() : boolean anyMatch(Predicate<? super T> predicate)
스트림의 요소 중 하나라도 Predicate의 조건을 만족하면 true를 리턴한다. 

noneMatch() : boolean noneMatch(Predicate<? super T> predicate)
스트림의 요소 중 하나도 Predicate의 조건을 만족하지 않으면 true를 리턴한다. 

다음은 문서의 단어를 이용해 스트림을 구성한 후 그중 5글자 이상인 것이 
있는지를 anyMatch()를 이용해 구현한 예이다. 

ex)
package ch16.terminate;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.List;

public class MatchingTest {

	public static void main(String[] args) throws IOException {
		Path text = Paths.get("./src/res/강남스타일.txt");
		List<String> lines = Files.readAllLines(text);
		boolean result = lines.stream()
		.flatMap(line -> {
			return Arrays.stream(line.split("\\b"));
		}).distinct().filter(word -> {
			return word.trim().length() > 0;
		}).peek(System.out::println)
		.anyMatch(word -> {
			return word.length() > 5;
		});
		System.out.println("stream의 단어들에는 5글자 이상인 것이 있다? "+result);
	}
}
//
오빤
강남스타일
낮에는
따사로운
인간적인
여자
커피
한잔의
여유를
아는
품격
있는
밤이
오면
심장이
뜨거워지는
그런
반전
나는
사나이
너만큼
식기도
전에
원샷
때리는
터져버리는
아름다워
사랑스러워
그래
너
hey
바로
지금부터
갈
때까지
가볼까
오
-
오빤강남스타일
stream의 단어들에는 5글자 이상인 것이 있다? true

//
Path와 Files를 이용해 강남스타일.txt의 문장들을 List<String> lines에 저장한다. 

lines에서 스트림을 생성한다. 리턴 타입이 boolean인 이유는 최종 처리 메서드
anyMatch() 때문이다. 

flatMap()을 이용해서 문장 -> 단어 형태로 구성된 스트림으로 변경한다. 

distinct()를 통해 스트림에서 중복을 제거한 후 filter()를 이용해 단어의 길이가 
0 이상인 요소들만 스트림에 남긴다. 

peek()을 이용해 현재 스트림의 내용을 출력해서 내용을 확인한다. 

최종 처리 메서드인 anyMatch()에서는 길이가 5를 넘는 단어가 스트림에 
하나라도 있다면 true를 리턴한다. 

----------------------------------------------------
4.2 집계

(1) 기본 집계 함수 
통계를 내는 집계 함수는 count(), sum(), average(), min(), max() 가 있다. 
통계는 숫자를 이용하기 때문에 기본형 스트림인 IntStream, LongStream ,
DoubleStream에서는 모두 사용할수 있지만, Stream에서는 count()와,
min(), max()만 사용할 수 있다. 

ex) 통계를 위한 Stream의 최종 처리 메서드 

메서드명 : 선언부와 설명 

count : long count()
스트림 내 요소의 개수를 리턴한다. 

min() : Optional<T> min(Comparator<? super T> comparator)
Stream에서 comparator에 의거 최소 요소를 Optional 타입으로 리턴한다. 

OptionalP#min()
기본형 스트림에서 요소의 최소값을 리턴한다. 

max() : Optional<T> max(Comparator<? super T> comparator)
Stream에서 comparator에 의거 최대 요소를 Optional 타입으로 리턴한다. 

OptionalP#max()
기본형 스트림에서 요소의 최대값을 리턴한다. 

average() : OptionalDouble average()
기본형 스트림에서 요소들의 평균값을 리턴한다. 

sum() : P# sum()
기본형 스트림에서 요소들의 총 합을 리턴한다. 
P#는 Int, Long, Double 을 나타내고 ,
p* int, long, double 을 나타낸다. 

이 메서드들의 사용 자체는 매우 간단하지만, Stream의 max()와 
min()에서 리턴되는 Optional<T>의 용법은 살펴볼 필요가 있다. 

(2) java.util.Optional
여기서 등장하는 java.util.Optional<T>은 T 타입의 객체가 존재하는지 여부에 
따라 동작하는 래퍼(wrapper) 클래스이다. Optional<T>를 이용하면 
참조하려는 객체가 null인 경우와 그렇지 않은 경우의 처리를 보다 안전하게 
프로그래밍할 수 있다. Optional 을 사용할 때는 값이 null로 없는 경우 대체 값을 
생산(Producer)하고 값이 있을 경우는 그 값을 소비(Consumer)한다. 

Optional 객체를 생성할 때는 Optional에서 제공되는 정적 메서드를 사용한다. 

Optional 생성을 위한 메서드 

메서드명 : 선언부와 설명 

of() : public static <T> Optional<T> of(T value)
value가 null이 아닌 상황에서 이를 래핑하는 Optional을 리턴한다. 
value가 null인 경우 NullPointerException이 발생한다. 

ofNullable() : public static <T> Optional<T> ofNullable( T value)
value 가 null 일 가능성이 있는 상황에서 value을 래핑하는 Optional을 
리턴한다. value가 null인 경우 empty()의 결과를 리턴한다. 

empty() : public static<T> Optional<T> empty()
값이 비어 있는 Optional 객체를 리턴하는데 일반적으로 이 값이 
Optional의 초기값으로 사용된다. 

Optional 객체에서 값을 가져오기 위해서는 get() 메서드를 사용한다. 
get() 메서드는 값이 없을 경우 NullPointerException을 발생시키는데 
Optional의 장점은 이 예외 상황에 대처하는 코드를 작성하는데 있다. 
Optional의 orElse()는 값이 null이 아닌 경우는 값을 리턴하고 값이 null
이어서 NullPointerException이 발생할 때는 대체할 값을 리턴한다. 
유사한 메서드로 orElseGet() 과 orElseThrow()가 제공된다. 

ex) Optional 의 값을 처리하는 메서드 

메서드 명 : 선언부와 설명 

get() : public T get()
Optional의 값을 리턴한다. 만약 null 일 경우 NullPointerException이 
발생한다. 

ifPresent() : public void IfPresent(Consumer <? super T> consumer)
Optional 값이 null 일 아닐 경우 consumer를 통해 값을 소비한다. 

orElse() : public T orElse( T other)
Optional의 값이 null 일 경우 other를 리턴한다. 

orElseGet() : public T orElseGet(Supplier <? extends T> other)
Optional의 값이 null 일 경우 Supplier인 other를 통해 공급받은 값을 
리턴한다. 

orElseThrow : public <X extends Throwable> T orElseThrow(
Supplier<? extends X> exceptionSupplier) throws X 
Optional의 값이 null 일 경우 exceptionSupplier에서 리턴한 예외를 
throws 시킨다. 

다음은 Optional의 사용 예이다. 

ex)

String str = "abc";
Optional<String> optVal = Optional.of(str);
System.out.println(optVal.get());
optVal.ifPresent(val -> System.out.println("optVal: "+val));

Optional<String> nullVal = Optional.ofNullable(null);
System.out.println(nullVal.orElse("널 대체 1"));
System.out.println(nullVal.orElseGet(() -> {
return " 널 대체 2";
}));

또한, Optional 역시 Stream 처럼 filter(), map, flatMap()과 
같은 메서드를 사용할수 있다. 

다음은 Optional<String>의 값이 4글자 이상이면 값을 출력하고 그렇지 
않으면 '4글자 미만'이라고 출력하는 예이다. 

ex)
String ifOver4 = Optional.of("Hello").filter(val -> {
return val.length() >= 4;
}).orElse("4글자 미만");
System.out.println(ifOver4);
이제 집계 함수에서 Optional이 사용되는 예를 살펴보자. 

ex)
package ch16.terminate;

import java.util.Arrays;
import java.util.Optional;
import java.util.Random;
import java.util.stream.IntStream;

public class AggregateTest {

	public static void main(String[] args) {
		IntStream is = new Random().ints(10, 1, 6);
		System.out.println("총합은: " + is.sum());

		String[] strs = { "Hi", "C", "Java", "zoo", "World" };
		Optional<String> max = Arrays.stream(strs).max(String::compareTo);
		max.ifPresent(val -> {
			System.out.println("최대값은: " + val);
		});

		String result = max.filter(val -> {
			return val.matches("[가-힣]{1,}");
		}).orElse("한글 중에는 없다.");
		System.out.println(result);

	}
}
//
총합은: 33
최대값은: zoo
한글 중에는 없다.

//Random 클래스의 ints()를 통해 1~6 까지의 랜덤 정수 10개로 
구성된 IntStream을 얻는다. 

IntStream의 sum()을 이용해 스트림 내 요소들의 총합을 출력한다. 

String [] strs 를 이용해 스트림을 만들고 max()를 이용해 알파벳 순으로 
가장 큰 값을 Optional<String> 타입의 max로 리턴 받는다. 

max에 값이 있다면 해당 값을 출력한다. 

max에 filter() 연산을 추가해서 값이 한글로 구성된 경우는 바로 리턴하지만, 
그렇지 않으면 '한글 중에는 없다'로 대체해서 출력한다. 

(3)사용자 정의 집계함수 
sum(), max(), min()등의 집계 함수가 미리 정해진 통계방식에 의한 집계 
처리라면 reduce()는 사용자 정의 집계 처리가 가능하다. 
reduce()는 함수 이름에서 알수 있듯이 스트림이 가지고 있는 요소를 
줄여가면서 연산한다. 즉 처음 두 요소를 가지고 연산 후 그 결과를 이용해 
다음 요소와 연산을 반복하고 전체 요소와의 연산이 끝나면 비로소 결과를 
리턴한다. 따라서 reduce()는 파라미터로 BinaryOperator를 갖는다. 

ex) 사용자 정의 집계 처리를 위한 Stream의 최종 처리 메서드 
메서드 명 : 선언부와 설명 

reduce() : Optional<T> reduce(BinaryOperator <T> accumulator)
accumulator의 연산을 수행하고 Optional<T> 타입을 반환한다. 

T reduce(T identity, BinaryOperator<T> accumulator)
초기값 identity와 스트림의 연산이 최초로 이뤄진다 
따라서 리턴되는 값은 Optional<T>이 아니라 그냥 T가 된다. 

<U> U reduce(U identity , BiFunction<U,? super T, U> accumulator,
BinaryOperator <U> combiner)
identity와 accumulator를 이용해 연산을 수행하고 병렬 스트림에 의해 
처리된 결과를 combiner를 통해 합한다. 

앞서 살펴본 count()나 sum() 등 통계형 집계함수도 사실은 reduce를 통해서 
구현된 것이다. 다음은 초기값을 0으로 하고 두 요소를 더하는 형태의 
BinaryOperator가 사용된 예이다. 

ex) 
IntStream is = Arrays.stream(new int [] { 1,2,3,4,5});
int sum = is.reduce(0, (a,b) -> a + b);
System.out.println(sum);

----------------------------------------------------
4.3 반복 

forEach() 메서드는 스트림 요소를 순차적으로 소비하는 메서드이다. 
파라미터로 전달 되는 Consumer<T>에 요소를 활용하는 코드를 작성한다. 

ex) 반복을 위한 Stream의 최종 처리 메서드 

메서드 명 : 선언부와 설명 
forEach() : void forEach(Consumer <? super T> action)
스트림의 각 요소에 대해 action을 수행한다. 

다음 예는 문자열로 구성된 스트림을 정렬 후 문자열과 길이를 
출력하는 예이다. 

ex) 
String [] strs = { "Hi", "C", "Java","Zoo","World"};
Stream<String> fromArr = Arrays.stream(Strs);
fromArr.sorted().forEach(data -> {
System.out.println(data + " : 길이 : "+ data.length());
});

----------------------------------------------------
4.4 조사 

findFirst()와 findAny()는 각각 스트림의 첫 번째 요소 또는 위치와 관계없이 
포함 여부를 조사하는 최종 처리 메서드이다. 

ex) 요소 조사를 위한 Stream의 최종 처리 메서드 

메서드명 : 선언부와설명

findFirst() : Optional<T> findFirst()
스트림의 맨 처음 요소 또는 null을 갖는 Optional 객체를 리턴한다. 

findAny() : Optional<T> findAny()
스트림에 있는 어떤 요소 또는 null을 갖는 Optional 객체를 리턴한다. 
일반 스트림에서는 findFirst()와 결과가 같가지만 병렬 스트림에서는 
findAny()를 써야 한다. 

ex) 
String [] strs = { "Hi", "C", "Java","Zoo","World"};
Stream<String> fromArr = Arrays.stream(Strs);
Optional<String> first = fromArr.findAny();
System.out.println(first.orElse("none"));

----------------------------------------------------
4.5 수집 

collect()는 스트림의 요소들을 수집하는 최종 처리 메서드로 가장 유용하면서 
활용도가 높고 그만큼 복잡한 메서드이다. collect()의 주요 목적은 필요한 요소만 
골라서 새로운 컬렉션을 구성하는데 있다. 기본 스트림에서 요소를 고르기 때문에 
reduce()와 유사하게 동작한다. collect()를 위해서 스트림에서 필요한 요소를 
골라내는 방법을 정의할 필요가 있는데 이 역할은 Collector 타입의 객체가 담당한다. 

ex) 수집 처리를 위한 Stream의 최종 처리 메서드 

메서드 명 : 선언부와 설명 

collect() : <R,A> R collect(Collector <? super T, A, R> collector)
Collector 를 이용해서 스트림의 요소를 새로운 컬렉션 R에 담아 리턴한다. 

<R> R collect(Supplier<R> supplier, BiConsumer<R, ? super T> accumulator,
BiConsumer<R,R> combiner)
supplier를 통해서 생성된 컨테이너 R에 accumulator를 이용해 T 값을 저장한다. 
병렬처리 스트림에서 호출되는 경우만 combiner가 스레드별로 생성된 컨테이너 
R을 통합해서 최종 컨테이너 객체를 완성한다. 

Collector는 인터페이스로 타입 파라미터가 3개 선언돼 있는데 collect()의 
동작을 이해 하기에 아주 중요한 요소들이다. 

T : A 가 저장할 입력 값의 타입이다. 
A : T를 입력받아서 처리하는 연산을 정의한다. 
R : A에서 리턴된 값들이 저장되는 컬렉션으로 최종 결과값이다. 

즉, T를 A가 받아서 R에 저장하는 형태이다. 

(1) Collectors의 정적 메서드 활용 

Collector 객체는 직접 생성할수도 있지만 대부분 Collectors가 제공하는 정적 
메서드를 사용한다. 먼저 정적 메서드 기반으로 Collector를 사용하는 방법을 
알아보자. 

ex) Collector를 생성하기 위한 Collectros 의 정적 메서드 

메서드 명 : 선언부와설명

toList() : public static <T> Collector< T, ?, List<T>> toList()
T 타입의 스트림 요소를 List<T>에 저장하는 Collector를 리턴한다. 

toSet() : public static <T> Collector<T, ?, Set<T>> Collector<T,?,C>
toCollection(Supplier<C> collectionFactory)
T 타입의 스트림 요소를 collectionFactory가 제공한 Collection에 
저장하는 Collector를 리턴한다. 

toMap() : public static <T, K, U> Collection <T, ?, Map<K,U>>
toMap(Function<? super T, ? extends K> keyMapper, Function<? super T, 
? extends U> valueMapper)
T 타입의 스트림 요소를 K와 U로 변환해서 K를 key, U를 value로 하는 
Map에 저장하는 Collector를 리턴한다. 

public static <T, K, U> Collector<T, ?, Map<K,U>>
toMap(Function <? super T, ? extends K> keyMapper,
Function<? super T, ? extends U> valueMapper, BinaryOperator<U> mergeFunction)
T 타입의 스트림 요소를 K와 U로 변환해서 K를 key, U를 value로 하는 
Map에 저장하는 Collector를 리턴한다. 이 때 key 가 중복된다면 
mergeFunction에서 사용할 key를 선택한다. 

public static <T, K, U, M extends Map<K, U>>
Collector<T, ?, M > toMap(
Function<? super T, ? extends K> keyMapper,
Function<? super T, ? extends U> valueMapper,
BinaryOperator<U> mergeFunction, Supplier<M> mapSupplier)

T 타입의 스트림 요소를 K와 U로 변환해서 K를 key, U를 value로 
하는 Map에 저장하는 Collector를 리턴 한다. 이 때 key가 중복된다면 
mergeFunction에서 사용할 key를 선택한다. 최종적으로 리턴될 
Map의 타입은 mapSupplier의 리턴 값을 사용한다. 

toConcurrentMap() : public static <T, K, U> Collector <T, ?, ConcurrentMap<K,U>>
toConcurrentMap(Function<? super T, ? extends K> keyMapper,
Function<? super T, ? extens U> valueMapper)
T 타입의 스트림 요소를 K와 U로 변환해서 K를 키, U를 value로 하는 
ConcurrentMap에 저장하는 Collector를 리턴한다. 

표를 보면 리턴 타입인 Collector의 두번째 타입 파라미터가 모두 '?'로 
되어 있다. 이는 T를 R에 저장하는 방식을 이미 Collector가 알고 있어서 
A가 필요없기 때문이다. 

collect()를 이용해 스트림의 요소 중 filter()를 통과한 요소들만 List나 Set,
Map으로 이동하는 예를 살펴보자. 

ex)
package ch16.terminate;

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.stream.Collectors;

public class CollectTest {

	public static void main(String[] args) {
		String[] strs = { "Hi", "C", "Java", "Zoo", "World" };

		List<String> list = Arrays.stream(strs).filter(str -> {
			return str.length() >= 3;
		}).collect(Collectors.toList());
		System.out.println(list.getClass().getName() + " : " + list);

		Set<String> set = Arrays.stream(strs).filter(str -> {
			return str.length() >= 3;
		}).collect(Collectors.toSet());
		System.out.println(set.getClass().getName() + " : " + set);

		Map<String, Integer> map = Arrays.stream(strs).filter(str -> {
			return str.length() >= 3;
		}).collect(Collectors.toMap(str -> str, str -> str.length()));
		System.out.println(map.getClass().getName() + " : " + map);

		Map<String, Integer> map2 = Arrays.stream(strs).filter(str -> {
			return str.length() >= 3;
		}).collect(Collectors.toMap(str -> str, 
									str -> str.length(), 
									(oldVal, newVal) -> newVal, 
									TreeMap::new));
		System.out.println(map2.getClass().getName());//java.util.TreeMap
	}
}
/*
List<String> list2 = Arrays.stream(strs).filter(str -> {
	return str.length() >= 3;
}).collect(Collectors.toCollection(LinkedList::new));
System.out.println(list2.getClass().getName());// java.util.LinkedList
*/
//
java.util.ArrayList : [Java, Zoo, World]
java.util.HashSet : [Java, Zoo, World]
java.util.HashMap : {Java=4, Zoo=3, World=5}
java.util.TreeMap

665 26/42

스트림에서  filter()를 이용해 문자열의 길이가 3이상인 요소만 고른 후 
collect()메서드를 이용해 List로 리턴받는다. 이 때 Collector로
Collectors.toList()를 이용한다. 결과로 받은 List 는 ArrayList 타입이다. 

위와 동일한 상황에서 Collector로 Collectors.toSet()을 이용해서 Set 형태로 리턴
받는다. 기본적으로 HashSet 타입이 리턴된다. 

Collector로 Collector.toMap() 메서드를 이용해서 Map 형태로 리턴 받는다. 
toMap()의 첫번째 파라미터 Function은 String을 받아서 그대로 리턴하는데 
이 값은 결과 Map의 key로 사용된다. 두 번째 파라미터 Function은 String을 
받아서 그 문자열의 길이를 리턴하는데 이값은 결과 키값의 value로 사용된다. 
결과로 리턴되는 Map 타입은 HashMap이다. 

collect() 가 기본적으로 리턴하는 ArrayList 나 HashSet 을 사용하지 않고 
다른 Collection을 사용하려는 경우는 Collector로 Collections.toCollection()
메서드 결과를 사용한다. 

다음의 코드는 ArrayList를 사용하는 대시 LinkedList를 사용하는 예이다. 

ex)
List<String> list2 = Arrays.stream(strs).filter(str -> {
return str.length() >= 3;
}).collect(Collectors.toCollection(LinkedList::new));
System.out.println(list2.getClass().getName()); // java.util.LinkedList

Map 계열에서는 표의 toMap() 메서드 중 세번째 toMap() 메서드를 사용하고 
mapSupplier 파라미터에서 실제 사용할 Map 타입을 리턴하면된다. 
toMap()의 세번째 파라미터 즉 mergeFunction인 BinaryOperator는 key에 
동일한 값이 들어오는 경우 처리 방침을 정한다. 여기서는 새로운 newVal
로 기존 값을 대체하도록 작성되었다. 네번째 파라미터 즉 
mapSupplier 인 Supplier에서는 TreeMap 객체를 리턴하도록 작성되었다. 
결과 collect()의 리턴 타입은 TreeMap이 되었다. 

ex)
Map<String, Integer> map2 = Arrays.stream(strs).filter(str -> {
return str.length() >=3;
}).collect(Collectors.toMap(str -> str. str -> str.length(),
(oldVal,newVal) -> newVal, TreeMap::new)
);
System.out.println(map2.getClass().getName()); //java.util.TreeMap

666 27/42

(2) 집계를 위한 Collector 
Collectors에는 앞서 살펴봤던 집계 처리를 위한 Collector를 반환하는 
메서드들도 제공한다. 

ex) 집계 기능의 Collector 를 생성하기 위한 Collectors 의 정적 메서드 

메서등 명 : 선언부와설명

counting() : public static <T> Collector<T,?,Long> counting()
스트림 요소의 개수를 Long 값으로 리턴하는 Collector를 리턴한다. 

summingP#() : 
public static <T> Collector<T, ?, W> summingP#(ToP#Function<? super T> mapper)
스트림 요소의 합을 W로 리턴하는 Collector를 리턴한다. 

averagingP#() :
public static <T> Collector <T, ?, Double> averagingP#(ToP#Function<? super T> mapper)
스트림 요소의 평균을 Double로 리턴하는 Collector를 리턴한다. 

maxBy() :
public static <T> Collector<T, ?, Optional<T>> maxBy(Comparator< ? super T> comparator)
comparator에 의해 스트림 요소의 최대값을 Optional로 리턴하는 Collector를 리턴한다. 

minBy() :
public static <T> Collector<T, ?, Optional<T>> minBy(Comparator< ? super T> comparator)
comparator에 의해 스트림 요소의 최대값을 Optional로 리턴하는 Collector를 리턴한다. 

reducing() :
public static <T> Collector <T, ? , Optional<T>> reducing(BinaryOperator<T> op)
op 에 의한 리듀스 연산의 결과를 Optional로 리턴하는 Collector를 리턴한다. 

P#는 Int, Long, Double 을 나타내며 W는 Integer, Long, Double 을 나타낸다. 

중간 처리에서 있던 기능을 구지 최종 처리에서 다시 지원하는 것이 매우 불필요해 보이지만 
이 메서드들은 뒤에 나오는 그룹화와 분리의 구현에 아주 주용한 역할을 한다. 

앞서 한번씩 다루었던 개념의 메서드들이기 때문에 바로 사용 예를 살펴보자. 

ex)
package ch16.terminate;

import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class AggregateCollectorTest {

	public static void main(String[] args) {
		long cnt = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
				.collect(Collectors.counting());
		System.out.println("counting: " + cnt);

		long sum = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
				.collect(Collectors.summingInt(n -> {
					return n;
				}));
		System.out.println("summing: " + sum);

		double avg = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
				.collect(Collectors.averagingInt(n -> {
					return n;
				}));
		System.out.println("avg: " + avg);

		Optional<Integer> maxBy = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
				.collect(Collectors.maxBy((a, b) -> {
					return a == b ? 0 : (a > b ? 1 : -1);
				}));
		maxBy.ifPresent(val -> {
			System.out.println("maxBy: " + val);
		});

		Optional<Integer> minBy = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
				.collect(Collectors.maxBy((a, b) -> {
					return a == b ? 0 : (a > b ? -1 : 1);
				}));
		minBy.ifPresent(val -> {
			System.out.println("minBy: " + val);
		});

		Optional<Integer> reduce = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
				.collect(Collectors.reducing((a, b) -> {
					return a * b;
				}));
		reduce.ifPresent(val -> {
			System.out.println("reduce: " + val);
		});
	}
}
//
counting: 10
summing: 55
avg: 5.5
maxBy: 10
minBy: 1
reduce: 3628800

(3) 사용자 정의 Collector 활용 
Collectors 의 메서드를 이용해서 Collector를 얻어서 사용하다 보면 
지정된 컬렉션 클래스들만을 컨테이너로 사용할 수 있다. 
이번에는 사용자 정의 컨테이너를 사용하는 Collector를 직접 만들어보자. 

먼저, 사용자 정의 컨테이너를 작성한다. 이 컨테이너는 Properties를 내장하고 
있어 필요할 때 파일로 내용을 쉽게 출력 할수 있다. 

ex)
package ch16.terminate;

import java.io.FileWriter;
import java.io.IOException;
import java.util.Properties;

public class MyContainer {
	Properties prop = new Properties();

	public void accumulate(String element) {
		prop.setProperty(element, element.length() + "");
	}

	public void combine(MyContainer other) {
		prop.putAll(other.prop);
	}

	public void saveToFile() {
		try (FileWriter writer = new FileWriter("c:/Temp/fromStream.txt")) {
			prop.store(writer, "from stream");
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}
// 자료가 저장될 Properties 타입의 prop을 선언한다. 

String 을 파라미터로 받아서 prop에 저장한다. 
이때 String을 key 로 하고 String 의 길이를 value로 한다. 

멀티스레드로 동작할 때 다른 스레드가 사용한 MyContainer의 prop 내용을 
통째로 추가한다. 

prop의 내용을 파일로 출력한다. 

이제 MyContainer를 사용하는 Connector를 구성할 차례인데 Stream 이 가지는 두 번째 
connector() 메서드를 사용한다. 이를 위해 supplier , accumulator, combiner가 
필요하다. 

supplier는 connector() 결과가 담길 컨테이너를 공급하는 Supplier이다. 
Supplier를 통해 새로운 MyContainer 객체를 리턴하면 된다. 

ex)
Supplier<MyContainer> con = () -> new MyContainer();

accumulator는 컨테이너에 데이터를 저장할 로직을 BiConsumer 를 통해 
작성한다. BiConsumer에는 컨테이너와 데이터가 파라미터로 전달된다. 
NyContainer에 작성한 accumulate() 메서드를 사용하자. 

ex)
BiConsumer<MyContainer, String> accumulator = (container, element) -> {
container.accumulate(element);};

combiner는 병렬 스트림에서만 의미 있으며 여러 개의 스레드에 의해 사용되던 
MyContainer의 데이터를 하나로 모으는 로직을 BiConsumer로 작성한다. 
BiConsumer에는 두개의 컨테이너 객체가 파라미터로 전달된다. 
MyContainer의 combine() 메서드를 이용하자. 

ex)
BiConsumer<MyContainer, MyContainer> combiner = (prop1, prop2) -> {
prop1.combine(prop2);};

다음 예는 스트림의 내용을 사용자 정의 컨테이너에 수집하는 방법을 보여준다. 

ex)
package ch16.terminate;

import java.util.Arrays;
import java.util.function.BiConsumer;
import java.util.function.Supplier;

public class CustomContainerTest {

	public static void main(String[] args) {
		String[] strs = { "Hi", "C", "Java", "Zoo", "World" };

		Supplier<MyContainer> supplier = () -> new MyContainer();
		
		BiConsumer<MyContainer, String> accumulator = (container, element) -> {
			container.accumulate(element);
		};
		BiConsumer<MyContainer, MyContainer> combiner = (prop1, prop2) -> {
			prop1.combine(prop2);
		};

		MyContainer custom = Arrays.stream(strs).filter(str -> {
			return str.length() >= 3;
		}).collect(supplier, accumulator, combiner);
		custom.saveToFile();
	}
}
// C:\Temp 에 fromStream.txt 에 내용이 저장되었는지 확인한다. 

collect() 메서드의 파라미터인 supplier, accumulator, combine을 생성한다. 

스트림에서 filter()를 통과한 요소들을 collector() 메서드로 모은다. 이 때 
리턴되는 컨테이너는 MyContainer 타입의 custom이다. 
custom의 saveToFile()을 호출해서 파일에 스트림 내용을 저장한다. 

(4) 그룹화(grouping) 와 분리(partitioning )
Collectors에는 스트림 자료 활용에 도움이 되는 다양한 Collector를 리턴하는 메서드들이
제공된다. 그 중 groupingBy()와 partitioningBy()는 가장 활용도가 높다고 할수 있다. 

Collectors의 groupingBy() 와 partitioningBy() 

메서드명 : 선언부와 설명 

groupingBy() : public static <T,K> Collector <T, ?, Map<K, List<T>>>
groupingBy(Function<? super T, ? extends K> classifier)
classifier를 key 값으로, 그에 해당하는 값의 목록을 
value로 갖는 Map으로 스트림을 수집하는 Collector를 반환한다. 
값의 목록 타입은 List이다. 

partitioningBy() : public static <T> Collector<T,?, Map<Boolean, List<T>>>
partitioningBy(Predicate<? super T> predicate)
predicate의 결과를 key로 , 그에 해당하는 값의 목록을 value로 갖는 
Map으로 스트림을 수집하는 Collector를 반환한다. 값의 목록 타입은 
List이다. 

groupingBy() 는 스트림 요소를 특정 기준으로 그룹화 한다. partitioningBy()
는 스트림의 요소를 특정 조건에 일치하는 그룹과 그렇지 찮은 그룹으로 분리한다.
예를 들어 스트림에 전 세계의 도시가 있다고 생각해보자. 

서울 : 대한민국, 광주: 대한민국, 부산 : 대한민국, 뉴욕: 미국, 하와이:미국 
베이징: 중국 

이 도시들을 국가별로 그룹화해보자. 

대한민국 : [서울, 광주, 부산]
미국 : [뉴욕, 하와이]
중국: [베이징]

결과는 국가명이 key이고 소속도시의 목록이 value인 Map<String, List<String>>
구조가 된다. 
이 도시들을 다시 아시아에 속한 도시와 그렇지 않은 도시로 분리해보자. 

true : [서울, 광주, 부산, 베이징]
false : [뉴욕, 하와이]

결과는 true/ false가 key 이고 소속 도시의 목록이 value인 
Map<Boolean, List<String>> 구조가 된다. 

ex) groupingBy()와 partitioningBy() 의 결과 
원본 스트림 
서울 : 대한민국, 광주: 대한민국, 부산 : 대한민국, 뉴욕: 미국, 하와이:미국 
베이징: 중국 

groupingBy()
대한민국 : [서울, 광주, 부산]
미국 : [뉴욕, 하와이]
중국: [베이징]

partitioningBy
아시아?
true:[서울,광주,부산,베이징]
false:[하와이, 뉴욕, 시카고]

그룹화와 분리가 어떤 상황에서 필요한지 알아보자. 

java.util.Locale 클래스는 언어코드_국가코드로 자바에서 사용하는 로케일 정보를 
관리한다. 예를 들어 대한민국은 ko_KR, 미국은 en_US와 
es_US, 중국은 zh_CN을 사용한다. 
홍콩은 zh_HK를 사용한다. 미국의 경우 처럼 한 나라에 두개의 언어가 있기도 하고 
중국이나 홍콩의 경우 처럼 여러 나라가 같은 언어를 사용하기도 한다. 

Locale 클래스에는 getAvailableLocales()를 통해 Locale [] 타입으로 모든 
로케일 정보를 반환한다.  이정보를 [국가-언어]의 구조로 Map에 저장해보자. 

ex)
Locale[] locales = Locale.getAvailableLocales();
Map<String, String> langNames = Arrays.stream(locales)
.filter(locate -> {
return locate.getDisplayCountry().trim().length() > 0;
})
.collect(
Collectors.toMap(
locale -> {   //keyMapper : key 구성 
retrun locale.getDisplayCountry() + "("+ locale.getCountry() + ")"; 
},
locale -> {  // valueMapper: value 구성 
return locale.getDisplayLanguage()+"("+locate.getLanguage() + ")";
},
(oldOne, newOne) -> { //mergeFunction: 중복 처리 
return newOne;
}));
System.out.println(langNames);

실행 결과는 {라트비아(LV)=라트비아어(레트어)(lv), 이집트(EG)=아랍어(ar),
벨라루스(BY)=벨로루시어(be),...}의 형식으로 로케일 정보가 출력된다. 
하지만 그 중에서 중국어가 사용되는 나라를 출력하거나 비영어권의 국가를 
찾는 일은 또다시 반복이나 새로운 스트림 작업을 거쳐야 한다. 

이 때 그룹화와 분리 기능을 사용하면 간단히 문제를 해결할수 있다. 

다음은 Locale 을 이용한 그룹화와 분리의 예이다. 

ex)
package ch16.terminate;

import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.stream.Collectors;

public class GroupingTest {

	public static void main(String[] args) {
		Locale[] locales = Locale.getAvailableLocales();

		Map<String, List<Locale>> langNames2 = Arrays.stream(locales).filter(locale -> {
			return locale.getDisplayCountry().trim().length() > 0;
		}).collect(Collectors.groupingBy(locale -> {
			return locale.getLanguage();
		}));
		System.out.println("한국어가 사용되는 Locale는?");
		langNames2.get("ko").stream().forEach(locale -> {
			System.out.print("["+locale.getDisplayCountry()+"]");
		});

		Map<Boolean, List<Locale>> langNames3 = Arrays.stream(locales).filter(locale -> {
			return locale.getDisplayCountry().trim().length() > 0;
		}).collect(Collectors.partitioningBy(locale -> {
			return locale.getLanguage().equals("ko");
		}));
		System.out.println("\n비 한국어 Locale의 수는?");
		System.out.println(langNames3.get(false).stream().count()+"개");
	}
}
/*
Locale[] locales = Locale.getAvailableLocales();

Map<String, String> langNames = Arrays.stream(locales)
		.filter(locale -> {
			return locale.getDisplayCountry().trim().length() > 0;
		})
		.collect(
				Collectors.toMap(
						locale -> {
							return locale.getDisplayCountry() + "(" + locale.getCountry() + ")";
						},
						locale -> {
							return locale.getDisplayLanguage() + "(" + locale.getLanguage() + ")";
						},
						(oldOne, newOne) -> {
							return newOne;
						}));
System.out.println(langNames);
 */
 //
한국어가 사용되는 Locale는?
[북한][대한민국]
비 한국어 Locale의 수는?
524개

//collect() 메서드에 groupingBy() 를 이용한 Collector를 전달한다. 
이 Collector는 locale.getLanguage() 를 기준으로 Locale의 목록을 구룹화한다. 

그룹화된 자료에서 키에 해당하는 언어 정보로 해당 Locale 의 국가명을 출력한다. 

collect()메서드에 partitioningBy()를 이용한 Collector를 전달한다. 
이 Collector는 Locale의 언어가 "ko"인지 아닌지를 기준으로 Locale의 목록을 분리한다. 

분리된 자료에서 false로 등록된 한국어가 아닌 Locale의 개수를 출력 한다. 

(5)다운스트림 컬레터(Downstream Collector)활용 
다운스트림 컬렉터는 주 컬렉터가 만들어낸 결과를 다시 수집하는 일종의 보조 
컬렉터이다. 앞서 학습한 groupingBy() 와 partitioningBy() 메서드는 두 번째 파라미터로 
또 다른 Collectros를 받을 수 있는데 이것을 다운스트림 컬렉터라고 부른다. 

ex) Collectors의 groupingBy()와 partitioningBy()에 다운스트림 컬렉터 적용 

메서드명 : 선언부와설명

groupingBy() :
public static <T, K, A, D> Collector<T, ?, Map<K,D>>
groupingBy(Function<? super T, ? extends K> classifier, Collector< ? super T, A, D>
downStream)
classifier를 key 값으로 , 그에 해당하는 값의 목록을 value로 갖는 Map으로 
스트림을 수집하는 Collector를 반환한다. 값의 목록 타입은 
Collector 인 downStream의 컨테이너 입니다. 

partitioningBy():
Collectors<T,?,Map<Boolean,D>>
partitioningBy(Predicate<? super T> predicate, Collector<? super T, A, D>
downStream)
predicate의 결과를 key로, 그에 해당하는 값의 목록을 value로 갖는 
Map으로 스트림을 수집하는 Collector를 반환한다. 값의 목록 타입은 
Collector인 downStream의 컨테이너 타입이다. 

다운스트림 컬렉터가 하는 역할을 생각해보자. 

앞선 예제 ch16.terminate.GroupingTest.java에서 그룹화의 결과로 언어별 사용 국가를 
Map<String, List<Locale>> 구조로 리턴받아서 사용했다. 
다운 스트림의 컬렉터는 List<Locale>에 대한 부분을 변경한다. 

예를 들어 List 구조가 아닌 Set 형태로 받고 싶다면 다음과 같이 toSet()을 이용할수 있다. 

ex)
Map<String, Set<Locale>> toSet = Arrays.stream(locales).filter(locale) ->
{ return locale.getDisplayCountry().trim().length() > 0;
}).collect(Collectors.groupingBy(locale -> {
return locale.getLanguage();
}, Collectors.toSet()

언어별로 사용 국가 목록이 아닌 국가의 수를 알아보자. 
List가 아닌 숫자를 리턴해주는 collectros 가 필요하다. 
앞서 집계를 위한 Collector에서 봤던 counting()을 써보자. 

ex)
Map<String,Long> counting = Arrays.stream(locales).filter(locale) ->
{ return locale.getDisplayCountry().trim().length() > 0;
}).collect(Collectors.groupingBy(locale -> {
return locale.getLanguage();
}, Collectors.counting()
));
System.out.println(counting)
// {de=5, no=2, hi=1, be=1,...)}

MaxBy()를 이용하면 최대값을 구하는데 이를 통해 국가명이 가장 큰 
(알파벳 뒤에 있는 Locale 만 남겨보자.

ex)
Map<Object,Optional<Locale>> maxLocale = Arrays.stream(locales).filter(locale) ->
{ return locale.getDisplayCountry().trim().length() > 0;
}).collect(Collectors.groupingBy(locale -> {
return locale.getLanguage();
}, Collectors.maxBy(
(l1,l2)->{
return l1.getDisplayCountry.compareTo(l2.getDisplayCountry());
})
));
System.out.println(maxlocale)
// {de=Optional[de_AT], no=Optional[no_NO_NY],...)}

마지막으로 mapping()을 이용해서 Locale이 아닌 Locale의 
displayCountry 로 값을 바꿔보자. 

ex)
Map<String,Optional<String>>mapping = Arrays.stream(locales).filter(locale) ->
{ return locale.getDisplayCountry().trim().length() > 0;
}).collect(Collectors.groupingBy(locale -> {
return locale.getLanguage();
}, Collectors.mapping(l -> l.getDisplayCountry(),
Collectors.maxBy((n1,n2) ->{
return n1.compareTo(n2)* -1;
})
)));
System.out.println(mapping);
// {de=Optional[그리스], no=Optional[노르웨이],hi=Optional[인도]...)}

----------------------------------------------------
5. 병렬 스트림

5.1 병렬 처리의 정의와 병렬 스트림 생성 

병렬(Parallel)과 병행(Concurrent) 은 둘다 멀티스레드와 연관된 단어라는 공통점이 있지만,
서로 다른 단어다. 병행 작업은 하나의 CPU 코어에서 멀티스레드가 번갈아 가며 
수행되는 것을 말하고 병렬이란 멀티 코어 CPU 환경에서 코어 개수 만큼의  스레드들이
각각의 코어에서 정말 동시에 작업이 이뤄지는 것을 말한다. 

676 37/42

자바의 스트림은 병렬 스트림을 지원해서 대량의 벌크 데이터에 대한 작업을 손쉽게 
해준다. 즉 병렬 스트림을 사용하면 별도의 스레드를 만들고 관리하지 않아도 자동으로 
병렬 작업이 일어난다. 

(1) 병렬 스트림 생성 
컬렉션에서 병렬 스트림을 생성할 때는 stream() 메서드 대신 parallelStream() 
메서드를 사용한다. 일부 parallelStream()을 지원하지 않는 경우는 순차 스트림을 만든 후 
parallel() 메서드를 이용해 병렬 스트림으로 변경하면 된다. 

ex)
List<String> strList = Arrays.asList(strs);
Stream<String> pStream2 = strList.parallelStream();

String [] strs = { "Hello", "Java","World"};
Stream<String> pStream = Arrays.stream(strs).parallel();

5.2 병렬 스트림 사용. 

병렬 스트림을 사용하면 최종 처리 메서드가 실행될 때 중간 처리 연산은 모두 
병렬화 된다. 이때 ForkJoin 스레드 풀의 스레드를 이용해서 중간 처리 연산을 
수행하고 이 스레드 들이 모두 완료되면 최종 처리가 동작한다. 

다음 예는 문자열의 배열을 순차적 스트림과 병렬 스트림을 이용해서 중간 
처리와 최종 처리를 실행한 것이다. 

ex)
package ch16.parallel;

import java.util.Arrays;
import java.util.function.Predicate;
import java.util.stream.Stream;

public class SequencialVsParallelTest {

	public static void main(String[] args) {
		String[] strs = { "Hello", "Java", "World" };
		Predicate<String> pred = str -> {
			System.out.println(Thread.currentThread().getName() + ":" + str);
			try {
				Thread.sleep(10);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			return str.length() >= 4;
		};

		Stream<String> sStream = Arrays.stream(strs);
		long cnt1 = sStream.filter(pred).count();
		System.out.println("순차: " + cnt1);

		Stream<String> pStream = Arrays.stream(strs).parallel();
		long cnt2 = pStream.filter(pred).count();
		System.out.println("병렬: " + cnt2);
	}
}
//
main:Hello
main:Java
main:World
순차: 3
main:Java
ForkJoinPool.commonPool-worker-5:World
ForkJoinPool.commonPool-worker-3:Hello
병렬: 3

//스트림 중간 연산에 사용될 Predicate를 생성한다. 구현부에는 실행 스레드의 
이름과 처리 중인 데이터를 출력하고 문자열의 길이가 4이상인지를 리턴한다. 

stream()을 이용해 순차 스트림을 만들고 filter()와 count() 연산을 수행한다. 
출력 결과 Hello, Java, World 가 순서대로 처리 되었으며 실행 스레드는 
main 임을 알수 있다. 

parallel()을 이용해 병렬 스트림을 만들고 filter()와 count() 연산을 수행한다. 
출력 결과 데이터의 순서대로 처리되지 않았으며 main 스레드와 함께 
ForkJoinPool의 스레드들이 동작함을 확인할수 있다. 

이처럼 병렬 스트림을 사용하면 스레드 관련된 코드 한 줄 없이 손쉽게 병렬 작업을 
처리 할수 있다. 

collect() 메서드는 스트림의 요소들을 다른 컬렉션으로 옮겨 담는 역할을 수행하는 
최종 처리 메서드이다. 만약 병렬 스트림에서 이 collect ()가 수행된다면 여러 스레드에서 
중간 처리한 내용을 합치는 과정이 필요하다. 
이것을 결합자(combiner)라고 한다. 

ch16.terminate.CustomContainerTest.java 예제를 통해 사용자 정의 Collector를 
만들었는데 이때 사용된 3번째 파라미터가 combine이다. 기존의 예제는 순차 스트림을 
이용했기 때문에 결합자가 무의미 했으며 병렬 스트림으로 변경 후 실행하면 비로소 
결합자가 동작한다. 

ex)

Supplier<MyContainer> supplier = () -> new MyContainer();

BiConsumer<MyContainer, String> accumulator = (container, element) ->{
container.accumulate(element);
};
BiConsumer<MyContainer, MyContainer> combiner = (prop1, prop2) ->
{prop1.combine(prop2);
};

MyContainer custom = Arrays.stream(strs).parallel().filter(Str -> {
return str.length() >=3;
}).collect(supplier, accumulator, combine);

----------------------------------------------------
5.3 병렬 스트림 사용 시 주의점 

(1) 공유 데이터 문제 
병렬 스트림을 사용할 때 가장 주의 할점은 공유 데이터 문제이다. 
스레드에 대한 언급이 전혀 없기 때문에 병렬 스트림이 멀티스레드로 동작한다는 점을 
간과하고 공유 데이터를 중간 처리 메서드에서 사용하다 보면 데이터에 대한 신뢰도가 
깨질수 있다. 

ex)
package ch16.parallel;

import java.util.HashMap;
import java.util.Map;
import java.util.stream.IntStream;

public class ParallelProblem {
	private static void testCount(String type, IntStream ints) {
		Map<String, Integer> dataMap = new HashMap<>();
		dataMap.put("counter", 0);
		int sum = ints.filter(num -> {
			int i = dataMap.get("counter");
			dataMap.put("counter", i + 1);
			return num % 2 == 0;
		}).sum();
		System.out.println(type + "- 합:" + sum + ", 카운터: " + dataMap.get("counter"));
	}

	public static void main(String[] args) {
		testCount("순차", IntStream.range(0, 1000));
		testCount("병렬", IntStream.range(0, 1000).parallel());
	}
}
//
순차- 합:249500, 카운터: 1000
병렬- 합:249500, 카운터: 680 //실행시 때론 카운터 값이 다름

카운트 정보를 관리하기 위해 Map 타입의 dataMap 을 선언한다. 
이 객체는 멀티스레드 공유 객체로 사용된다. 

스트림에 중간 처리 연산 filter()와 최종 처리 연산 sum()을 적용시킨다. 
중간 처리에서는 dataMap에서 counter를 가져오는 부분과 counter를 
증가시켜 설정하는 부분이 있다. 

0~999로 구성된 순차 스트림을 이용해 testCount()를 호출한다. 
실행 결과 합과 카운터가 정확히 출력된다. 

0~999로 구성된 병렬 스트림을 이용해 testCount()를 호출한다. 
실행 결과 합은 정확하나  카운터 부정확하다. 

(2) 성능이슈 
성능은 문제까지는 아니지만, 병렬 스트림이 언제나 순차 스트림보다 
빠르지는 않다는 점을 기억해 두자. 병렬 처리는 내부적으로 스레드 풀을 생성하고 
스레드를 만들어서  동작 시키는 추가 비용이 발생한다. 
따라서 컬렉션의 요소 수가 적고 처리 과정에는 걸리는 시간이 짧다면 
오히려 순차 스트림이 빠를수 있다. 

----------------------------------------------------


------------------------------------------------------
[자바 커피 정리]

14 장  JDBC (Java DataBase Connectivity)

JDBC는 자바 언어에서 데이터베이스에 접근 할수 있는 프로그래밍 
 API이다. SQL*PLUS 툴을 이용해서 SQL 문을 요청 했던 것처럼 자바 언어에서 
 JDBC 를 이용해서 SQL문을 데이터 베이스에 요청 할수 있다. 
 
 1.1 JDBC  실행 전 고려사항 
 
 다음은 JDBC를 사용하기 위해서 반드시 고려해야 할 사항이다. 
 
(1) 데이터베이스 정보 확인 
데이터베이스가 설치된 IP 정보 및 설정된 데이터베이스명을 반드시 알아야 한다. 
다음은 DBA로 접속하여 설정된 데이터베이스명을 확인하는 방법이다.

ex)
SQL > show paramerter db_name;

ex) Linux  나
SQL> show parameter db_name
NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
db_name                              string      orcl

(2)  오라클 데이터베이스의 2가지 실행 여부 확인 
윈도우즈 버전. 
제어판 - 관리도구 - 서비스 에서 
ex)
1)OracleOraDb11g_home1TNSListener
2)OracleServiceORCL 
확인. 

(3) 오라클 드라이버를 클래스 패스에 설정 
JDBC 는 대부분이 인터페이스로 되어 있으며 이 인터페이스를  구현한 
클래스 파일들의 묶음을 드라이버(  driver)라고 한다. 
JDBC는 자바에서 제공하고, 드라이버는 데이터베이스를 만드는 회사(벤더)에서 
제공한다. 오라클에서 만든 드라이버를 '오라클 드라이버'라고 한다. 
 
자바에서 서로 다른 데이터베이스를 접속하기 위한 일관된 방식을 위해서 
인터페이스로 만들고 각 벤더에서는 실제 접속 방법을 구현한 클래스 파일을 
제공하는 형태이다. 따라서 벤더에서 제공한 데이터베이스의 드라이버를 
반드시 사용해야 하기 때문에, 이들 드라이버 파일이 클래스 패스에 설정 
되어 있어야한다. 
 
오라클 드라이버는 오라클 데이터베이스를 설치하면 다음 경로에 자동
생성된다. 
윈도우즈 
ex) 11.2.0 경우 
C:\app\사용자명\product\11.2.0\dbhome_1\jdbc\lib 
 
리눅스
ex)  12.2.0 설치 경로에 따라 조금씩 다름. 
/opt/oracle12/app/product/12.2.0/dbhome_1/jdbc/lib
 
다음과 같이 lib 폴더 안에 저장된 많은 압축 파일들이 모두 오라클 드라이버이다. 
이렇게 드라이버 파일의 종류가 많은 이유는 각 드라이버 파일이 제공하는 기능상의 
차이이다. 이중에서 "ojdbc6_g.jar " 파일을 사용 .

나는 
ex)
"ojdbc8_g.jar " 파일을 사용 .

사용하고자 하는 오라클 드라이버를 이클립스에서 
클래스 패스에 설정하는 방법.

ex)
Window - Preferences 를 선택 .

[Java]->[Build Path]-[ClassPath Variables]에서 
JRE_LIB의 경로를 파악한다. 
나의 환경에서 
C:\Program Files\Java\jdk-11.0.2\lib
 
이 경로에 있는 'ext' 폴더에  "ojdbc8_g.jar " 파일을 복사하면 
자동으로 압축 파일이 클래스 패스에 추가된다. 
이 방법은 확장 폴더인 'ext' 폴더를 이용해서 앞축 파일을 클래스 패스에 
설정하는 방법이다. 

JDBC 연결을 위한 환경설정이 모두 끝났으면 자바 코드로 데이터베이스를 
연동할수 있다. 대부분의 데이터베이스 연동 코드가 일정한 패턴으로 구현하기 
때문에 설명하는 순서대로 코드 작업을 하면 무리 없이 데이터베이스를 연동할수있다. 


1.2 JDBC  실행순서 정리 

다음은 JDBC를 사용하여 기본적인 프로그램을 개발하는 순서.

1. 오라클 데이터베이스 연동을 위한 4가지 정보를 문자열에 저장한다. 

ex) 윈도우즈 교재 예제 
String driver = "oracle.jdbc.driver.OracleDriver";
String url = "jdbc:oracle:thin:@localhost:1521:orcl";
String userid = "scott";
String passwd = "tiger";

나 
String driver = "oracle.jdbc.driver.OracleDriver";
String url = "jdbc:oracle:thin:@1.252.62.38:11521:orcl";
String userid = "hr2";
String passwd = "1234";
!

드라이버(압축 파일) 내에 핵심이 되는 클래스 파일이 있다. 
이 클래스 파일은 oracle.jdbc.driver 패키지 내에 있는 OracleDriver 클래스이다. 
이 값을 String 변수인 driver에 저장한다. 오라클의 위치 및 포트 번호, 데이터베이스명 
의 정보를 String 변수인 url에 저장한다. 

오라클의 기본 포트 번호는 1521 번이고 데이터베이스 위치는 현재 로컬 컴퓨터에 
설치 했기 때문에 localhost 라고 지정한다. 만약 오라클 데이터베이스가 원격에 
있다면 반드시 원격 IP 주소를 지정한다. 데이터베이스명은 기본적으로 orcl 이다. 
마지막으로 접속 하고자 하는 계정명과 비밀번호를 userid 변수와 passwd 변수에 
저장한다. 


2. 드라이버 로딩 
앞에서 살펴보았던 OracleDriver 클래스를 메모리에 올려야 하는데 
다음과 같은 방법으로 클래스 파일을 메모리에 로딩한다. 

ex)
Class.forName(driver);

3. Connection 맺기 
자바 코드와 오라클 데이터베이스를 연결하는 것을 의미한다. 
연결은 java.sql 패키지의 Connection 클래스를 사용한다. 다음과 같이 
DriverManager  클래스를 이용해서 Connection을 구한다. 

ex)
Connection con = DriverManager.getConnection(url, userid, passwd);

getConnection 메소드 인자에 앞에서 저장했던 url과 userid 그리고 passwd 값을 
지정하면, 이 정보를 이용해서 데이터베이스에 연결한다. 

4. SQL 문 작성 
자바에서 데이터베이스에 요청할 SQL 은 문자열로 저장한다. 
SQL*PLUS 툴에서의 요청과 같다. 주의할 점은 ';' 세미콜론은 입력하지 않는다. 

dept 테이블의 데이터를 검색하기 위한 SQL문은 다음과 같다. 

ex) 
String query = "SELECT deptno,dname,loc FROM dept";


5. PreparedStatement 생성 
요청할 SQL 문을 데이터베이스에 전송할 때 사용되는 API 이다. 다음과 같이 
Connection을 사용해서 PreparedStatement를 생성한다. 

ex) 
PreparedStatement pstmt = con.prepareStatement(query);

Connection 객체의 prepareStatement() 메소드를 이용해서 PreparedStatement 객체 
를 생성할수 있다. 

다음은 dept 테이블의 데이터 중에서 deptno 가 40 인 레코드를 삭제하는 SQL 문이다 .

ex)
String delete = "DELETE FROM dept WHERE deptno = 40";

6. SQL 문 전송 및 결과값 얻기 
SQL 문 전송은 PreparedStatement 객체를 이용해서 데이터베이스에 전송한다. 
요청하는 SQL 문에 따라서 다음과 같이 2가지 메소드를 사용할수 있다.


DML 요청 (INSERT, DELETE, UPDATE)
DML 요청은 executeUpdate() 메소드를 사용한다. 

ex) 
int n = pstmt.executeUpdate();

SQL*PLUS 툴에서 DML 을 요청하면 항상 적용된 레코드의 개수가 다음과 같이
출력된다. 

따라서 executeUpdate() 메소드의 리턴되는 정수값은 변경된 레코드의 개수이다. 
DELETE 문을 요청했을 때 리턴되는 정수값이 10이라면 삭제된 레코드 개수가 10개라 
는 것이다. 반환된 값이 저장되는 변수 n의 값을 이용해서 적용된 레코드의 개수를 파악 
할수 있다. 

또한, JDBC 의 DML 처리는 기본적으로 자동 커밋 (auto commit )
이 발생한다. 따라서  JDBC를 이용하여 SQL 문을 수행한 후에는 
ROLLBACK 처리가 불가능하다. 

SELECT 요청 
SELECT 요청은 executeQuery() 메소드를 사용한다. 

ex) 
ResultSet rs = pstmt.execuQuery(); 
SQL*PLUS 툴에서 SELECT 문을 실행하면 항상 테이블 형태로 다음과 
같이 결과가 출력된다. 

앞의  SELECT 문의 실행 결과에서 테이블 형식의 결과를 자바의 객체로 표현한 것이 
ResultSet 객체이다. ResultSet 객체를 이용해서 원하는 데이터를 얻을 수 있다. 
객체를 이용해서 레코드를 선택하고, 객체가 가리키는 레코드의 칼럼을 지정해서 
데이터를 얻는다. 레코드를 선택하는 메소드는 next() 메소드를 사용하고 칼럼은 
데이터형에 따라서 getInt("칼럼명"), getString("칼럼명") 메소드등을 사용할수 있다. 

다음은 결과값인 ResultSet에서 데이터를 얻는 방법이다. 

ex)
while(rs.next()){
int deptno = rs.getInt("deptno");
String dname = rs.getString("dname");
String loc = rs.getString("loc");
System.out.println(deptno+" "+dname+ " "+loc);
}

결과값의 레코드가 여러 개 있을 수 있기 때문에 while 문을 사용하여 
next() 메소드는 레코드가 있으면 true 값을 리턴하고, 레코드가 없으면 
false 값을 리턴한다. 

deptno 칼럼은 NUMBER 형이기 때문에  getInt() 메소드를 사용해서 데이터를 얻는다. 
dname 칼럼은 VARCHAR2 형이기 때문에 getString() 메소드를 사용한다. 
이때 칼럼명을 사용하거나 SELECT 문에서 사용한 칼럼의 인덱스 값을 사용할수도 있다. 
가독성을 위해서 칼럼명을 사용할 것을 권장한다. 


7 자원 반납
파일 및 데이터베이스는 자바에서 사용하는 외부 자원이기 때문에 반드시 사용한 
다음에는 자원을 해제해야 한다. 
데이터베이스에서 사용한 자원은 ResultSet, Statement 또는 PreparedStatement,
Connection 등이다. 이 자원을 해제시킬 때에는 사용한 역순으로 
해제한다. 데이터베이스를 사용할 때 예외가 발생하거나 발생하지 않거나 항상 자원을 
해제시켜야 하기 때문에 일반적으로 finally 문에서 자원 반납을 위한 코드를 구현한다. 

다음과 같이 자원을 해제한다. 

ex)
rs.close(); // ResultSet 을 사용한 경우 
pstmt.close();
con.close(); 
 
앞에서 설명한 각 단계를 잘 이해하고 숙지하면, 
JDBC를 사용하는 프로그램 개발에 큰 어려움은 없음. 

1.3 
JDBC 실습하기 .

실습하기 14-1
레코드 검색하기 

dept 테이블에 저장된 레코드를 검색하는 자바 프로그램 예제이다. 
이클립스에서 새프젝트를 생성하고, 클래스를 추가.

-프로젝트 이름 : JAVA_CH14_JDBC
-패키지 경로: ch14.JDBC 
-클래스 이름 : JDBC_select_ex_1

package ch14.JDBC;

import java.sql.DriverManager; //public class DriverManager
import java.sql.Connection; //public interface Connection  extends Wrapper, AutoCloseable {
import java.sql.PreparedStatement; // public interface PreparedStatement extends Statement
import java.sql.Statement; //public interface Statement extends Wrapper, AutoCloseable {
import java.sql.ResultSet; //public interface Statement extends Wrapper, AutoCloseable {
import java.sql.SQLException; // public class SQLException extends java.lang.Exception implements Iterable<Throwable> {

public class JDBC_select_ex_1 {
 public static void main(String[] args) {
	 String driver = "oracle.jdbc.driver.OracleDriver";   // 12행 ~ 15행 데이터베이스 접속을 위한 4가지 정보를 String  변수에  저장.
	 String url = "jdbc:oracle:thin:@1.252.62.38:11521:orcl";
	 String userid = "hr2";
	 String passwd = "1234";
	 Connection con = null;
	 PreparedStatement pstmt = null;
	 ResultSet rs = null;
	 try {
		 Class.forName(driver);
		 //명시된 드라이버 클래스를 메모리에 로딩한다. 
		 con = DriverManager.getConnection(url, userid, passwd); 
		 // DriverManager 클래스의 getConnection() 메소드를 이용해서
//		 Connection 객체를 얻는다. 
		 String query = "SELECT deptno,dname,loc FROM dept";
		 //요청할 SQL  문을 String 변수에 저장한다.
		 pstmt =con.prepareStatement(query); 
		 //SQL 문 전송에 필요한 PreparedStatement 객체를 
		 //Connection 객체의 preparedStatement(sql)메소드를 이용해서 얻는다. 
		 
		 rs = pstmt.executeQuery(); 
		 //SELECT 문을 요청하기 때문에 executeQuery()
//		 메소드를 사용하며 결과는 ResultSet 객체로 받는다.
		 while(rs.next()) {
			 int deptno = rs.getInt("deptno");
			 String dname = rs.getString("dname");
			 String loc = rs.getString("loc");
			 System.out.println(deptno + " " + dname + " " + loc);
		 }
	 }catch(Exception e) {
		 e.printStackTrace();
	 }finally {
		 try {
			 if (rs != null) rs.close();
			 if (pstmt != null) pstmt.close();
			 if ( con != null) con.close();
		 }catch(SQLException e){
			 e.printStackTrace();
		 }
	 }
		 }
	}


//
10 ACCOUNTING NEW YORK
20 RESEARCH DALLAS
30 SALES CHICAGO
40 OPERATIONS BOSTON


비교 
SQL> select deptno,dname,loc from dept;

    DEPTNO DNAME          LOC
---------- -------------- -------------
        10 ACCOUNTING     NEW YORK
        20 RESEARCH       DALLAS
        30 SALES          CHICAGO
        40 OPERATIONS     BOSTON
 
 
 실습하기 14-2
 레코드 저장하기
 
dept 테이블에 새로운 레코드를 저장하는 자바 프로그램 예제 
클래스 이름은 
 
 -프로젝트 이름 : JAVA_CH14_JDBC
-패키지 경로: ch14.JDBC 
-클래스 이름 : JDBC_insert_ex_1
 
 새로운 데이터의  deptno 값은 50, dname 값은 " 개발" , 
 loc 값은 "서울"로 저장한다. 
 
 package ch14.JDBC;

import java.sql.DriverManager; //public class DriverManager
import java.sql.Connection; //public interface Connection  extends Wrapper, AutoCloseable {
import java.sql.PreparedStatement; // public interface PreparedStatement extends Statement
import java.sql.SQLException; // public class SQLException extends java.lang.Exception implements Iterable<Throwable> {

public class JDBC_insert_ex_1 {
 public static void main(String[] args) {
	 String driver = "oracle.jdbc.driver.OracleDriver";   // 10행 ~ 14행 데이터베이스 
	 //접속을 위한 4가지 정보를 String  변수에  저장.
	 String url = "jdbc:oracle:thin:@1.252.62.38:11521:orcl";
	 String userid = "hr2";
	 String passwd = "1234";
	 Connection con = null;
	 PreparedStatement pstmt = null;
	 
	 try {
		 Class.forName(driver);
		 //명시된 드라이버 클래스를 메모리에 로딩한다. 
		 con = DriverManager.getConnection(url, userid, passwd); 
		 // DriverManager 클래스의 getConnection() 메소드를 이용해서
//		 Connection 객체를 얻는다. 
		 String sql = "INSERT INTO dept(deptno,dname,loc)" + "VALUES(?,?,?)";
		 //요청할 SQL  문을 String 변수에 저장한다. 이때 저장할 데이터 대신에 '?' 
		 //기호를 사용한다. 나중에 PreparedStatement 객체의 set()메소드를 
		 //사용하여 값을 동적으로 설정한다. 
		 pstmt = con.prepareStatement(sql);
		 pstmt.setInt(1, 50);
		 pstmt.setString(2, "개발");
		 pstmt.setString(3, "서울");
		 //SQL 문 전송에 필요한 PreparedStatement 객체를 
		 //Connection 객체의 preparedStatement(sql)메소드를 이용해서 얻고 '?' 대신에 
		 //설정할 값을 인덱스(1부터 시작) 를 사용하여 set() 메소드로 설정한다.
	     int n = pstmt.executeUpdate();
	     // INSERT 문을 요청하기 때문에 executeUpdate() 메소드를 
	     //사용하며 결과는 int 형으로 저장한다. 
	     System.out.println(n+"개의 레코드가 저장");
	     // 반환된 정수값을 출력하면 SQL 문을 실행한 뒤에 데이터베이스에 적용된 
	     // 레코드의 개수를 알수 있다. 
			 }catch(Exception e) {
		 e.printStackTrace();
	 }finally {
		 try {
			  if (pstmt != null) pstmt.close();
			 if ( con != null) con.close();
			 //사용한 자원을 finally 문을 이용해서 반납한다. 
			 // 자원 반납은 사용했던 객체의 역순으로 하며 모두 공통적으로 
			 // close()  메소드를 사용한다. 
		 }catch(SQLException e){
			 e.printStackTrace();
		 }
	 }
		 }
	}
//
1개의 레코드가 저장

SQL> select deptno,dname,loc from dept;

    DEPTNO DNAME          LOC
---------- -------------- -------------
        10 ACCOUNTING     NEW YORK
        20 RESEARCH       DALLAS
        30 SALES          CHICAGO
        40 OPERATIONS     BOSTON
        50 개발           서울
		
앞의 실습 파일을 실행해보면 새로 저장한 레코드까지 포함하여 출력됨을 
확인할수 있다. 
여러 번 실행하면 deptno 가 PRIMARY KEY 로 지정되었기 때문에 예외가 
발생한다. 여러 번 실습하려면 deptno 칼럼의 값인 50을 중복되지 않는 
값으로 변경한 뒤에 실습한다. 


실습하기 14-3 
레코드 수정하기 
 
 다음은 dept 테이블에 저장된 레코드를 수정하는 자바 프로그램 예제이다. 
 클래스 이름은 
 
 -프로젝트 이름 : JAVA_CH14_JDBC
-패키지 경로: ch14.JDBC 
-클래스 이름 : JDBC_update_ex_1
 
수정할 데이터로 deptno  값이 50인 레코드의 dname 칼럼의 값을 
'인사'로 변경하고, loc 칼럼의 값을 '부산'으로 변경한다. 

자바 커피 JDBC 453 13/40

package ch14.JDBC;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class JDBC_update_ex_1 {
	public static void main(String[] args) {
		 String driver = "oracle.jdbc.driver.OracleDriver";   // 10행 ~ 14행 데이터베이스 
		 //접속을 위한 4가지 정보를 String  변수에  저장.
		 String url = "jdbc:oracle:thin:@1.252.62.38:11521:orcl";
		 String userid = "hr2";
		 String passwd = "1234";
		 Connection con = null;
		 PreparedStatement pstmt = null;
		 
		 try {
			 Class.forName(driver);
			 //명시된 드라이버 클래스를 메모리에 로딩한다. 
			 con = DriverManager.getConnection(url, userid, passwd); 
			 // DriverManager 클래스의 getConnection() 메소드를 이용해서
//			 Connection 객체를 얻는다. 
			 String sql = "UPDATE dept SET dname = ? , loc = ? WHERE deptno = ?";
			 //요청할 SQL  문을 String 변수에 저장한다. 이때 저장할 데이터 대신에 '?' 
			 //기호를 사용한다. 나중에 PreparedStatement 객체의 set()메소드를 
			 //사용하여 값을 동적으로 설정한다. 
			 pstmt = con.prepareStatement(sql);
			 pstmt.setString(1, "인사");
			 pstmt.setString(2, "부산");
			 pstmt.setInt(3, 50);
			 //SQL 문 전송에 필요한 PreparedStatement 객체를 
			 //Connection 객체의 preparedStatement(sql)메소드를 이용해서 얻고 '?' 대신에 
			 //설정할 값을 인덱스(1부터 시작) 를 사용하여 set() 메소드로 설정한다.
		     int n = pstmt.executeUpdate();
		     // UPDATE 문을 요청하기 때문에 executeUpdate() 메소드를 
		     //사용하며 결과는 int 형으로 저장한다. 
		     System.out.println(n+"개의 레코드가 수정");
		     // 반환된 정수값을 출력하면 SQL 문을 실행한 뒤에 데이터베이스에 적용된 
		     // 레코드의 개수를 알수 있다. 
				 }catch(Exception e) {
			 e.printStackTrace();
		 }finally {
			 try {
				  if (pstmt != null) pstmt.close();
				 if ( con != null) con.close();
				 //사용한 자원을 finally 문을 이용해서 반납한다. 
				 // 자원 반납은 사용했던 객체의 역순으로 하며 모두 공통적으로 
				 // close()  메소드를 사용한다. 
			 }catch(SQLException e){
				 e.printStackTrace();
			 }
		 }
			 }

}
//
1개의 레코드가 수정

SQL> select deptno,dname,loc from dept;

    DEPTNO DNAME          LOC
---------- -------------- -------------
        10 ACCOUNTING     NEW YORK
        20 RESEARCH       DALLAS
        30 SALES          CHICAGO
        40 OPERATIONS     BOSTON
        50 인사           부산

실습하기 14-4
레코드 삭제하기 
 
 다음은 dept 테이블에 저장된 레코드를 삭제하는 자바 프로그램 예제이다. 
 클래스 이름은 
 
 -프로젝트 이름 : JAVA_CH14_JDBC
-패키지 경로: ch14.JDBC 
-클래스 이름 : JDBC_delete_ex_1
 
삭제할 데이터로 deptno  값이 50인 레코드를 삭제한다. 
dept 테이블에 저장된 다른 레코드를 삭제할 때에는 emp 
테이블에서 참조하기 때문에 에러가 발생한다. 

package ch14.JDBC;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class JDBC_delete_ex_1 {
	public static void main(String[] args) {
		 String driver = "oracle.jdbc.driver.OracleDriver";   // 10행 ~ 14행 데이터베이스 
		 //접속을 위한 4가지 정보를 String  변수에  저장.
		 String url = "jdbc:oracle:thin:@1.252.62.38:11521:orcl";
		 String userid = "hr2";
		 String passwd = "1234";
		 Connection con = null;
		 PreparedStatement pstmt = null;
		 
		 try {
			 Class.forName(driver);
			 //명시된 드라이버 클래스를 메모리에 로딩한다. 
			 con = DriverManager.getConnection(url, userid, passwd); 
			 // DriverManager 클래스의 getConnection() 메소드를 이용해서
//			 Connection 객체를 얻는다. 
			 String sql = "DELETE  FROM dept WHERE deptno = ?";
			 //요청할 SQL  문을 String 변수에 저장한다. 이때 저장할 데이터 대신에 '?' 
			 //기호를 사용한다. 나중에 PreparedStatement 객체의 set()메소드를 
			 //사용하여 값을 동적으로 설정한다. 
			 pstmt = con.prepareStatement(sql);
			  pstmt.setInt(1, 50);
			 //SQL 문 전송에 필요한 PreparedStatement 객체를 
			 //Connection 객체의 preparedStatement(sql)메소드를 이용해서 얻고 '?' 대신에 
			 //설정할 값을 인덱스(1부터 시작) 를 사용하여 set() 메소드로 설정한다.
		     int n = pstmt.executeUpdate();
		     // UPDATE 문을 요청하기 때문에 executeUpdate() 메소드를 
		     //사용하며 결과는 int 형으로 저장한다. 
		     System.out.println(n+"개의 레코드가 삭제");
		     // 반환된 정수값을 출력하면 SQL 문을 실행한 뒤에 데이터베이스에 적용된 
		     // 레코드의 개수를 알수 있다. 
				 }catch(Exception e) {
			 e.printStackTrace();
		 }finally {
			 try {
				  if (pstmt != null) pstmt.close();
				 if ( con != null) con.close();
				 //사용한 자원을 finally 문을 이용해서 반납한다. 
				 // 자원 반납은 사용했던 객체의 역순으로 하며 모두 공통적으로 
				 // close()  메소드를 사용한다. 
			 }catch(SQLException e){
				 e.printStackTrace();
			 }
		 }
			 }

}
//
1개의 레코드가 삭제

SQL> select deptno,dname,loc from dept;

    DEPTNO DNAME          LOC
---------- -------------- -------------
        10 ACCOUNTING     NEW YORK
        20 RESEARCH       DALLAS
        30 SALES          CHICAGO
        40 OPERATIONS     BOSTON

        50 인사           부산
50번 삭제 


===========================================

2 DAO 및 DTO 패턴 

데이터베이스를 연동하는 프로그램을 개발할 때 반드시 사용되는 2가지 
개발 패턴으로 DAO 패턴과 DTO 패턴이 있다. 

2.1 DAO(Data Access Object) 패턴 

일반적으로 프로그램 개발은 GUI 화면에 보여 줄수 있는 데이터 관리를 위해서 
데이터베이스를 사용해서 개발하게 된다. 가장 손쉽게 볼수 있는 것이 
웹(Web)이다. 

브라우저에서 보이는 것처럼 GUI 화면을 구성하는 코드를 'Presentation Logic'
이라고 하며, GUI 화면에 데이터를 보여주기 위해서 데이터베이스를 검색하는 
코드 및 GUI 화면에서 새로 발생한 데이터(예를 들면 회원가입)를 데이터베이스
에 저장하는 코드와 같은 실제적인 작업을 하는 코드를 'Business Logic' 이라고 한다. 

'Presentation Logic'과 'Business Logic'을 하나의 클래스로 모두 구현할 수도 
있고 여러 클래스로 모듈화해서 구현할 수도 있다. 하나의 클래스로 만들면 
유지보수가 어려워지기 때문에 바람직하지 않다. 

예를 들어 2개의 로직이 하나의 클래스 파일에 저장되면 화면(Presentation Logic)을 
변경하거나 또는 Business logic 이 변경될 때 복잡한 코드 때문에 유지보수가 
어려워진다.  따라서 두가지 영역을 모듈화하여 개발한다. 

모듈화한 클래스들 중에서 데이터베이스 접근하는 코드만을 관리하는 클래스를 
DAO 클래스라고 한다. 이렇게 DAO 클래스를 사용해서 개발하는 것이 보편화 
되었기 때문에 DAO 패턴이라고 부른다. 

일반적으로 DAO 클래스는 테이블마다 한 개씩 생성해서 사용한다. DAO 클래스
안에는 특정 테이블에서 수행할 작업을 메소드로 정의해서 구현하며 
Presentation Logi 에서는 DAO 클래스의 메소드를 호출하면서 원하는 작업을 
구현하게 된다. 

2.2 DTO (Data Transfer Object ) 패턴 

Presentation Logic 과 Business Logic 을 여러 클래스로 분리해서 
작업은 하지만 서로간에 긴밀한 관계가 유지되면서 작업이 이루어진다. 
Presentation Logic 에서 보여줄 데이터를 얻기 위해서 Business Logic에 
요청하면 Business Logic은 필요한 데이터를 데이터베이스 검색해서 
Presentation Logic 에게 결과를 반화하는 작업 등을 하게 된다. 

이렇게 데이터를 다른 Logic 에게 전송 및 반환할 때 효율적으로 데이터를 사용 
할수 있게 클래스를 작성할 수 있는데 이 클래스를 DTO 클래스라고 한다. 
이름 그대로 데이터를 전송할 때 사용되는 클래스이다. DTO 클래스를 사용하면 
데이터를 전송할 때와 전송된 데이터를 얻어서 사용할 때 
효율적으로 사용할수 있는 장점이다. 

다음과 같은 구조 DAO ,DTO 패턴을 사용할수 있다. 

presentation logic -> business logic 
1.데이터 검색 ->DAO , DTO-> 오라클
2.데이터 저장 ->DAO , DTO-> 오라클
3.데이터 삭제 ->DAO , DTO-> 오라클
4.데이터 수정 ->DAO , DTO-> 오라클

실습하기 14-5 

DAO  패턴을 이용한 레코드 검색하기 

다음은 dept 테이블에 저장된 레코드를 검색하는 자바 프로그램 예제.

Presentation Login 을 담당하는 Ex_DTO 클래스와 DAO 패턴을 적용한 
'Ex_DAO'  클래스 그리고 DTO 패턴을 적용한 'Ex_DTO' 클래스를 작성한다. 
'Ex_DTO' 클래스는 실제로 GUI 화면 코드를 작성해야 하지만 실습 관계상 
모두 생략하고 main 메소드만을 지정한다. 새 클래스를 추가하는 방법으로 
3개의 클래스를 현재 프로젝트에 추가한다. 

dept 테이블의 칼럼 데이터를 관리하기 위한 용도로 'Ex_DTO' 클래스를 작성.
일반적으로 테이블의 테이터는 레코드 단위로 처리하기 때문에 레코드 전체를 
저장할수 있는 클래스를 작성하면 레코드를 생성하거나 수정, 삭제 또는 검색할 때 
효율적인 데이터 관리를 할수 있다. 
이런 장점을 취한 클래스를 DTO 클래스라고 한다. 
일반적으로 DTO 클래스는 필요한 인스턴스 변수와 인스턴스 변수의 값을 
읽거나 설정하기 위한 Getter/Setter 메소드로 구성된다. 

 -프로젝트 이름 : JAVA_CH14_JDBC
-패키지 경로: ch14.JDBC 
-클래스 이름 : JDBC_Ex_DTO

package ch14.JDBC;

public class JDBC_Ex_DTO {

	int deptno;  // dept 테이블의 칼럼을 저장하기 위한 인스턴스 변수를 정의.
	String dname;
	String loc;
	
	public JDBC_Ex_DTO(int deptno, String dname, String loc) {
		this.deptno = deptno;
		this.dname = dname;
		this.loc = loc;
	}
	public JDBC_Ex_DTO() {}

	public int getDeptno() { // 인스턴스 변수에 값을 설정하는 Setter 메소드와 인스턴스 변수의 값을
		// 읽어 오는 Getter 메소드를 정의.
		return deptno;
	}

	public void setDeptno(int deptno) {
		this.deptno = deptno;
	}

	public String getDname() {
		return dname;
	}

	public void setDname(String dname) {
		this.dname = dname;
	}

	public String getLoc() {
		return loc;
	}

	public void setLoc(String loc) {
		this.loc = loc;
	}

}

 -프로젝트 이름 : JAVA_CH14_JDBC
-패키지 경로: ch14.JDBC 
-클래스 이름 : JDBC_Ex_DAO

package ch14.JDBC;
import java.util.ArrayList; //public class ArrayList<E> extends AbstractList<E>
import java.sql.*;

public class JDBC_Ex_DAO {
	 String driver = "oracle.jdbc.driver.OracleDriver";   // 6행 ~ 9행 데이터베이스 접속을 위한 4가지 정보를 String  변수에  저장.
	 String url = "jdbc:oracle:thin:@1.252.62.38:11521:orcl";
	 String userid = "hr2";
	 String passwd = "1234";
	 public JDBC_Ex_DAO() {
		 try {
		 Class.forName(driver);  //드라이버를 로딩하는 초기화 작업을 생성자에서 구현한다.
	 }catch(ClassNotFoundException e) { e.printStackTrace();}
	 }
	 public ArrayList<JDBC_Ex_DTO>select(){
	   ArrayList<JDBC_Ex_DTO> list = new ArrayList<JDBC_Ex_DTO>();
	  Connection con = null;
	  PreparedStatement pstmt = null;
	  ResultSet rs = null;
	 
	 try {
		 con = DriverManager.getConnection(url, userid, passwd); // DriverManager 클래스의 getConnection() 메소드를 이용해서 Connection 객체를 얻는다. 
		 String query = "SELECT deptno,dname,loc FROM dept"; //요청할 SQL  문을 String 변수에 저장한다.
		 pstmt =con.prepareStatement(query); //SQL 문 전송에 필요한 PreparedStatement 객체를 Connection 객체의 preparedStatement(sql)메소드를 이용해서 얻는다. 
		 rs = pstmt.executeQuery(); //SELECT 문을 요청하기 때문에 executeQuery() 메소드를 사용하며 결과는 ResultSet 객체로 받는다.
		 while(rs.next()) {
		JDBC_Ex_DTO dto = new JDBC_Ex_DTO(); // 각각의 레코드 정보를 JDBC_Ex_DTO 클래스의 객체에 저장한다. 
		dto.setDeptno(rs.getInt("deptno"));
		dto.setDname(rs.getString("dname"));
		dto.setLoc(rs.getString("loc"));
		list.add(dto); // 저장된 JDBC_Ex_DTO 클래스의 객체를 누적시키기 위해서 
		// ArrayList 객체 저장한다. while 문이 모두 실행된 후에는 dept 테이블의 모든 레코드가 
		// ArrayList 의 객체에 모두 저장된다. 
		 }
	 }catch(Exception e) {
		 e.printStackTrace();
	 }finally {
		 try {
			 if (rs != null) rs.close();
			 if (pstmt != null) pstmt.close();
			 if ( con != null) con.close();
		 }catch(SQLException e){
			 e.printStackTrace();
		 }
	 }
	 return list;
		 }
}

Presentation Logic 역할을 하는 ''JDBC_Ex_Presentation_Logic"
클래스를 작성한다. 
이 클래스에서 DAO 클래스와 연동하면서 데이터 출력 및 데이터 
저장, 수정, 삭제 작업 등을 구현할 수 있다. 


 -프로젝트 이름 : JAVA_CH14_JDBC
-패키지 경로: ch14.JDBC 
-클래스 이름 : JDBC_Ex_Presentation_Logic

package ch14.JDBC;

import java.util.ArrayList;

public class JDBC_Ex_Presentation_Logic {
	public static void main(String[] args) {
		JDBC_Ex_DAO dao = new JDBC_Ex_DAO(); //JDBC_Ex_DAO 클래스를 사용하기 위해서 객체 생성.
		ArrayList<JDBC_Ex_DTO> list = dao.select(); // JDBC_Ex_DAO 클래스의 select 메소드 호출.
		// 결과값으로는 dept 테이블의 모든 레코드를 저장하고 있는 ArrayList 객체를 리턴 받는다. 
				for(JDBC_Ex_DTO dto : list) {
					int deptno = dto.getDeptno();
					String dname = dto.getDname();
					String loc = dto.getLoc();
					System.out.println(deptno+"\t"+dname+"\t"+loc);
				} //for ~ each 문을 이용해서 ArrayList 에 저장된 레코드의 값을 출력한다. 
				

	}

}
//
10	ACCOUNTING	NEW YORK
20	RESEARCH	DALLAS
30	SALES	CHICAGO
40	OPERATIONS	BOSTON

SQL> SELECT deptno,dname,loc FROM dept;

    DEPTNO DNAME          LOC
---------- -------------- -------------
        10 ACCOUNTING     NEW YORK
        20 RESEARCH       DALLAS
        30 SALES          CHICAGO
        40 OPERATIONS     BOSTON

===============================

3 Connection Pool 기능 

데이터베이스를 연동할 때 적용 가능한 2가지 패터인 
DAO 와 DTO 패턴을 살펴봄. 
추가로 데이터베이스를 연동할 때 성능 향상을 위해서 
Connection Pool 기능을 사용 할수 있다. 

데이터베이스 연동은 프로그램과 데이터베이스를 연결하기 위해 
Connection을 맺는 작업이 필수 이며, 이러한 연결은 반드시 
'Thread-safe'로 작업이 이루어지도록 고려해야 한다. 

'Thread-safe' 는 하나의 Connection으로 여러 사용자가 사용하지 못하도록 
구현해야 하는 방법이다. 하나의 Connection으로 여러 사용자가 사용하면 
원하지 않는 결과가 나올수 있기 때문이다. 

또한, Connection 을 맺는 작업이 많은 시간이 소모되는 작업이기 때문에 
데이터베이스와 연동할 때 소모되는 시간을 대부분을 소비하게 된다. 
이러한 문제점 때문에 필요할 때마다 Connection을 맺어서 사용하지 않고 
미리 Connection을 일정한 수만큼 맺어 놓고 필요할 때 빌려서 
사용하는 방법을 생각할수 있다. 

미리 Connection을 맺어서 보관하는 기능을 제공하는 클래스를 ConnectionPool
클래스라고 한다. DAO 클래스에서 ConnectionPool 클래스에 저장된 
Connection을 이용해서 원하는 작업을 하고 사용 후에는 ConnectionPool에 
Connection을 돌려주는 작업을 한다. 만약 돌려주지 않으면 ConnectionPool
클래스에 저장된 Connection 을 모두 소비하기 때문에 더는 Connection을 
사용할수 없게 된다. 

이런 기능을 제공하는 ConnectionPool 클래스를 직접 작성해서 사용할수 도 
있지만, 자바 개발자들이 손쉽게 사용할수 있도록 Apache 그룹에서 만들어 
무로료 배포하는 API 파일을 일반적으로 사용한다. 

다음은 Apach 그룹에서 배포한 ConnectionPool 기능을 포함하는 API를 사용하는 
방법이다. 모두 3개의 zip 파일을 다운로드해야 한다. 

http://jakarta.apache.org
!
1 다음의 Apache 사이트에 접속하여 왼쪽 메뉴 중에서 
Commons  선택 .

2  내용중 DBCP 링크 선택 

3 아래에 다운로드 링크 선택 

4 commons-dbcp2-2.1.1-bin.zip 파일 다운로드 

5. 다시 Commons에서 Pool 링크 선택 

6. 다운. Commons Pool 2.6.2

7. 다시 Commons에서 Logging 링크 선택 

8.  Commons Logging 1.2 다운. 

9. 각 파일을 압축 해제후, 이클립스 클래스 패스에 추가. 
Build path -> Configure Build Path 선택. 
Java Build Path - Libraries - Add External JARs... 를 선택. 

3개 파일 추가. 

10 . 사이트의 예제 파일 보기 
 BasicDataSourceExample.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import javax.sql.DataSource;

//
// Here are the dbcp-specific classes.
// Note that they are only used in the setupDataSource
// method. In normal use, your classes interact
// only with the standard JDBC API
//
import org.apache.commons.dbcp2.BasicDataSource;

//
// Here's a simple example of how to use the BasicDataSource.
//

//
// Note that this example is very similar to the PoolingDriver
// example.

//
// To compile this example, you'll want:
//  * commons-pool-2.3.jar
//  * commons-dbcp-2.1.jar 
// in your classpath.
//
// To run this example, you'll want:
//  * commons-pool-2.3.jar
//  * commons-dbcp-2.1.jar 
//  * commons-logging-1.2.jar
// in your classpath.
//
//
// Invoke the class using two arguments:
//  * the connect string for your underlying JDBC driver
//  * the query you'd like to execute
// You'll also want to ensure your underlying JDBC driver
// is registered.  You can use the "jdbc.drivers"
// property to do this.
//
// For example:
//  java -Djdbc.drivers=org.h2.Driver \
//       -classpath commons-pool2-2.3.jar:commons-dbcp2-2.1.jar:commons-logging-1.2.jar:h2-1.3.152.jar:. \
//       BasicDataSourceExample \
//       "jdbc:h2:~/test" \
//       "SELECT 1"
//
public class BasicDataSourceExample {

    public static void main(String[] args) {
        // First we set up the BasicDataSource.
        // Normally this would be handled auto-magically by
        // an external configuration, but in this example we'll
        // do it manually.
        //
        System.out.println("Setting up data source.");
        DataSource dataSource = setupDataSource(args[0]);
        System.out.println("Done.");

        //
        // Now, we can use JDBC DataSource as we normally would.
        //
        Connection conn = null;
        Statement stmt = null;
        ResultSet rset = null;

        try {
            System.out.println("Creating connection.");
            conn = dataSource.getConnection();
            System.out.println("Creating statement.");
            stmt = conn.createStatement();
            System.out.println("Executing statement.");
            rset = stmt.executeQuery(args[1]);
            System.out.println("Results:");
            int numcols = rset.getMetaData().getColumnCount();
            while(rset.next()) {
                for(int i=1;i<=numcols;i++) {
                    System.out.print("\t" + rset.getString(i));
                }
                System.out.println("");
            }
        } catch(SQLException e) {
            e.printStackTrace();
        } finally {
            try { if (rset != null) rset.close(); } catch(Exception e) { }
            try { if (stmt != null) stmt.close(); } catch(Exception e) { }
            try { if (conn != null) conn.close(); } catch(Exception e) { }
        }
    }

    public static DataSource setupDataSource(String connectURI) {
        BasicDataSource ds = new BasicDataSource();
        ds.setDriverClassName("org.h2.Driver");
        ds.setUrl(connectURI);
        return ds;
    }

    public static void printDataSourceStats(DataSource ds) {
        BasicDataSource bds = (BasicDataSource) ds;
        System.out.println("NumActive: " + bds.getNumActive());
        System.out.println("NumIdle: " + bds.getNumIdle());
    }

    public static void shutdownDataSource(DataSource ds) throws SQLException {
        BasicDataSource bds = (BasicDataSource) ds;
        bds.close();
    }
}
 


실습하기 14-6 
Connection Pool 기능을 포함한 레코드 검색 

dept 테이블의 칼럼 데이터를 관리하기 위한 용도로 PoolDTO 클래스를 
작성한다. 클래스 이름은 "JDBC_PoolDTO"로하고, 패키지 경로를 

 -프로젝트 이름 : JAVA_CH14_JDBC
-패키지 경로: ch14.JDBC 
-클래스 이름 : JDBC_PoolDAO, JDBC_PoolDTO, 
GUI 역할을 담당하는 JDBC_PoolTest
데이터는 dept 테이블의 레코드를 출력함. 

package ch14.JDBC;

public class JDBC_PoolDTO {

	int deptno; //5-8행 dept 테이블의 컬럼에 
	//해당하는 인스턴스 변수를 선언한다.
	String dname;
	String loc;

	public void setDeptno(int deptno) { //인스턴스 변수에 대한 Getter/Setter 메소드를 정의한다.  
				this.deptno = deptno;
	}
	public void setDname(String dname) {
		this.dname = dname;
	}
	public void setLoc(String loc) {
		this.loc = loc;
	}
	
	public int getDeptno() {
		return deptno;
	}
	public String getDname() {
		return dname;
	}
	public String getLoc() {
		return loc;
	}
}

데이터베이스에 접근하여 dept 테이블을 조작하기 위한 DTO 
클래스를 작성한다. 

 -프로젝트 이름 : JAVA_CH14_JDBC
-패키지 경로: ch14.JDBC 
-클래스 이름 : JDBC_PoolDAO, JDBC_PoolDTO, 
GUI 역할을 담당하는 JDBC_PoolTest

JDBC_PoolDAO.java

package ch14.JDBC;

import java.util.ArrayList; //public class ArrayList<E> extends AbstractList<E>
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

import org.apache.commons.dbcp2.BasicDataSource;


public class JDBC_PoolDAO {
 BasicDataSource ds;
  public JDBC_PoolDAO() {
	  ds = new BasicDataSource(); //Connection Pool 기능과 Thread-safe 기능을 갖춘 BasicDataSource
	  // 클래스의 객체를 생성한다. 이 클래스는 이클립스에 추가한 commons-dbcp-2.x.jar에 내장된 API이다. 
	  ds.setDriverClassName("oracle.jdbc.driver.OracleDriver");
	  ds.setUrl("jdbc:oracle:thin:@1.252.62.38:11521:orcl");
	  ds.setUsername("hr2");
	  ds.setPassword("1234"); // BasicDataSource 클래스의 객체에서 데이터베이스에 연결할 때
	  // 필요한 4가지 정보를 설정. 
	  ds.setInitialSize(4); // setInitialSize() 메소드를 이용해서 Connection Pool에 초기값으로 
	  //4개의 Connection을 가질수 있도록 설정한다. 이 4개의 Connection 을 공유하면서
	  // 사용할수 있다.
  }
		 public ArrayList<JDBC_PoolDTO>select(){
		   ArrayList<JDBC_PoolDTO> list = new ArrayList<JDBC_PoolDTO>();
		  Connection con = null;
		  PreparedStatement pstmt = null;
		  ResultSet rs = null;
		  try {
			 con = ds.getConnection(); // BasiceDataSource 의 객체에서 인자가 없는 
			 // getConnection() 메소드를 이용해서 Connection 객체를 얻는다.
			 // Pool에 저장되어 있던 Connection 객체가 반환된다. 
			 String query = "SELECT deptno,dname,loc FROM dept"; //요청할 SQL  문을 String 변수에 저장한다.
			 pstmt =con.prepareStatement(query); //SQL 문 전송에 필요한 PreparedStatement 객체를 Connection 객체의 preparedStatement(sql)메소드를 이용해서 얻는다. 
			 rs = pstmt.executeQuery(); //SELECT 문을 요청하기 때문에 executeQuery() 메소드를 사용하며 결과는 ResultSet 객체로 받는다.
			 while(rs.next()) {
			JDBC_PoolDTO dto = new JDBC_PoolDTO(); // 각각의 레코드 정보를 JDBC_Ex_DTO 클래스의 객체에 저장한다. 
			dto.setDeptno(rs.getInt("deptno"));
			dto.setDname(rs.getString("dname"));
			dto.setLoc(rs.getString("loc"));
			list.add(dto); // 저장된 JDBC_Ex_DTO 클래스의 객체를 누적시키기 위해서 
			// ArrayList 객체 저장한다. while 문이 모두 실행된 후에는 dept 테이블의 모든 레코드가 
			// ArrayList 의 객체에 모두 저장된다. 
			 }
		 }catch(Exception e) {
			 e.printStackTrace();
		 }finally {
			 try {
				 if (rs != null) rs.close();
				 if (pstmt != null) pstmt.close();
				 if ( con != null) con.close();
			 }catch(SQLException e){
				 e.printStackTrace();
			 }
		 }
		 return list;
			 }
	}

Presentation Logic 의 역할로 PoolTest 클래스를 작성.

 -프로젝트 이름 : JAVA_CH14_JDBC
-패키지 경로: ch14.JDBC 
-클래스 이름 : JDBC_PoolDAO, JDBC_PoolDTO, 
GUI 역할을 담당하는 JDBC_PoolTest

JDBC_PoolTest

//
10 ACCOUNTING NEW YORK
20 RESEARCH DALLAS
30 SALES CHICAGO
40 OPERATIONS BOSTON


SQL> SELECT deptno,dname,loc FROM dept;

    DEPTNO DNAME          LOC
---------- -------------- -------------
        10 ACCOUNTING     NEW YORK
        20 RESEARCH       DALLAS
        30 SALES          CHICAGO
        40 OPERATIONS     BOSTON

======================================
4 메타 데이터 

일반적으로 메타 데이터(Meta Data) 라고 하면 실제 데이터를 관리하는데 
필요한 추가적인 데이터를 의미한다. 예를 들어 부서번호, 부서명 데이터를 
저장하는데 필요한 추가 데이터는 데이터베이스 정보, 데이블 정보, 
컬럼 정보 등이 필요하다. 이러한 데이터를 메타 데이터라고 한다. 

JDBC 에서는 이런 메타 데이터를 얻을 수 있는 2가지 API를 제공한다. 

(1) DatabaseMetaData API 
데이터베이스 이름, 버전, 드라이버명, url 등과 같이 데이터베이스와 
관련된 메타 데이터를 얻을 수 있다. 

(2) ResultSetMetaData API 
테이블명, 컬럼 개수, 컬럼명, 데이터형 등과 같이 테이블과 
관련된 메타 데이터를 얻을수 있다. 

 -프로젝트 이름 : JAVA_CH14_JDBC
-패키지 경로: ch14.JDBC 
-클래스 이름 :  JDBC_Meta

package ch14.JDBC;

import java.sql.*;

public class JDBC_Meta {
	public static void main(String[] args) {

		 String driver = "oracle.jdbc.driver.OracleDriver";   // 12행 ~ 15행 데이터베이스 접속을 위한 4가지 정보를 String  변수에  저장.
		 String url = "jdbc:oracle:thin:@1.252.62.38:11521:orcl";
		 String userid = "hr2";
		 String passwd = "1234";
		 Connection con = null;
		 try {
			 Class.forName(driver);  //명시된 드라이버 클래스를 메모리에 로딩한다. 
			 con = DriverManager.getConnection(url, userid, passwd); // DriverManager 클래스의 getConnection() 메소드를 이용해서 Connection 객체를 얻는다. 
			DatabaseMetaData data = con.getMetaData();
			System.out.println(data.getDatabaseProductName());
			System.out.println(data.getDatabaseProductVersion());
			System.out.println(data.getDriverName());
			System.out.println(data.getURL());
			ResultSet rs = data.getSchemas();
			 while(rs.next()) {
					 System.out.println("계정명 : "+rs.getString(1));
			 }
		 }catch(Exception e) {
			 e.printStackTrace();
		 }finally {
			 try {
				  if ( con != null) con.close();
			 }catch(SQLException e){
				 e.printStackTrace();
			 }
		 }
	}
}
//
Oracle
Oracle Database 12c Enterprise Edition Release 12.2.0.1.0 - 64bit Production
Oracle JDBC driver
jdbc:oracle:thin:@1.252.62.38:11521:orcl
계정명 : ANONYMOUS
계정명 : APPQOSSYS
계정명 : AUDSYS
계정명 : CTXSYS
계정명 : DBSFWUSER
계정명 : DBSNMP
계정명 : DIP
계정명 : DVF
계정명 : DVSYS
계정명 : GGSYS
계정명 : GSMADMIN_INTERNAL
계정명 : GSMCATUSER
계정명 : GSMUSER
계정명 : HR2
계정명 : LBACSYS
계정명 : MDDATA
계정명 : MDSYS
계정명 : OJVMSYS
계정명 : OLAPSYS
계정명 : ORACLE_OCM
계정명 : ORDDATA
계정명 : ORDPLUGINS
계정명 : ORDSYS
계정명 : OUTLN
계정명 : REMOTE_SCHEDULER_AGENT
계정명 : SI_INFORMTN_SCHEMA
계정명 : SPATIAL_CSW_ADMIN_USR
계정명 : SYS
계정명 : SYS$UMF
계정명 : SYSBACKUP
계정명 : SYSDG
계정명 : SYSKM
계정명 : SYSRAC
계정명 : SYSTEM
계정명 : WMSYS
계정명 : XDB
계정명 : XS$NULL

		
 -프로젝트 이름 : JAVA_CH14_JDBC
-패키지 경로: ch14.JDBC 
-클래스 이름 :  JDBC_RSMeta

package ch14.JDBC;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;

public class JDBC_RSMeta {
	 public static void main(String[] args) {
		 String driver = "oracle.jdbc.driver.OracleDriver";   // 12행 ~ 15행 데이터베이스 접속을 위한 4가지 정보를 String  변수에  저장.
		 String url = "jdbc:oracle:thin:@1.252.62.38:11521:orcl";
		 String userid = "hr2";
		 String passwd = "1234";
		 Connection con = null;
		 PreparedStatement pstmt = null;
		 ResultSet rs = null;
		 try {
			 Class.forName(driver);  //명시된 드라이버 클래스를 메모리에 로딩한다. 
			 con = DriverManager.getConnection(url, userid, passwd); 
			 // DriverManager 클래스의 getConnection() 메소드를 이용해서 Connection 객체를 얻는다. 
			String query = "SELECT * FROM dept"; // dept  테이블을 SELECT 하는 SQL 문 작성. 
			pstmt = con.prepareStatement(query);
			rs = pstmt.executeQuery(); // ResultSet  객체에서 테이블의 메타 정보를 얻을 수 있는 
			//ResultSetMetaData  객체를 얻는다. 
			ResultSetMetaData data = rs.getMetaData();					
			System.out.println(data.getColumnCount());
			System.out.println(data.getColumnName(1));
			System.out.println(data.getColumnName(2));
			System.out.println(data.getColumnTypeName(1));
			// ResultSetMetaData 객체의 메소드를 이용해서 컬럼 개수, 컬러명,
			// 데이터형 등의 메타 정보를 얻는다. 
			
		 }catch(Exception e) {
			 e.printStackTrace();
		 }finally {
			 try {
				  if ( rs != null) rs.close();
				  if ( pstmt != null) pstmt.close();
				  if ( con != null) con.close();
			 }catch(SQLException e){
				 e.printStackTrace();
			 }
		 }
		}

}
//
3
DEPTNO
DNAME
NUMBER

 
SQL> SELECT * FROM dept;

    DEPTNO DNAME          LOC
---------- -------------- -------------
        10 ACCOUNTING     NEW YORK
        20 RESEARCH       DALLAS
        30 SALES          CHICAGO


=====================================

15장 윈도우 빌더를 활용한 자바 GUI 

-이립스에 WindowBuilder 플러그인 설정에 관하여 학습한다. 
-Swing 개요 및 사용법에 관하여 학습한다. 
-JFrame에 관하여 학습한다. 
-컨테이너에 관하여 학습한다. 
-레이아웃에 관하여 학습한다. 
-컴포넌트에 관하여 학습한다. 
-이벤트 처리 방법에 관하여 학습한다. 

1.윈도우빌더란?
2.윈도우빌더 개발 환경 설정 
3. 윈도우빌더 프로젝트 만들기 
4. 이벤트 처리 1
5. GUI 입력폼 만들기 
6. 이벤트 처리 2 
-----------------------------------------------------
1.윈도우빌더란?

윈도우빌더는 이클립스 플러그인으로 사용되며 강력하고 
다루기 쉬운 양방향 자바 GUI 툴이다. 

윈도우 빌더는 SWT 디자이너와 스윙 디자이너로 구성되며 매우 쉽게 
GUI를 만들수 있다. 
GUI 응용 프로그램을 구현할 때 자바 소스 코드에 의지 하지 않고 
비주얼 디자이너와 레이아웃 도구 등 간단한 양식을 작성하는 창을 통해 
자바 코드를 생성한다. 
또한 속성 편집기를 사용하여 컨트롤의 다양한 속성을 쉽게 
변경할수 있으며, 응용 프로그램 이벤트 처리 기능 추가 등도 드래그 앤 드롭을 
통해 쉽게 구현 할수 있다. 

윈도우빌더에 의해 생성된 코드는 컴파일 및 실행을 위해 추가로 
사용자 지정 라이브러리를필요로 하지 않는다. 
-------------------------------------------------------------------------
2.윈도우빌더 개발 환경 설정 

1 플러그인 설치 
http://www.eclipse.org./windowbuilder/download.php 

Name : WindowBuilder
Location : http://download.eclipse.org/windowbuilder/WB/integration/4.5/
[출처] 이클립스에 윈도우빌더(WindowBuilder) 설치하기|작성자 킹닥터

설치후, 이클립스 재시작 후, 
Window - show view - other 클릭. 

WindowBuilder 항목에서 하위 항목으로 "Palette"가 존재하면 
잘 설치된것.

설치 후, 버전 오류가 발생하면, 새 이클립스 
설치후, 업데이트 설치 하면 됨.

----------------------------------------------------------------------------------
3. 윈도우빌더 프로젝트 만들기 

1) 프로젝트 유형 Java Project 로 하고 ,
 프로젝트 이름  Java_WB 생성. 
 패키지 : ch15.wb
 클래스 이름 : Wb_Ex1
 
2)클래스 파일 우클릭 
Open With - WindowBuilder Editor 클릭. 
편집창 하단에 Source 탭과 Design 탭이 표시. 

3)
 클래스 파일에  상속하는 JFrame 클래스 사용. 
 import javax.swing.JFrame;
 디자인탭 클릭. 
 
4)
windows builder 492  12/36
 
쉽게 UI 구성요소를 Drag&Drop 으로 디자인 할수 있음. 

5) 
좌측 상단의 Components 창에서 
(javax.swing.JFrame 항목을 선택하면 GUI 창에 표시되는 
크기 조절 핸들을 이용하여 다음과 같이 GUI 창의 사이즈를 조절 가능. 
)

컨테이너 : 설명 
JPanel : 경량 컨테이너로서 컴포넌트들을 소그룹 단위로 담아 놓을수 있다. 
JScrollPane : 화면 사이즈보다 많은 데이터를 보여주고자 하는 컴포넌트를 
감싸서 스크롤링이 되도록한다. 
JTabbedPane : 설정된 타이틀이나 아이콘 탭을 클릭하여 사용자가 
컴포넌트의 그룹을 교체 할수 있도록 하는 컴포넌트이다. 

6) 
좌측 상단의 Components 창에서 
javax.swing.JFrame - getContenttPane() 항목을 클릭 하면 
GUI  창의 레이아웃을 변경할수 있다. 
여기서는 기본 레이아웃(BoarderLayout)을 사용. 
클릭하고 오른쪽으로 클릭. 
 
창 디자인에 사용되는 기본  Layout 의 종류는 

레이웃 : 설명 
BoarderLayout :  GUI  창을 5개 영역 (동, 서, 남, 북 , 센터)으로 
나누어, 각 영역에 맞게 구성 요소의 크기 및 컨테이너를 배치한다. 
각 지역은  SOUTH , NORTH, EAST , WEST  그리고 CENTER 다섯 상수 
중 하나를 사용하며 컨테이너에 구성 요소를 추가할 때 사용한다. 

GridLayout : GUI  창을 행과 열로 컨테이너의 구성 요소를 배치하는 
레이아웃 매니저이다. 컨테이너는 설정한 행과 열에 의해 동일한 크기의 
사각형으로 분할되고, 하나의 구성 요소 (패널, 버튼등)는 각각의 사각형 영역에 
배치된다. 

CardLayout : 카드가 겹쳐지는 형태로 각 구성 요소를 처리한다. 
한번에 오직 하나의 카드만 볼수 있으며, 컨테이너는 카드의 스택으로서 
동작한다. 

FlowLayout : 한 방향으로 컴포넌트를 배치하며 일반적으로  Panel에 
버튼을 배치하는데 사용된다. 흐름 방향은 다음과 같이 ComponentOrientation
속성에 의해 결정된다. 
-ComponentOrientation.LEFT_TO_RIGHT
-ComponentOrientation.RIGHT_TO_LEFT
정렬 상수는 LEFT, RIGHT, CENTER, LEADING, TRAILING 이 있다. 

7) 이클립스의 중앙 하단 부분에서 
Components- JButton 을 클릭 한뒤에 마우스를 
오른쪽의 디자인 영역으로 이동. 
BoarderLayout   의 영역이 보이면 원하는 영역에 버튼을 배치.

예로 북쪽으로 배치. 

배치되면 
왼쪽의 Properties 창에서 text 항목의 값에 
North를 입력하여 버튼의 이름을 변경. 

8) 하단의 [Source]  탭을 선택하면 아래처럼 소스코드가 추가됨. 
package ch15.wb2;
import javax.swing.JFrame;
import java.awt.BorderLayout;
import java.awt.GridLayout;
import javax.swing.JButton;
public class Wb_Ex1 extends JFrame {
	public Wb_Ex1() {
		getContenttPane().setLayout(new BorderLayout(0, 0));
		
		JButton btnNewButton = new JButton("North");
		getContenttPane().add(btnNewButton, BorderLayout.NORTH);
	}

	public static void main(String[] args) {
System.out.println("Test~");


	}

}

9) 다시 [Design] 탭으로 이동해서 다음과 같이 
가상뷰 탭을 선택하면 가상뷰를 볼수 있다. 
(위에 상단에 2번째 아이콘 클릭시 컴파일이나 러닝 과정없이 볼수 있음. )


10) 실제 프로젝트를 실행하여 확인하려면 
main() 메소드가 있는 클래스에서 JFram을 상속하는 클래스의 
객체를 생성해주어야 화면으로 실행된다. 

화면 왼쪽의 
[Components]창에서 
"javax.swing.JFrame" 항목을 선택한 뒤에, 
왼쪽 아래의 "Properties"창에서 
"Show advanced properties"  도구 버튼을 클릭. 
[Size]항목을 선택하여 " width = 250" , "height = 300"으로 설정. 

[visible] 항목에서 "true "로 변경. 기본은 false 값. 
프로그램을 실행하면 GUI 창이 화면에 보이지 않을수 있다. 

[title]항목을 선택하여 GUI 창의 제목을 입력. 

이클립스의 패키지 탐색기 창에서 해당파일을 마우스 오른쪽 버튼으로 
선택하여 표시되는 단축 메뉴에서 
[Open With]-[Java Editor] 를 클릭. 

코드 창에서 
main() 메소드 에서 기본 생성자 생성문 추가하여 GUI 창의 객체를 생성. 
ex)
new Wb_Ex1();

실행. 
마우스 우클릭 [Run As] -[Java Application] 메뉴를 클릭하여 프로그램 실행.

결과, 콘솔 출력과 함께 GUI 창이 나타나면 성공. 

다음 표 GUI 창을 디자인할 때 자주 사용되는 컴포넌트의 기능을 설명.

컴포넌트 : 설명 
JButton : 버튼 이벤트를 받을 수 있다. 

JLabel :  짧은 텍스트 등을 표시하는 영역이다. 입력 이벤트에 반응하지 
않는다. 즉, 키보드 포커스를 얻을 수 없다. 

JTextField : 1개 행의 텍스트의 입력을 받는 컴퍼넌트이다. 

JTable : 일반적으로의 2차원 테이블의 셀을 편집하는데 사용된다. 
컬럼명은 1차원 배열, 데이터들은 2차원 배열을 담을수 있는 객체 
(예: DefaultTableModel)를 통해 테이블을 쉽게 구현할 수 있다. 

ButtonGroup : 여러 개의 버튼 중에 단일하게 선택하고 선택된 버튼은 
그룹의 모든 다른 버튼을 해제하도록 그룹화한다. 

JRadioButton : 여러 개의 버튼 중에 단일하게 선택하고 선택된 버튼은 
그룹의 모든 다른 버튼을 해제하도록 그룹화한다. 

JCheckBox : 여러 개의 체크 가능한 버튼 중에서 다중 항목을 선택하고자 할 때
사용된다. 

------------------------------------------------------------------------------------
4. 이벤트 처리 1

이벤트는 GUI  화면을 구성하는 버튼 등의 UI 컴포넌트에서 발생하는 어떤 
일을 의미한다. 예를 들면, 화면의 버튼을 클릭하거나 또는 더블클릭하거나 
하는 등의 동작이다. 개발자는 어떤 컴포넌트에서 어떤 일(이벤트,  event)
이 일어났는지를 구분하고 , 각 이벤트가 발생했을 때 무엇을 할 것인지를 소스 
코드로 나타내어야 한다. 이것을 이벤트 처리라고 한다. 

버튼 컴포넌트에서 사용 가능한 이벤트를 처리하는 방법을 다음 과정으로 
알아보기로 하자. 

1) [Components]창에서 디자인된 버튼 컴포넌트인 "btnNorth"
항목을 마우스 오른쪽 버튼으로 클릭하여 표시되는 단축 메뉴에서 
Add event handler - action - actionPerformed  메뉴를 클릭. 

참고, 디자인 창에 보이는 버튼에서 마우스 오른쪽 클릭해도 같은 메뉴.

다음은 이벤트의 종류와 해당 이벤트를 처리하는 메소드를 설명한 것이다. 
컴포넌트에 따라서 발생 가능한 이벤트의 종류가 달라질수 있고, 
이벤트 종류에 따라 처리하는 메소드가 달라 각 종류를 구분할 수 있어야 
한다. 

이벤트 : 설명 

addActionListener : ActionListener 인터페이스를 구현 
(implements)하거나 익명 클래스를 통해서  actionPerformed(ActionEvent e)
메소드를 오버라이딩해서 이벤트를 처리한다. 
(적용 예: JButton)

addMouseListener : MouseAdapter 클래스를 상속(extends) 하거나 
익명 클래스를 통해서 다음의 메소드 중 필요한 것을 오버라이딩해서 
이벤트를 처리한다. (적용 예 : JTable)

void mouseClicked(MouseEvent e)
void mouseDragged(MouseEven e)
void mouseEntered(MouseEven e)
void mouseExited(MouseEven e)
void mouseMoved(MouseEven e)
void mousePressed(MouseEven e)
void mouseReleased(MouseEven e)
void mouseWhellMoved(MouseEven e)

addChangeListener : ChangeListener 인터페이스를 구현 
(implements) 하거나 익명 클래스를 통해서  stateChanged(ChangeEvent e)
메소드를 오버라이딩해서 이벤트를 처리한다. 
(적용 예 : JSpinner)

2) 이벤트 처리를 추가한 뒤에 [Source] 탭으로 이동하여 
소스 코드를 확인하면, 다음처럼 이벤트 처리를 위한 코드가 추가됨을 확인. 
버튼 이벤트 상태를 확인하기 위해 이벤트가 발생했을 때 콘솔에 메시지를 
출력하도록 추가 작성. 

ex)
btnNewButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
			System.out.println("btn clicked...");
			}
		});

3) 실행. 우클릭 -Run As - Java Application 클릭하여 
프로그램을 실행 시킴. 
-------------------------------------------------------------------------
5. GUI 입력폼 만들기 

504 24/36

이름, 전화번호,  E-mail, 직업 정보를 입력받아 이벤트를 처리하는 프로그램을 
만들어보자.

1) 아래 그림처럼 GUI를 만들자. 

기본 Layout으로 5행 1열의 GridLayout을 사용한다. 각 행에 JPanel 을 
디자인하고, JPanel 의 Layout은 1행 2열로 구성되는 GridLayout을 사용한다. 
1행 부터 4행까지는 각 행에 디자인된 JPanel의 1열에 JLabel을 디자인하고,
2열에는 JTextField를 디자인한다.  5행에도 JPanel을 디자인하여 1행 2열로 
구성되는 GridLayout을 사용하고, 각 열에는 JButton을 디자인하여 
전체 UI를 디자인한다.
UI 창에 디자인된 [SEND ] 버튼과 [CNACEL]버튼에 이벤트(ActionListener)를 
등록하고 이벤트 처리(actionPerformed() 메소드) 코드를 입력한다. 

1) 프로젝트 유형 Java Project 로 하고 ,
 프로젝트 이름  Java_WB 생성. 
 패키지 : ch15.wb
 클래스 이름 : Wb_Ex2

package ch15.wb2;
import javax.swing.JFrame;
import java.awt.Dimension;
import java.awt.GridLayout;
import javax.swing.JPanel;
import javax.swing.JLabel;
import javax.swing.border.LineBorder;
import java.awt.Color;
import javax.swing.JTextField;
import javax.swing.JButton;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
public class Wb_Ex2 extends JFrame{ //JFrame 을 상속하는 클래스 정의
	private JTextField nameField; // 4개의 JTextField 객체 선언 
	private JTextField telField;
	private JTextField emailField;
	private JTextField jobField;
	public Wb_Ex2() { // 생성자 정의 
		setVisible(true); // 창이 보이도록 설정 
		setTitle("Wb_Ex2"); //창의 제목 설정
		getContenttPane().setSize(new Dimension(250, 300)); // 창의 크기 설정 
		getContenttPane().setLayout(new GridLayout(5, 1, 0, 0));
		//창의 기본 레이아웃 설정 
		
		JPanel namePanel = new JPanel(); //JPanel 객체 생성
		namePanel.setBorder(new LineBorder(new Color(0, 0, 0)));
		namePanel.setName("namePanel");
		getContenttPane().add(namePanel); //JPanel 객체를 창에 추가 
		namePanel.setLayout(new GridLayout(1, 2, 0, 0));
		// JPanel 객체의 레이아웃 설정 
		
		JLabel nameLabel = new JLabel("이름");  // JLabel 객체 생성 
		namePanel.add(nameLabel); // JLabel 객체를 JPanel에 추가 
		
		nameField = new JTextField(); //JTextField 객체 생성
		namePanel.add(nameField); //JTextField 객체를 JPanel에 추가 
		nameField.setColumns(10); // JTextField에서 입력 글자 수를 10자로 설정 
		
		JPanel telPanel = new JPanel(); //전화번호를 위한 영역 설정. 
		telPanel.setName("telPanel");
		telPanel.setBorder(new LineBorder(new Color(0, 0, 0)));
		getContenttPane().add(telPanel);
		telPanel.setLayout(new GridLayout(1, 2, 0, 0));
		
		JLabel telLabel = new JLabel("전화번호");
		telPanel.add(telLabel);
		
		telField = new JTextField();
		telField.setColumns(10);
		telPanel.add(telField);
		
		JPanel emailPanel = new JPanel(); //email 주소를 위한 영역 설정. 
		emailPanel.setName("emailPanel");
		emailPanel.setBorder(new LineBorder(new Color(0, 0, 0)));
		getContenttPane().add(emailPanel);
		emailPanel.setLayout(new GridLayout(1, 2, 0, 0));
		
		JLabel emailLabel = new JLabel("E-mail");
		emailPanel.add(emailLabel);
		
		emailField = new JTextField();
		emailField.setColumns(10);
		emailPanel.add(emailField);
		
		JPanel jobPanel = new JPanel(); //직업을 위한 영역 설정. 
		jobPanel.setName("jobPanel");
		jobPanel.setBorder(new LineBorder(new Color(0, 0, 0)));
		getContenttPane().add(jobPanel);
		jobPanel.setLayout(new GridLayout(1, 2, 0, 0));
		
		JLabel jobLabel = new JLabel("직업");
		jobPanel.add(jobLabel);
		
		jobField = new JTextField();
		jobField.setColumns(10);
		jobPanel.add(jobField);
		
		JPanel btnPanel = new JPanel();
		//버튼을 디자인하기 위한 JPanel 객체 생성 
		btnPanel.setName("btnPanel");
		getContenttPane().add(btnPanel); //JPanel 객체를 창에 붙이기 
		btnPanel.setLayout(new GridLayout(1, 2, 0, 0));
		// JPanel 객체의 레이아웃 설정 
		
		JButton btnSend = new JButton("SEND");
		// [SEND ] 버튼을 위한 JButton 객체 생성 
		btnSend.addActionListener(new ActionListener() {
		// JButton 객체에 이벤트 처리기 추가 
			public void actionPerformed(ActionEvent e) {
			// [SEND] 버튼을 클릭했을 때 이벤트 처리 내용 
 				System.out.println(nameField.getText());
				// JTextField 객체에 입력된 내용을 콘솔에 출력 
				System.out.println(telField.getText());
				System.out.println(emailField.getText());
				System.out.println(jobField.getText());
			}
		});
		btnPanel.add(btnSend); //JButton 을 JPanel에 붙이기 
		
		JButton btnCancel = new JButton("CANCEL");
		// [CANCEL ] 버튼을 위한 JButton 객체 생성 
		btnCancel.addActionListener(new ActionListener() {
		// JButton 객체에 이벤트 처리기 추가 
			public void actionPerformed(ActionEvent e) {
			// [CANCEL] 버튼을 클릭했을 때 이벤트 처리 내용 
				nameField.setText("");
				// JTextField 객체의 내용을 삭제 
				telField.setText("");
				emailField.setText("");
				jobField.setText("");
			}
		});
		btnPanel.add(btnCancel);
	}
public static void main(String[] args) {
	System.out.println("Window Builder Test");
	new Wb_Ex2();
}
}

6. 이벤트 처리 2 

1) 클래스 이름은 
 프로젝트 유형 Java Project 로 하고 ,
 프로젝트 이름  Java_WB 생성. 
 패키지 : ch15.wb
 클래스 이름 : Wb_Ex3
 
추가된 새 클래스의 코드에서 JFrame 클래스를 상속하도록 클래스 정의를 
수정하여 저장한 뒤에, 윈도우 빌더를 사용할수 있도록 한다. 

윈도우 빌더를 사용할 때 이클립스 창의 왼쪽에서 [Components]창의 노드 구조와
이클립스 창의 오른쪽에 보이는 미리보기 화면을 보면서 다음 그림과 같은 화면을 
디자인한다. 

기본 Layout은 1행 1열로 구성되는 GridLayout을 사용한다. 
이곳에 JTabbedPane을 디자인한다. 디자인된 JTabbedPane에 JPanel과 
JScrollPane을 추가한다. JPanel에는 Flowlayout을 설정하고, 
JScrollPane에는 JTable 컴포넌트를 추가한다. 

디자인된 JPanel에는 2개의 JRadioButton과 한개의 JSpinner 컴포넌트를 
디자인한다. 

2)"남" ,"여" 를 선택하는 라디오 버튼은 다음 그림처럼 "buttonGroup" 컴포넌트를 
이용하여 버튼 그룹으로 묶어 주어야 한다. 
[Components] 창에서 키보드 (Ctrl 키) 와 마우스를 이용하여 두개의 JRadioButton객체를 
선택하고, 선택된 컴포넌트에서 마우스 오른쪽 버튼을 클릭하면 표시되는 단축메뉴에서
[Set ButtonGroup] ->[buttonGroup ] 메뉴를 클릭한다. 

3) 라디오 버튼도 이벤트 처리 1에서 처럼 각각 라디오 버튼 컴포넌트를 마우스 오른쪽 
버튼으로 클릭하여 표시되는 단축 메뉴에서 
[Add event handler]- [action]-[actionPerformed]를 선택하여 이벤트 처리 코드를 
입력한다. 

코드 예제)

JRadioButton rdbtnX = new JRadioButton("남");
		rdbtnX.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				System.out.println(rdbtnX.getText());
			}
		});
		buttonGroup.add(rdbtnX);
		panel.add(rdbtnX);
		
		JRadioButton rdbtnY = new JRadioButton("여");
		rdbtnY.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				System.out.println(rdbtnY.getText());
			}
		});
		buttonGroup.add(rdbtnY);
		panel.add(rdbtnY);

4) JSpinner를 추가한 후 다음 그림처럼 스피너 컴포넌트에서 선택할수 있는 
목록을 변경할수 있다. JSpinner 컴포넌트의  model 속성에서 [...]
버튼을 클릭하면 편집할수 있다. 

예)
List  탭에서 
통신사
KT 
SKT 
추가하기. 

JSpinner 컴포넌트의 이벤트 처리는 다음 그림처럼 stateChanged 이벤트를 
처리하도록 한다. 

ex)
JSpinner spinner = new JSpinner();
		spinner.addChangeListener(new ChangeListener() { //이부분
			public void stateChanged(ChangeEvent e) {//이부분
				System.out.println(spinner.getValue());//이부분
			} //이부분
		});
		spinner.setModel(new SpinnerListModel(new String[] {"\uD1B5\uC2E0\uC0AC", "KT", "SKT"}));
		panel.add(spinner);

5 데이터를 표형식으로 표현하는 JTable  도 아래 그림처럼 추가해보자. 
JTable 데이터 행의 길이가 화면 높이보다 크면 JScrollPane을 먼저 추가한 후 
그 안에 JTable을 넣는다. 

6 JTable 의 이벤트는 mouseClicked()  메소드를 정의하여 처리한다. 

table.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				System.out.println("선택한 행번호:"+table.getSelectedRows());
			}
		});


전체 
package ch15.wb2;
import javax.swing.JFrame;
import java.awt.GridLayout;
import javax.swing.JTabbedPane;
import javax.swing.JPanel;
import javax.swing.JRadioButton;
import javax.swing.JSpinner;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.ButtonGroup;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import javax.swing.SpinnerListModel;
import javax.swing.event.ChangeListener;
import javax.swing.event.ChangeEvent;
import javax.swing.table.DefaultTableModel;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

public class Wb_Ex3 extends JFrame{
	public static void main(String[] args) {
		new Wb_Ex3();
	}
	private final ButtonGroup buttonGroup = new ButtonGroup();
	private JTable table;
	public Wb_Ex3() {		
	    setVisible(true); // 창이 보이도록 설정 
		setTitle("Wb_Ex3\r\n");
		getContenttPane().setLayout(new GridLayout(1, 1, 0, 0));
		
		JTabbedPane tabbedPane = new JTabbedPane(JTabbedPane.TOP);
		getContenttPane().add(tabbedPane);
		
		JPanel panel = new JPanel();
		tabbedPane.addTab("선택화면 탭\r\n", null, panel, null);
		
		JRadioButton rdbtnX = new JRadioButton("남\r\n");
		rdbtnX.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				System.out.println(rdbtnX.getText());
			}
		});
		buttonGroup.add(rdbtnX);
		panel.add(rdbtnX);
		
		JRadioButton rdbtnY = new JRadioButton("여\r\n");
		rdbtnY.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				System.out.println(rdbtnY.getText());
			}
		});
		buttonGroup.add(rdbtnY);
		panel.add(rdbtnY);
		
		JSpinner spinner = new JSpinner();
		spinner.addChangeListener(new ChangeListener() {
			public void stateChanged(ChangeEvent e) {
				System.out.println(spinner.getValue());
			}
		});
		spinner.setModel(new SpinnerListModel(new String[] {"\uD1B5\uC2E0\uC0AC", "KT", "SKT"}));
		panel.add(spinner);
		
		table = new JTable();
		table.setModel(new DefaultTableModel(
			new Object[][] {
				{"1", "email1", "1234"},
				{"2", "email2", "1234"},
				{"3", "email3", "1234"},
			},
			new String[] {
				"New column", "New column", "New column"
			}
		));
		tabbedPane.addTab("테이블 탭", null, table, null);
	}

}
518 2/11
람다 표현식 

람다 표현식을 사용하면 복잡한 메소드들을 나열하지 않아도 계산을 간결한 
코드 조각(함수이름없음)으로 처리하는 함수형 프로그래밍이 가능하다. 

그래서, 컬렉션 라이브러리가 더욱 풍부해졌고, 새로운 스트림 API를 
부담없이 사용할수 있게 되고, 병렬 처리도 쉽게 할수 있다. 

사용되는 방법 
1) Interface 를 이용하는 익명 클래스 처리 방법 
2) 람다 표현식으로 처리한 방법 
비교하기. 

ex) 
interface Xyz { // interface 정의 
public void a();
}
..

// Xyz 인터페이스를 사용하기 위한 익명 클래스의 일반적인 표현식. 

Xyz xxx = new Xyz() {
@Override
public void a() { // interface 에 정의된 a() 메소드를 오버라이딩 
System.out.println("a");
}
};

xxx.a(); // 이름 없는 클래스에 정의된 a() 메소드 호출 

//람다 표현식 
Xyz xxx2 = () -> System.out.println("a"); 
// 람다식으로  a() 메소드를 오버라이딩 
xxx2.a(); 
// 람다식을 이용하여 정의된 a() 메소드 호출 .

람다 표현식은 익명 클래스와 오버라이딩 해야하는 a() 메소드 대신에 
익명 클래스와 메소드명을 모두 생략한 "() "로 표현된다. 
그리고 " -> " 형식을 사용하여 오버라이딩해야 하는 메소드의
구현 코드를 작성한다. 

인자가 있는 경우의 람다 표현식.

ex2) 
interface Xyz { // interface 정의 
public void a(int x, int y);
}
..

// Xyz 인터페이스를 사용하기 위한 익명 클래스의 일반적인 표현식. 

Xyz xxx = new Xyz() {
@Override
public void a(int x, int y);{ // interface 에 정의된 a() 메소드를 오버라이딩 
System.out.println("x+y="+(x+y));
}
};

xxx.a(10,20); // 이름 없는 클래스에 정의된 a() 메소드 호출 

//람다 표현식 
Xyz xxx2 = (x, y) -> System.out.println("x+y="+(x+y));
// 람다식으로  a() 메소드를 오버라이딩 
xxx2.a(10,20); 
// 람다식을 이용하여 정의된 a() 메소드 호출 .

람다 표현식은 익명 클래스와 오버라이딩 
a(int x, int y)  메소드 대신에 익명 클래스와 메소드명을 모두 생략하고 
인자 x와 y를 가지 "(x,y)"로 표현된다. 
그리고 
"-> "형식을 사용하여 오버라이딩 해야 하는 메소드의 구현 코드를 작성한다. 

---------------------------
실습하기 16-1 
패키지명 : ch16.lamda
클래스 이름 :  Lambda_ex1

익명 클래스 처리 방식과 람다 표현식 비교 1

package ch16.lamda;

interface Xyz { // interface 정의 
public void a();
}

public class Lambda_ex1 {
	public static void main(String[] args) {
	
		// 1 . 익명 클래스 이용
		Xyz xxx = new Xyz() {
			@Override
			public void a() { // interface 에 정의된 a() 메소드를 오버라이딩 
			System.out.println("익명 클래스 이용");
			}
			};

			xxx.a(); // 이름 없는 클래스에 정의된 a() 메소드 호출 

			//람다 표현식 
			Xyz xxx2 = () -> System.out.println("람다 표현식 "); 
			// 람다식으로  a() 메소드를 오버라이딩 
			xxx2.a(); 
			// 람다식을 이용하여 정의된 a() 메소드 호출 .

	}

		
	}
	
//
익명 클래스 이용
람다 표현식 

---------------------------
실습하기 16-2
패키지명 : ch16.lamda
클래스 이름 :  Lambda_ex2

package ch16.lamda;

interface Xyz_Param { // interface 정의 
public void a(int x, int y);
}

public class Lambda_ex2 {
	public static void main(String[] args) {
	
		// 1 . 익명 클래스 이용
		Xyz_Param xxx = new Xyz_Param() {
			@Override
			public void a(int x , int y) { // interface 에 정의된 a() 메소드를 오버라이딩 
			System.out.println("익명 클래스 " + (x+y));
			}
			};

			xxx.a(10,20); // 이름 없는 클래스에 정의된a(int x , int y) 메소드 호출 

			//람다 표현식 
			Xyz_Param xxx2 = (x,y) -> System.out.println("람다 표현식"+(x+y)); 
			// 람다식으로  a() 메소드를 오버라이딩 
			xxx2.a(10,20); 
			// 람다식을 이용하여 정의된 a() 메소드 호출 .

	}

		
	}

//
익명 클래스 30
람다 표현식30

---------------------------
실습하기 16-3
패키지명 : ch16.lamda
클래스 이름 :  Lambda_ex3

Comparator 인터페이스를 활용하여 컬렉션에 저장된 사용자 클래스를 
정렬(sort)할 때 람다 표현식으로 처리하는 예제이다. 


package ch16.lamda;

public class Lambda_ex3 {

	private Integer num;
	private String name;
	private Integer kor;
	private Integer eng;
	private Integer math;
	
	public Lambda_ex3() {}

	public Lambda_ex3(Integer num, String name, Integer kor, Integer eng, Integer math) {
		super();
		this.num = num;
		this.name = name;
		this.kor = kor;
		this.eng = eng;
		this.math = math;
	}

	public Integer getNum() {
		return num;
	}

	public void setNum(Integer num) {
		this.num = num;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Integer getKor() {
		return kor;
	}

	public void setKor(Integer kor) {
		this.kor = kor;
	}

	public Integer getEng() {
		return eng;
	}

	public void setEng(Integer eng) {
		this.eng = eng;
	}

	public Integer getMath() {
		return math;
	}

	public void setMath(Integer math) {
		this.math = math;
	}
	public String toString() {
		return num + ":"+ name + ":" + kor + ":" + eng + ":"+math;
	}
	
}

---------------------------
실습하기 16-3
패키지명 : ch16.lamda
클래스 이름 :  Lambda_ex3_1

package ch16.lamda;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class Lambda_ex3_1 {

	static List<Lambda_ex3> studentsList = new ArrayList<>();
	static {
		studentsList.add(new Lambda_ex3(3,"KIM",70,70,70));
		studentsList.add(new Lambda_ex3(1,"LEE",80,80,80));
		studentsList.add(new Lambda_ex3(2,"YANG",90,90,90));
		studentsList.add(new Lambda_ex3(4,"IN",100,100,100));
		System.out.println("정렬전 : " + studentsList);
	}
	
	public static void main(String[] args) {
		
		
		 // 1. 익명 클래스 이용
		  Collections.sort(studentsList, new Comparator<Lambda_ex3>(){
		 @Override
		  public int compare(Lambda_ex3 o1, Lambda_ex3 o2) {
		  return o1.getNum() - o2.getNum();
		 }
		  });
		 
		//2. 람다 표현식 이용 
  Collections.sort(studentsList, (Lambda_ex3 o1, Lambda_ex3 o2) -> o1.getNum() - o2.getNum());
  System.out.println("정렬 후 : "+ studentsList);
	}
	
}
//
정렬전 : [3:KIM:70:70:70, 1:LEE:80:80:80, 2:YANG:90:90:90, 4:IN:100:100:100]
정렬 후 : [1:LEE:80:80:80, 2:YANG:90:90:90, 3:KIM:70:70:70, 4:IN:100:100:100]

----------------------------------
람다 표현식 변환 
이클립스에서  람다 표현식으로 변환 가능한 부분을 자동으로 변환할수 있다. 
소스 코드에서 람다 표현식으로 변환할 부분에 해당하는 영역
(예에서는 "new Comparator<Lambda_ex3>()" 부분)을 마우스로 드래그하여 
선택한 뒤에 단축키 ctrl + 1 -[ 
Convert to lambda expression을 선택하면 간단히 변환. 
!

---------------------------
실습하기 16-4
패키지명 : ch16.lamda
클래스 이름 :  Lambda_ex4

익명 클래스를 통한 메서드 처리는 다음과 같이 스레드 처리에서도 
간단히 할수 있다. 

package ch16.lamda;

public class Lambda_ex4 {

	public static void main(String[] args) {
		
		System.out.println("Anonymous 표현 ");
		new Thread() {
			public void run() {
				while(true) {
					try {
						Thread.sleep(1000);
						System.out.println("Anonymous..."+ System.currentTimeMillis());
					}catch(InterruptedException e) {
						e.printStackTrace();
					}
				}
			}
		}.start();

		System.out.println("Lambda 표현식");
		new Thread (() -> {
			while(true) {
				try {
					Thread.sleep(1000);
					System.out.println("Lambda..."+System.currentTimeMillis());
				}catch(InterruptedException e) {
					e.printStackTrace();
				}
			}
		}).start();
		
	}

}
//
Anonymous 표현 
Lambda 표현식
Anonymous...1558688796251
Lambda...1558688796268
Anonymous...1558688797251
Lambda...1558688797268
Anonymous...1558688798252
Lambda...1558688798269

------------------------------

17장 네트워크
학습목표 
-네트워크 개요에 관하여 학습한다. 
-InetAddress 클래스의 메소드와 사용법에 관하여 학습한다. 
-URL 클래스의 메소드와 사용법에 관하여 학습한다. 
-URLConnection 클래스의 메소드와 사용법에 관하여 학습한다. 
-URLEncoder 클래스의 메소드와 사용법에 관하여 학습한다. 
-Socket 클래스와 ServerSocket 클래스의 메소드와 사용법에 관하여 학습한다. 

1.네트워크 
2.InetAddressn 클래스 
3.URL 클래스 ]
4.URLConnection 클래스 
5.URLEncoder 클래스 
6.Socket 클래스 
7.ServerSocket 클래스 
8. 채팅 프로그램.

---------------------------------------------

1.네트워크 
530 2/21

1.1 네트워크 정의 

네트워크는 미리 정의된 규약 (protocol)으로 정보를 주고받는 하드웨어와
소프트웨어 기반의 시스템을 의미한다 

하드웨어로는 네트워크 카드와 케이블 같은 연결 장치가 있고 소프트웨어로는
ftp, http, 등 여러 가지 프로토콜을 기반으로 하는 통신 프로토콜을 기반으로 
하는 통신 프로그램들이 있다. 

1.2 인터넷 과 프로토콜

네트워크 프로그래밍에서 가장 일반적이면서 자주 사용되는 용어인 인터넷 
(Internet), 프로토콜(protocol) 그리고 IP 주소 (Internet Protocol Address)
에 대해 알아보자. 

(1) 인터넷 (internet)
여러가지 프로토콜(통신 규약) 중에서 TCP/IP 프로토콜을 기반으로 하는 
네트워크를 의미한다. 

(2) 프로토콜(protocol) 
네트워크상에 있는 여러 개체 간의 데이터 교환을 관리하는 
통신 규약을 의미한다. 

(3) IP 주소 
모든 컴퓨터는 IP 주소라고 하는 32 비트 또는 128비트로 구성된 주소 
체계를 사용하여 구별한다. 32비트 체계를 IPv4 라고 하며 128비트 체계를 
IPv6라고 한다. IPv4는 32비트 숫자를 8비트씩 끊어서 표현하고 각 자리는 
0~255 까지의 범위를 가진다. IPv6는 128 비트 숫자를 16비트씩 8부분으로 
나누어 16진수로 표현한다. 

1.3 TCP/IP 와 UDP
현재 네트워크에서 사용되고 있는 두가지 대표적인 프로토콜을 
구분한다. 

(1) TCP/IP 
TCP는 IP 의 상위 프로토콜로서 접속 기반(Connection based) 전송 프로토콜이다. 
신뢰성이 있고 연결 지향적이다. 포트 번호를 사용하여 다중 송수신을 지원한다. 
예를 들면 웹에서 사용되는 HTTP , 이메일 전송을 위한 SMTP 등 여러 기능을 
하나의 서버에서 동시에 클라이언트에게 서비스할수 있다. 

TCP 전송에서 전송되는 데이터들은 번호가 부여되기 때문에 도착 순서에 
상관없이 자동으로 순서를 정렬해 준다. 또한, Checksum 을 사용하여 
데이터의 무결성을 확인할 수 있다. 

TCP에서는 전송 지연 알고리즘을 사용하여 대역폭을 제한할수도 있다. 
이를 통하여 네트워크에 부하가 많이 생겼을 때 과다한 데이터가 전송되지 
않도록 조절할수도 있다. 

또한, TCP는 데이터를 동시에 전송하고 받을 수 있는 구조로 되어 있다. 

(2) UDP 
UDP 는 비연결성 통신 방식으로 전송된다. 또한, 네트워크를 통해서 전달되는 
데이는 반드시 순서에 맞게 도착해야 하고 훼손되거나 중복되지 않아야 한다. 
Checksum 같은 기본적인 기능 이외의 데이터 무결성을 위한 기능이 
포함되지 않는다. 

UDP는 TCP 보다 신뢰성이 떨어지는 단점이 있지만, 네트워크에 부담을 
적게 준다는 것이 UDP의 장점이다. 

UDP는 TCP 처럼 연결 상태가 아닌 일방적으로 상대방에서 정보를 보내는 
응용분야에 많이 사용된다. 대표적으로 게임, 채팅 같은 곳에서 많이 사용 된다. 

1.4 소켓(Socket) 과 포트(port) 
네트워크의 소켓은 컴퓨터가 연결된 통신의 끝을 의미한다. 데이터를 입출력하기
위해 통신하려는 두개의 프로그램 사이에 채널(통로)이 형성되고, 이 채널을 
통해서 양방향 통신이 이루어진다. 이러한 채널을 생성하기 위해서 서버 프로그램은 
자신의 포트 번호를 통해 들어오는 클라이언트 요청을 계속 감시하게 되며 
클라이언트의 요청이 포트 번호를 통해 들어왔을 때 이를 받아 해당 
서비스를 수행하게 된다. 

532 4/21

이렇게 서버 프로그램과 클라이언트 프로그램은 각각 사용하는 소켓을 연결함으로써 
하나의 논리적인 채널을 생성하고 이를 이용하여 데이터를 입출력한다. 

포트 번호 중에서 0부터 1,023 사이의 번호는 시스템에서 사용하도록 예약되어 
있으며, 1,024 부터 65,536 까지의 포트번호는 사용자가 임의로 사용 할수 있다. 

대표적인 시스템이 예약한 포트 번호. 
FTP 21, TELNET 23, SMTP 25 , HTTP 80 

-------------------------------------------------------
2 InetAddress 클래스 

자바에서 IP 주소를 사용할 수 있는 기능을 제공하는 클래스이다. 
다음은 주요 메소드이다. 

메소드 : 설명 
getAddress() : InetAddress 클래스가 가지고 있는 IP 주소의 byte 배열을 얻는다. 

getHostAddress() : IP 주소를 문자열로 나타낸다. 

getHostName() : 객체가 가지는 호스트 이름을 문자열로 나타낸다. 

getByName(String host) : 주어진 이름을 갖는 호스트의 IP 주소를 얻는다. 

getAllByName(String host) : 주어진 이름을 갖는 호스트의 IP 주소들를 얻는다. 

getLocalhost() : 현재 시스템의 호스트 IP 주소를 얻는다. 

----------------
17-1 InetAddress 클래스 사용하기 

 프로젝트 유형 Java Project 로 하고 ,
 프로젝트 이름  Java_Network 생성. 
 패키지 : ch17.Network
 클래스 이름 : Network_ex1
 
import java.net.InetAddress;
public class Network_ex1 {
public static void main(String [] args) {
try {
String name = "www.google.co.kr";
// 요청하고자 하는 도메인명을  String에 저장한다.

InetAddress inetAddr = InetAddress.getByName(name);
// 요청 도메인에 대한 정보를 가진 InetAddress 클래스를 얻어온다.

String hostName = inetAddr.getHostName();
String hostAddress = inetAddr.getHostAddress();
System.out.println(hostName + "" + hostAddress);
//getHostName() 메소드와 getHostAddress() 메소드를 사용하여 호스트명과 
//호스트 주소를 얻는다. 

InetAddress localHost = InetAddress.getLocalHost();
//로컬(현재 자신의 컴퓨터) 컴퓨터의 네트워크 정보를 얻기 위해서 
//getLocalHost() 메소드를 호출한다. 


String localName = localHost.getHostName();
String localAddress = localHost.getHostAddress();
System.out.println(localName + "" + localAddress);
//로컬의 호스트명과 호스트 주소를 얻는다. 

byte [] b = localHost.getAddress();
// 로컬의 호스트 주소를 byte 배열로 얻는다. 
//자바의 byte 값은 -128~ 127 값을 갖게 되므로 
// 0~255 사이 값으로 변환해야 한다.
// 음수일 때 변환 작업 수행. 


for ( int x =0; x < b.length ; x++){
System.out.print(((b[x] < 0 ) ? (b[x] + 255) : b[x] )+ ".");
}
}catch (Exception e) { e.printStackTrace();}
}
}
//pc 마다 다름 
www.google.co.kr 172.217.25.227
itwill 192.168.56.1
191.167.56.1.


533 5/21

URL 클래스 

URL 클래스는 Uniform Resource Locator 의 약자로서 World Wide Web 
(일반적으로 웹(web)으로 부름)상의 '자원'들을 
사용하기 위한 포인터 역학을 하는 클래스이다.

여기서 자원은 파일, 디렉토리 또는 데이터베이스의 Query와 다양한 
형식의 객체가 될수 있다. 

URL 은 형식 
http://www.abc.co.kr:80/network/index.html 
- http를 protocol이라고 한다. 
- www.abc.co.kr 을 host 라고 한다. 
- 80 을 port 번호라고 한다. 
- network/index.html 을 path 라고 한다. 

실습하기 17-2 
URL 클래스 사용하기 

 프로젝트 유형 Java Project 로 하고 ,
 프로젝트 이름  Java_Network 생성. 
 패키지 : ch17.Network
 클래스 이름 : Network_ex2
 
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;

public class Network_ex2 {
public static void main(String[] args) {

BufferedReader buffer = null;
try {
URL url = new URL("http://www.naver.com");
//요청한 도메인의 위치를 얻기 위해서 해당 
//도메인을 인자로 하여 URL 객체를 생성한다. 

InputStream in = url.openStream();
// URL 객체로부터 InputStream 객체를 얻기 위해서 openStream()
//메소드를 호출한다. 

InputStreamReader reader = new InputStreamReader(in);
buffer = new BufferedReader(reader);
String s = buffer.readLine();
while(s != null){
System.out.println(s);
s = buffer.readLine();
}// end while
// Filter 계열의 InputStreamReader 와 BufferedReader 클래스를 
// 이용하여 요청 도메인 (www.naver.com)의 기본 (홈페이지) 
//파일을 읽어, 해당 파일의 내용인 HTML 정보를 콘솔에 출력한다. 

}catch(Exception e) {
e.printStackTrace();
}finally{
try {
buffer.close();
}catch(IOException e) {
e.printStackTrace();
}
}
}
}

//
<html>
<head><title>302 Found</title></head>
<body bgcolor="white">
<center><h1>302 Found</h1></center>
<hr><center> NWS </center>
</body>
</html>

실습하기 17-3 
URL 클래스 메타 정보 출력하기 

 프로젝트 유형 Java Project 로 하고 ,
 프로젝트 이름  Java_Network 생성. 
 패키지 : ch17.Network
 클래스 이름 : Network_ex3
 
import java.net.URL; 

public class Network_ex3 {
try {
URL url = new URL("http://www.google.co.kr/index.html");
//요청한 도메인의 위치를 얻기 위해서, 해당 도메인을 인자로 하여 
//URL 객체를 생성한다. 

System.out.println(url.getProtocol());
//요청한 도메인의 프로토콜 정보를 얻기 위해서 getProtocol() 메소드를 호출.

System.out.println(url.getDefaultPort());
//요청한 도메인의 기본 포트 정보를 얻기 위해서 getDefaultPort() 메소드를 호출.

System.out.println(url.getHost());
//요청한 도메인의 호스트 정보를 얻기 위해서 getHost() 메소드를 호출한다. 

System.out.println(url.getFile());
// 요청한 파일 자원의 정보를 얻기 위해서 getFile() 메소드를 호출한다. 

}catch(Exception e){
e.printStackTrace();
}
}
}

//
http
80
www.google.co.kr
/index.html

4 URLConnection  클래스 

URLConnection 클래스는 URL 객체와 애플리케이션 간의 통신을 
담당하는 클래스이다. 원격 자원의 속성 정보를 얻거나 연결된 상태에서 
원격지 파일을 읽는 등 다양한 기능의 메소드를 제공한다. 

다음은 주요 메소드이다. 

메소드 : 설명 

URL getURL() :  해당 URLConnection 객체 지정된 URL을 반환한다. 

boolean getDoInput() : URLConnection 객체가 입력용인지 아닌지를 반환한다. 

void setDoInput(boolean) : URLConnection 객체가 입력용으로 사용할 것인지를 
설정한다. 

boolean getDoOutput() : URLConnection 객체가 출력용인지 아닌지를 반환한다. 

boolean getAllowUserInteraction() : URLConnection 객체가 사용자 입력 유무를 
검사한다. (기본은 허용하지 않는다.)

boolean getUseCaches() : URLConnection 객체가 캐시 데이터를 사용하는지의 
여부를 반환한다. 기본은 true 이다. 

String getRequestProperty(String key) : 매개변수로 들어온 요청 프로퍼티인 
key 에 해당되는 값을 String 으로 리턴한다. 

long getIfModifiedSince() : 설정된 시간값을 반환한다. 

String getHeaderFieldKey(String name) : 매개변수의 name은 응답 헤더이며, 
이 응답 헤더에 해당하는 필드값을 반환한다. 

int getContentLength() : content-length 응답 헤더의 값을 반환한다. 
!
실습하기 17-4 
URLConnection 클래스 사용하기  

 프로젝트 유형 Java Project 로 하고 ,
 프로젝트 이름  Java_Network 생성. 
 패키지 : ch17.Network
 클래스 이름 : Network_ex4
 !
 
import java.net.URL;
import java.net.URLConnection;
import java.util.Date;

public class Network_ex4 {
	public static void main(String[] args) {
	
try{
URL url = new URL ("http://www.google.co.kr/ig/images/weather/sunny.gif");
// 도메인을 인자로 하여 해당하는 URL 객체를 생성한다. 

URLConnection con = url.openConnection();
// URL 객체의 openConnection() 메소드를 호출하여 URLConnection 객체를 
//리턴 받는다.

con.connect();
//URLConnection 객체의 connect() 메소드를 이용하여 원격지의 파일에 연결한다. 

System.out.println("문서의 타입 : "+ con.getContenttType());
System.out.println("마지막 수정일자 :  "+
new Date(con.getLastModified()));
int len = con.getContentLength();
System.out.println("문서의 길이 : "+ len + " 바이트");
// 다양한 메소드를 사용하여 원격지에 있는 파일의 정보를 출력한다. 

}catch(Exception e){e.printStackTrace();}	
}
}
//
문서의 타입 : text/html; charset=UTF-8
마지막 수정일자 :  Thu Jan 01 09:00:00 KST 1970
문서의 길이 : 221 바이트


5 URLEncoder 클래스 

문자열을 "x-www-form-urlencoded" 라고 불리는 MIME 형식으로 
변환하기 위한 클래스이다. 주로 웹 서버에 한글로 표시되는 쿼리 문자열을 
요청할 때 사용된다. 

변환 규칙은 다음과 같다. 

-아스키 문자('a-z', 'A-Z', 0-9)는 그대로 변환 
- 공백 문자는 + 기호로 변환
- 기타 문자는 % 가 붙은 총 3개의 문자로 변환 

실습하기 17-5 
URLEncoder 클래스 사용하기  

 프로젝트 유형 Java Project 로 하고 ,
 프로젝트 이름  Java_Network 생성. 
 패키지 : ch17.Network
 클래스 이름 : Network_ex5
 !

539 11/21

package ch17.Network;

import java.net.URLDecoder;
import java.net.URLEncoder;

public class Network_ex5 {

public static void main(String[] args){
try {
String original = "[Java Solution : 홍길동]";
// 인코딩할 문자열을 저장한다. 

String encodeStr = URLEncoder.encode(original, "EUC-KR");
// URLEncoder 클래스의 encode 메소드를 이용하여 요청 문자열을 인코딩한다. 

String decodeStr = URLDecoder.decode(encodeStr, "EUC-KR");
// URLEncoder 클래스의 decode 메소드를 이용하여 인코딩된 문자열을 
//디코딩하여 원래의 문자열로 변환되는지 확인한다. 

System.out.println(original);
System.out.println(encodeStr);
System.out.println(decodeStr);

}catch(Exception e) {
e.printStackTrace();
}

}
}

//
[Java Solution : 홍길동]
%5BJava+Solution+%3A+%C8%AB%B1%E6%B5%BF%5D
[Java Solution : 홍길동]

----------------------------------------------------------------------
6 Socket 클래스 

소켓이란 통신을 하기 위해서 사용되는 TCP 포트를 의미하여 클라이언트는 
Socket 클래스를 사용하여 원격 호스트에 대한 I/O 기반의 통신 상태를 
구축하게 된다. 

다음은 Socket 클래스의 주요 메소드이다. 

메소드 : 설명 

void close() : 소켓 객체를 닫는다. 

InetAddress getInetAddress() : 소켓 객체를 InetAddress 객체로 반환한다. 

InputStream getInputStream() : 소켓 객체로부터 입력할 수 있는 
InpuStream 객체를 반환한다. 

InetAddress getLocalAddress() : 소켓 객체의 로컬 주소를 반환한다. 

int port() : 소켓 객체의 포트 번호를 반환한다. 

void setSoTimeout(int t) : 소켓 객체의 시간을 밀리세컨드 단위로 설정한다. 

-------------------------------------------

7 ServerSocket 클래스 

541 13/21

클라이언트의 Socket에 대응되는 원격 호스트의 소켓을 의미한다. 
ServerSocket 클래스는 accept() 메소드를 통해 클라이언트의 요청을 
받아들인다. 

다음은 ServerSocket 클래스의 주요 메소드이다. 

메소드 : 설명 
void close() : ServerSocket 객체를 닫는다. 
int getLocalPort() : ServerSocket 객체에 설정된 포트 번호를 반환한다. 
Socket accept() : 클라이언트의 요청을 기다리는 메소드이다. 

실습하기 17-6
Socket을 이용한 통신하기  

 프로젝트 유형 Java Project 로 하고 ,
 프로젝트 이름  Java_Network 생성. 
 패키지 : ch17.Network
 클래스 이름 : Network_ex6
 !
 
import java.net.*;
import java.io.*;
public class Network_ex6 {

public static void main(String[] args) {
ServerSocket s = null;
//5432 포트를 이용하여 클라이언트가 접속하도록 
//ServerSocket 클래스를 생성한다. 

try {
s = new ServerSocket(5432);
}catch(Exception e) {e.printStackTrace();}
try {
while(true){
//일반적으로 서버는 항상 실행 중이어야 하기 때문에 
//무한루프로 실행시킨다. 

Socket s1 = s.accept();
//accept() 메소드를 사용하여 클라이언트가 접속하기를 기다린다. 
//클라이언트가 접속이 되면 ServerSocket은 내부적으로 Socket 객체를 
//하나 생성하여 클라이언트가 접속한 Socket을 대응하는 역할을 맡긴다. 

OutputStream os = s1.getOutputStream();
ObjectOutputStream oos = new ObjectOutputStream(os);
oos.writeObject("Hello World");
// 클라이언트에게 "Hello World"문자열을 출력시키기 위해서 
//OutputStream을 얻고 filter 계열인 ObjectOutputStream 클래스의 
//writeObject 메소드를 이용하여 데이터를 출력시킨다. 

oos.close();
s1.close();
//사용된 자원을 해제한다. 

}
}catch(Exception e) { e.printStackTrace();}
}
}

실습하기 17-6-2
Socket을 이용한 통신하기  

 프로젝트 유형 Java Project 로 하고 ,
 프로젝트 이름  Java_Network 생성. 
 패키지 : ch17.Network
 클래스 이름 : Network_ex6_2

import java.net.*;
import java.io.*;
public class Network_ex6_2 {

public static void main(String[] args) {

try {
Socket s1 = new Socket("localhost",5432);
//서버 ip 주소와 5432 포트를 이용한 Socket 클래스를 생성한다.

InputStream is = s1.getInputStream();
ObjectInputStream ois = new ObjectInputStream(is);
System.out.println(ois.readObject());
//서버에서 출력시킨 데이터를 입력하기 위해서 InputStream을 얻는다. 
//filter 계열인 ObjectInputStream 클래스의 readObject 메소드를 
//이용하여 데이터를 입력 받는다. 

ois.close();
is.close();
s1.close();
//사용된 자원을 해제한다. 

}catch(Exception e) {e.printStackTrace();}
}
}

// 둘다 다 보임. 
Hello World

-----------------------------------------

8 채팅 프로그램 

서버와 클라이언트 간의 1:1 채팅이 가능한 프로그램. 

실습하기 17-7 Socket을 이용한 채팅 프로그램 개발하기 

채팅 프로그램의 화면 구성은 AWT로 구성되어 있으며 서버와 클라이언트 
간의 일대일 채팅만 가능하다. 

프로젝트 유형 Java Project 로 하고 ,
 프로젝트 이름  Java_Network 생성. 
 패키지 : ch17.Network
 클래스 이름 : Network_ex7_Chat_Server
 !

import java.net.*;
import java.io.*;
import java.awt.*;
import java.awt.event.*;

public class Network_ex7_Chat_Server extends Thread implements ActionListener {
//Thread 클래스를 상속 받고 ActionListener 인터페이스를 구현하는 
// Network_ex7_Chat_Server 클래스를 정의한다. 

Frame frame;
TextArea ta;
TextField tf;
ServerSocket s;
Socket s1;
DataOutputStream dos;
DataInputStream dis; 
boolean stop;
// 필요한 변수를 정의.

public Network_ex7_Chat_Server() {
launchFrame();
service();
}
// 생성자 안에서 launchFrame() 메소드와 service() 메소드를 호출한다. 

public void launchFrame(){
frame = new Frame("일대일 채팅실습");
ta = new TextArea();
tf = new TextField();
frame.setBackground(Color.lightGray);
ta.setEditable(false);
frame.add(ta, BorderLayout.CENTER);
frame.add(tf, BorderLayout.SOUTH);
tf.addActionListener(this);
frame.setSize(500,300);
frame.setVisible(true);
tf.requestFocus();
}
// 변수에 대한 객체를 생성한다. 

public void service() {
try{
ta.append("서비스 하기 위해 준비중..\n");
s = new ServerSocket(5432);
// 5432 포트 번호를 가진 ServerSocket 클래스의 객체를 생성한다. 

ta.append("클라이언트 접속 대기중..");
s1 = s.accept();
// accept() 메소드를 이용해서 클라이언트의 요청을 기다린다. 

ta.append("클라이언트가 접속하였습니다. : "+s1.getInetAddress() + "\n");
dos = new DataOutputStream(s1.getOutputStream());
dis = new DataInputStream(s1.getInputStream());
// InputStream과 OutputStream 객체를 생성한다. 

this.start();
// 스레드를 start() 메소드로 호출한다. 

dos.writeUTF("채팅 서버에 접속하신걸 환영합니다.");
}catch(IOException e) { e.printStackTrace();}
}

public static void main(String[] args){
new Network_ex7_Chat_Server();
}

public void actionPerformed(ActionEvent action){
//텍스트 필드에 대한 이벤트 처리를 위해 
//actionPerformed() 메소드를 구현한다. 

try {
String msg = tf.getText();
ta.append(msg +"\n");
if(msg.equals("exit")){
ta.append("bye");
stop = true;
dos.close();
s1.close();
System.exit(0);
}else{
dos.writeUTF("서버 : "+ msg);
tf.setText("  ");
}
}catch(IOException e){
ta.append(e.toString() + "\n");
}
}

public void run() {
try{
while(!stop){
ta.append(dis.readUTF() + "\n");
}
//stop 변수가 true 가 될 때까지 클라이언트에서 
//전송된 데이터를 입력받는다. 

dis.close();
s1.close();
}catch(EOFException e){
ta.append("클라이언트로부터 연결이 끊어졌습니다. \n");
}catch(IOException e1){
e1.printStackTrace();
}
}
}

 
 

프로젝트 유형 Java Project 로 하고 ,
 프로젝트 이름  Java_Network 생성. 
 패키지 : ch17.Network
 클래스 이름 : Network_ex7_Chat_Client
 !

import java.net.*;
import java.io.*;
import java.awt.*;
import java.awt.event.*;

public class Network_ex7_Chat_Client extends Thread implements ActionListener {
// Thread 클래스를 상속받고 ActionListener 인터페이스를 구현하는 
// SimpleClient 클래스를 정의한다. 

Frame frame;
TextArea ta;
TextField tf, tf2;
Dialog dialog;
Label label;

Socket s1;
DataOutputStream dos;
DataInputStream dis;
boolean stop;
String host;

// 필요한 변수를 정의한다. 

public Network_ex7_Chat_Client(){
launchFrame();
}
// 생성자 안에서 launchFrame() 메소드를 호출한다. 

public void launchFrame(){
frame = new Frame("일대일 채팅 실습");
ta = new TextArea();
tf = new TextField();
frame.setBackground(Color.lightGray);
ta.setEditable(false);
frame.add(ta,BorderLayout.CENTER);
frame.add(tf, BoarderLayout.SOUTH);
tf.addActionListener(this);
frame.setSize(500,300);
frame.setVisible(true);
tf.requestFocus();
dialog = new Dialog(frame , " 서버 IP", true);
label = new Label("접속할 서버 IP를 입력하세요");
tf2 = new TextField(15);
dialog.add(label, BoarderLayout.NORTH);
dialog.add(tf2, BoarderLayout.CENTER);
tf2.addActionListener(this);
dialog.pack();
dialog.show();
service(host);
tf2.requestFocus();
}
// 변수에 대한 객체를 생성한다. 

public void service() {
try {
s1 = new Socket(host, 5432);
// 서버의 IP 주소와 5432 포트 번호를 가진 
// Socket 클래스의 객체를 생성한다. 

dis = new DataInputStream(s1.getInputStream());
dos = new DataOutputStream(s1.getOutputStream());
// InputStream 클래스와  OutputStream 클래스를 객체 생성한다. 

ta.append("접속완료.. \n");
this.start();
//스레드를 start() 메소드로 호출한다. 

}catch(IOException e ) {e.printStackTrace();}
}

public static void main(String[] args){
new Network_ex7_Chat_Client();
}

public void actionPerformed(ActionEvent action){
// 텍스트 필드에 대한 이벤트 처리를 위해 actionPerformed() 
//메소드를 구현한다. 

if(tf == action.getSource()){
try {
String msg = tf.getText();
ta.append(msg + "\n");
if(msg.equals("exit")){
ta.append("bye");
stop = true;
dos.close();
s1.close();
System.exit(0);
}else{
dos.writeUTF("서버 : " + msg);
tf.setText("  ");
}
}catch(IOException e){
ta.append(e.toString() + "\n");
}
}else{
host = tf2.getText().trim();
if(host.equals(""))host = "localhost";
dialog.idspose();
}
}

public void run() {
System.out.println("Thread started...");
try {
while(!stop) {
// stop 변수가 true 될 때까지 서버에서 전송된 데이터를 입력받는다. 

ta.append(dis.readUTF() + "\n");
}
dis.close();
s1.close();
}catch(EOFException e){
ta.append("서버로부터 연결이 끊어졌습니다. \n");
}catch(IOException e1){
e1.printStackTrace();
}
}
}

이클립스 한글 깨질 때, 
해당 프로젝트 우클릭에서 
Run 설정에서,
[Arguments]->VM arguments 에
-Dfile.encoding=MS949
입력.

==================================================
화면 구현 

출처
https://m.blog.naver.com/javaking75/140190272629

회원 관리 프로그램 만들기 

1. DB 

 [SQL문]

-- DB 테이블 생성 
CREATE TABLE TB_MEMBER(
    id varchar2(20) NOT NULL, --아이디 // 없는게 정상, primary key  에 포함. 
    pwd varchar2(30) NOT NULL, --비밀번호
    name varchar2(30) NOT NULL, -- 이름
    tel varchar2(20) , -- 전화번호
    addr varchar2(100) , -- 주소
    birth varchar2(8) , -- 생년월일
    job varchar2(50),  -- 직업
    gender varchar2(3) NOT NULL, -- 성별
    email varchar2(50) , -- 이메일
    intro VARCHAR(4000) , -- 자기소개
    CONSTRAINT pk_member PRIMARY KEY(id)  -- 기본키 지정
);

오라클 주석 : -- 



not null : 무조건 값 입력 해야하고, 입력 안하면 오류.
birth :  date  항목으로 변경 하고,
tel :  크기가 작다.
primary key 외부 노출 되므로, 다른 값으로 , primary key 고려하기.


-- DB 테이블 조회
SELECT * FROM TB_MEMBER;

-- DB 테이블구조 확인
DESC TB_MEMBER;

계정 락 해제 
ex)
alter user scott identified by tiger account unlock;
alter user sys identified by oracle account unlock;

입력시, 
각 컬러명 명시 안하면, 무조건 전체 다 입력 하기. 
not null 은 무조건 입력. 

ex) 계정  sys로 디비 만들었음. hr2/ 권한 불충분. 
commit 꼭 하기.
!!
ex) 입력 
insert into TB_MEMBER values ('lsy3709','123456','이상용','010-7661-3709',
'부산진구가야동','841205','강사','남','lsy3709@naver.com','UI 화면구현 테스팅중');

insert into sys.TB_MEMBER values ('lsy3709','123456','이상용','010-7661-3709',
'부산진구가야동','841205','강사','남','lsy3709@naver.com','UI 화면구현 테스팅중');

ex) 수정 
update  테이블명 set 컬럼명=새로운값 [, 추가 콤마로 뒤에 이어서 ]
where = 조건식 ;

update TB_MEMBER set id='lsy37092' where id = 'lsy3709';

ex)삭제 
delete from 테이블명 where 조건식 

delete from TB_MEMBER where id = 'lsy3709';

저장 commit;
취소 rollback;

사용자 삭제 
drop user 사용자 계정 CASCADE;
!

-----------------------------------------------------------------------

DTO ( Data Transfer Object) : 데이터 전송(이동) 객체 , 
DB처리하는데 이용; 테이블의 한 레코드

 
DAO ( Data Access Object) : 데이터 접근 객체 ,  
DB처리 클래스 ( DB연결, Select, update, insert, delete )

MVC ( Model;데이타, View;화면, Controller;처리 ) :

================================================

 [코드] MemberDTO.java - 한명의 회원정보를 저장하는 클래스
 
public class MemberDTO {
   
   
    private String id;
    private String pwd;
    private String name;
    private String tel;
    private String addr;
    private String birth;
    private String job ;
    private String gender;
    private String email;
    private String intro;
 
    //이클립스팁 : Getter/Setter 만들기
    //             우클릭 -> source->Generate Getters And Setters-> [Select AlL] -> [OK]
   
   
    public String getId() {
        return id;
    }
    public void setId(String id) {
        this.id = id;
    }
    public String getPwd() {
        return pwd;
    }
    public void setPwd(String pwd) {
        this.pwd = pwd;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public String getTel() {
        return tel;
    }
    public void setTel(String tel) {
        this.tel = tel;
    }
    public String getAddr() {
        return addr;
    }
    public void setAddr(String addr) {
        this.addr = addr;
    }
    public String getBirth() {
        return birth;
    }
    public void setBirth(String birth) {
        this.birth = birth;
    }
    public String getJob() {
        return job;
    }
    public void setJob(String job) {
        this.job = job;
    }
    public String getGender() {
        return gender;
    }
    public void setGender(String gender) {
        this.gender = gender;
    }
    public String getEmail() {
        return email;
    }
    public void setEmail(String email) {
        this.email = email;
    }
    public String getIntro() {
        return intro;
    }
    public void setIntro(String intro) {
        this.intro = intro;
    }
   
    //DTO 객체 확인
    //이클립스팁 : toString() 자동생성: 우클릭 -> source -> Generate toString->[OK]
    @Override
    public String toString() {
        return "MemberDTO [id=" + id + ", pwd=" + pwd + ", name=" + name
                + ", tel=" + tel + ", addr=" + addr + ", birth=" + birth
                + ", job=" + job + ", gender=" + gender + ", email=" + email
                + ", intro=" + intro + "]";
    }
}

===================================================
 [코드] MemberDAO.java - 데이터베이스에 접근하는 객체
 =========================================

//이름 규칙 : 테이블명DAO , 테이블명DTO
//CRUD : Create;insert , Read;Select, Update, delete
 
import java.sql.*;
import java.util.Vector;
 
import javax.swing.table.DefaultTableModel;
 
//DB 처리
public class MemberDAO {
 
    private static final String DRIVER
        = "oracle.jdbc.driver.OracleDriver";
    private static final String URL
        = "jdbc:oracle:thin:@192.168.0.3:1521:ORCL";
   
    private static final String USER = "SCOTT"; //DB ID
    private static final String PASS = "SCOTT"; //DB 패스워드
    Member_List mList;
   
    public MemberDAO() {
   
    }
   
    public MemberDAO(Member_List mList){
        this.mList = mList;
        System.out.println("DAO=>"+mList);
    }
   
    /**DB연결 메소드*/
    public Connection getConn(){
        Connection con = null;
       
        try {
            Class.forName(DRIVER); //1. 드라이버 로딩
            con = DriverManager.getConnection(URL,USER,PASS); //2. 드라이버 연결
           
        } catch (Exception e) {
            e.printStackTrace();
        }
       
        return con;
    }
   
   
    /**한사람의 회원 정보를 얻는 메소드*/
    public MemberDTO getMemberDTO(String id){
       
        MemberDTO dto = new MemberDTO();
       
        Connection con = null;       //연결
        PreparedStatement ps = null; //명령
        ResultSet rs = null;         //결과
       
        try {
           
            con = getConn();
            String sql = "select * from TB_MEMBER where id=?";
            ps = con.prepareStatement(sql);
            ps.setString(1, id);
           
            rs = ps.executeQuery();
           
            if(rs.next()){
                dto.setId(rs.getString("id"));
                dto.setPwd(rs.getString("Pwd"));
                dto.setName(rs.getString("Name"));
                dto.setTel(rs.getString("tel"));
                dto.setAddr(rs.getString("addr"));
                dto.setBirth(rs.getString("birth"));
                dto.setJob(rs.getString("job"));
                dto.setGender(rs.getString("gender"));
                dto.setEmail(rs.getString("email"));
                dto.setIntro(rs.getString("intro"));
               
            }
        } catch (Exception e) {
            e.printStackTrace();
        }      
       
        return dto;    
    }
   
    /**멤버리스트 출력*/
    public Vector getMemberList(){
       
        Vector data = new Vector();  //Jtable에 값을 쉽게 넣는 방법 1. 2차원배열   2. Vector 에 vector추가
       
           
        Connection con = null;       //연결
        PreparedStatement ps = null; //명령
        ResultSet rs = null;         //결과
       
        try{
           
            con = getConn();
            String sql = "select * from TB_MEMBER order by name asc";
            ps = con.prepareStatement(sql);
            rs = ps.executeQuery();
           
            while(rs.next()){
                String id = rs.getString("id");
                String pwd = rs.getString("pwd");
                String name = rs.getString("name");
                String tel = rs.getString("tel");
                String addr = rs.getString("addr");
                String birth = rs.getString("birth");
                String gender = rs.getString("gender");
                String job = rs.getString("job");
                String email = rs.getString("email");
                String intro = rs.getString("intro");
               
                Vector row = new Vector();
                row.add(id);
                row.add(pwd);
                row.add(name);
                row.add(tel);
                row.add(addr);
                row.add(birth);
                row.add(job);
                row.add(gender);
                row.add(email);
                row.add(intro);
               
                data.add(row);             
            }//while
        }catch(Exception e){
            e.printStackTrace();
        }
        return data;
    }//getMemberList()
   
 
 
    /**회원 등록*/
    public boolean insertMember(MemberDTO dto){
       
        boolean ok = false;
       
        Connection con = null;       //연결
        PreparedStatement ps = null; //명령
       
        try{
           
            con = getConn();
            String sql = "insert into TB_MEMBER(" +
                        "id,pwd,name,tel,addr,birth," +
                        "job,gender,email,intro) "+
                        "values(?,?,?,?,?,?,?,?,?,?)";
           
            ps = con.prepareStatement(sql);
            ps.setString(1, dto.getId());
            ps.setString(2, dto.getPwd());
            ps.setString(3, dto.getName());
            ps.setString(4, dto.getTel());
            ps.setString(5, dto.getAddr());
            ps.setString(6, dto.getBirth());
            ps.setString(7, dto.getJob());
            ps.setString(8, dto.getGender());
            ps.setString(9, dto.getEmail());
            ps.setString(10, dto.getIntro());          
            int r = ps.executeUpdate(); //실행 -> 저장
           
           
            if(r>0){
                System.out.println("가입 성공");   
                ok=true;
            }else{
                System.out.println("가입 실패");
            }
           
               
           
        }catch(Exception e){
            e.printStackTrace();
        }
       
        return ok;
    }//insertMmeber
   
   
    /**회원정보 수정*/
    public boolean updateMember(MemberDTO vMem){
        System.out.println("dto="+vMem.toString());
        boolean ok = false;
        Connection con = null;
        PreparedStatement ps = null;
        try{
           
            con = getConn();           
            String sql = "update TB_MEMBER set name=?, tel=?, addr=?, birth=?, job=?, gender=?" +
                    ", email=?,intro=? "+ "where id=? and pwd=?";
           
            ps = con.prepareStatement(sql);
           
            ps.setString(1, vMem.getName());
            ps.setString(2, vMem.getTel());
            ps.setString(3, vMem.getAddr());
            ps.setString(4, vMem.getBirth());
            ps.setString(5, vMem.getJob());
            ps.setString(6, vMem.getGender());
            ps.setString(7, vMem.getEmail());
            ps.setString(8, vMem.getIntro());
            ps.setString(9, vMem.getId());
            ps.setString(10, vMem.getPwd());
           
            int r = ps.executeUpdate(); //실행 -> 수정
            // 1~n: 성공 , 0 : 실패
           
            if(r>0) ok = true; //수정이 성공되면 ok값을 true로 변경
           
        }catch(Exception e){
            e.printStackTrace();
        }
       
        return ok;
    }
   
    /**회원정보 삭제 :
     *tip: 실무에서는 회원정보를 Delete 하지 않고 탈퇴여부만 체크한다.*/
    public boolean deleteMember(String id, String pwd){
       
        boolean ok =false ;
        Connection con =null;
        PreparedStatement ps =null;
       
        try {
            con = getConn();
            String sql = "delete from TB_MEMBER where id=? and pwd=?";
           
            ps = con.prepareStatement(sql);
            ps.setString(1, id);
            ps.setString(2, pwd);
            int r = ps.executeUpdate(); // 실행 -> 삭제
           
            if (r>0) ok=true; //삭제됨;
           
        } catch (Exception e) {
            System.out.println(e + "-> 오류발생");
        }      
        return ok;
    }
   
   
    /**DB데이터 다시 불러오기*/   
    public void userSelectAll(DefaultTableModel model) {
       
       
        Connection con = null;
        PreparedStatement ps = null;
        ResultSet rs = null;
       
        try {
            con = getConn();
            String sql = "select * from TB_MEMBER order by name asc";
            ps = con.prepareStatement(sql);
            rs = ps.executeQuery();
           
            // DefaultTableModel에 있는 데이터 지우기
            for (int i = 0; i < model.getRowCount();) {
                model.removeRow(0);
            }
 
            while (rs.next()) {
                Object data[] = { rs.getString(1), rs.getString(2),
                        rs.getString(3), rs.getString(4),
                       rs.getString(5),
                        rs.getString(6),
                        rs.getString(7),
                        rs.getString(8),
                        rs.getString(9),
                        rs.getString(10)};
 
                model.addRow(data);                
            }
 
        } catch (SQLException e) {
            System.out.println(e + "=> userSelectAll fail");
        } finally{
           
            if(rs!=null)
                try {
                    rs.close();
                } catch (SQLException e2) {
                    // TODO Auto-generated catch block
                    e2.printStackTrace();
                }
            if(ps!=null)
                try {
                    ps.close();
                } catch (SQLException e1) {
                    // TODO Auto-generated catch block
                    e1.printStackTrace();
                }
            if(con!=null)
                try {
                    con.close();
                } catch (SQLException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
        }
    }
}
 
=======================================================
 [코드 ]MemberProc.java - 회원가입창, 회원정보수정창 
 
 import java.awt.*;
import java.sql.*;
import java.util.*;
import javax.swing.*;
import javax.swing.table.DefaultTableModel;
 
import java.awt.event.*;
 
public class MemberProc extends JFrame implements ActionListener {
   
   
    JPanel p;
    JTextField tfId, tfName, tfAddr, tfEmail;
    JTextField tfTel1, tfTel2, tfTel3; //전화
    JComboBox cbJob; //직업
    JPasswordField pfPwd; //비밀번호   
    JTextField tfYear, tfMonth, tfDate; //생년월일
    JRadioButton rbMan, rbWoman; //남, 여
    JTextArea taIntro;
    JButton btnInsert, btnCancel, btnUpdate,btnDelete; //가입, 취소, 수정 , 탈퇴 버튼
   
    GridBagLayout gb;
    GridBagConstraints gbc;
    Member_List mList ;
   
    public MemberProc(){ //가입용 생성자
       
        createUI(); // UI작성해주는 메소드
        btnUpdate.setEnabled(false);
        btnUpdate.setVisible(false);
        btnDelete.setEnabled(false);
        btnDelete.setVisible(false);
       
       
    }//생성자
   
    public MemberProc(Member_List mList){ //가입용 생성자
       
        createUI(); // UI작성해주는 메소드
        btnUpdate.setEnabled(false);
        btnUpdate.setVisible(false);
        btnDelete.setEnabled(false);
        btnDelete.setVisible(false);
        this.mList = mList;
       
    }//생성자
    public MemberProc(String id,Member_List mList){ // 수정/삭제용 생성자
        createUI();
        btnInsert.setEnabled(false);
        btnInsert.setVisible(false);
        this.mList = mList;
       
       
        System.out.println("id="+id);
       
        MemberDAO dao = new MemberDAO();
        MemberDTO vMem = dao.getMemberDTO(id);
        viewData(vMem);
       
       
    }//id를 가지고 생성
 
       
    //MemberDTO 의 회원 정보를 가지고 화면에 셋팅해주는 메소드
    private void viewData(MemberDTO vMem){
       
        String id = vMem.getId();
        String pwd = vMem.getPwd();
        String name = vMem.getName();
        String tel = vMem.getTel();
        String addr = vMem.getAddr();
        String birth = vMem.getBirth();
        String job = vMem.getJob();
        String gender = vMem.getGender();
        String email= vMem.getEmail();
        String intro = vMem.getIntro();    
       
        //화면에 세팅
        tfId.setText(id);
        tfId.setEditable(false); //편집 안되게
        pfPwd.setText(""); //비밀번호는 안보여준다.
        tfName.setText(name);
        String[] tels = tel.split("-");
        tfTel1.setText(tels[0]);
        tfTel2.setText(tels[1]);
        tfTel3.setText(tels[2]);
        tfAddr.setText(addr);
       
        tfYear.setText(birth.substring(0, 4));
        tfMonth.setText(birth.substring(4, 6));
        tfDate.setText(birth.substring(6, 8));
       
        cbJob.setSelectedItem(job);
       
       
        if(gender.equals("M")){
            rbMan.setSelected(true);
        }else if(gender.equals("W")){
            rbWoman.setSelected(true);
        }
       
        tfEmail.setText(email);
        taIntro.setText(intro);
   
       
    }//viewData
   
   
   
    private void createUI(){
        this.setTitle("회원정보");
        gb = new GridBagLayout();
        setLayout(gb);
        gbc = new GridBagConstraints();
        gbc.fill = GridBagConstraints.BOTH;
        gbc.weightx = 1.0;
        gbc.weighty = 1.0;
       
       
        //아이디
        JLabel bId = new JLabel("아이디 : ");
        tfId = new JTextField(20);     
        //그리드백에 붙이기
        gbAdd(bId, 0, 0, 1, 1);
        gbAdd(tfId, 1, 0, 3, 1);
       
        //비밀번호
        JLabel bPwd = new JLabel("비밀번호 : ");
        pfPwd = new JPasswordField(20);
        gbAdd(bPwd, 0, 1, 1, 1);
        gbAdd(pfPwd, 1, 1, 3, 1);
       
        //이름
        JLabel bName = new JLabel("이름 :");
        tfName = new JTextField(20);
        gbAdd(bName,0,2,1,1);
        gbAdd(tfName,1,2,3,1);
       
        //전화
        JLabel bTel = new JLabel("전화 :");
        JPanel pTel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        tfTel1 = new JTextField(6);    
        tfTel2 = new JTextField(6);    
        tfTel3 = new JTextField(6);
        pTel.add(tfTel1);
        pTel.add(new JLabel(" - "));
        pTel.add(tfTel2);
        pTel.add(new JLabel(" - "));
        pTel.add(tfTel3);
        gbAdd(bTel, 0, 3, 1,1);
        gbAdd(pTel, 1, 3, 3,1);
       
        //주소
        JLabel bAddr = new JLabel("주소: ");
        tfAddr = new JTextField(20);
        gbAdd(bAddr, 0,4,1,1);
        gbAdd(tfAddr, 1, 4, 3,1);
       
        //생일
        JLabel bBirth= new JLabel("생일: ");
        tfYear = new JTextField(6);
        tfMonth = new JTextField(6);
        tfDate = new JTextField(6);
        JPanel pBirth = new JPanel(new FlowLayout(FlowLayout.LEFT));
        pBirth.add(tfYear);
        pBirth.add(new JLabel("/"));
        pBirth.add(tfMonth);
        pBirth.add(new JLabel("/"));
        pBirth.add(tfDate);
        gbAdd(bBirth, 0,5,1,1);
        gbAdd(pBirth, 1, 5, 3,1);
       
        //직업       
        JLabel bJob = new JLabel("직업 : ");
        String[] arrJob = {"---", "학생", "직장인", "주부"};
        cbJob = new JComboBox(arrJob);
        JPanel pJob = new JPanel(new FlowLayout(FlowLayout.LEFT));
        pJob.add(cbJob);       
        gbAdd(bJob, 0,6,1,1);
        gbAdd(pJob,1,6,3,1);
       
        //성별
        JLabel bGender = new JLabel("성별 : ");
        JPanel pGender = new JPanel(new FlowLayout(FlowLayout.LEFT));
        rbMan = new JRadioButton("남",true);
        rbWoman = new JRadioButton("여",true);
        ButtonGroup group = new ButtonGroup();
        group.add(rbMan);
        group.add(rbWoman);
        pGender.add(rbMan);
        pGender.add(rbWoman);      
        gbAdd(bGender, 0,7,1,1);
        gbAdd(pGender,1,7,3,1);
       
        //이메일
        JLabel bEmail = new JLabel("이메일 : ");
        tfEmail = new JTextField(20);
        gbAdd(bEmail, 0,8,1,1);
        gbAdd(tfEmail,1,8,3,1);
       
        //자기소개
        JLabel bIntro = new JLabel("자기 소개: ");
        taIntro = new JTextArea(5, 20); //행 : 열
        JScrollPane pane = new JScrollPane(taIntro);
        gbAdd(bIntro,0,9,1,1);
        gbAdd(pane,1,9,3,1);
       
        //버튼
        JPanel pButton = new JPanel();
        btnInsert = new JButton("가입");
        btnUpdate = new JButton("수정"); 
        btnDelete = new JButton("탈퇴");
        btnCancel = new JButton("취소");     
        pButton.add(btnInsert);
        pButton.add(btnUpdate);
        pButton.add(btnDelete);
        pButton.add(btnCancel);    
        gbAdd(pButton, 0, 10, 4, 1);
       
        //버튼에 감지기를 붙이자
        btnInsert.addActionListener(this);
        btnUpdate.addActionListener(this);
        btnCancel.addActionListener(this);
        btnDelete.addActionListener(this);
       
        setSize(350,500);
        setVisible(true);
        //setDefaultCloseOperation(EXIT_ON_CLOSE); //System.exit(0) //프로그램종료
        setDefaultCloseOperation(DISPOSE_ON_CLOSE); //dispose(); //현재창만 닫는다.
       
       
    }//createUI
   
    //그리드백레이아웃에 붙이는 메소드
    private void gbAdd(JComponent c, int x, int y, int w, int h){
        gbc.gridx = x;
        gbc.gridy = y;
        gbc.gridwidth = w;
        gbc.gridheight = h;
        gb.setConstraints(c, gbc);
        gbc.insets = new Insets(2, 2, 2, 2);
        add(c, gbc);
    }//gbAdd
   
    public static void main(String[] args) {
       
        new MemberProc();
    }
   
 
    @Override
    public void actionPerformed(ActionEvent ae) {
        if(ae.getSource() == btnInsert){
            insertMember();
            System.out.println("insertMember() 호출 종료");
        }else if(ae.getSource() == btnCancel){
            this.dispose(); //창닫기 (현재창만 닫힘)
            //system.exit(0)=> 내가 띄운 모든 창이 다 닫힘          
        }else if(ae.getSource() == btnUpdate){
            UpdateMember();            
        }else if(ae.getSource() == btnDelete){
            //int x = JOptionPane.showConfirmDialog(this,"정말 삭제하시겠습니까?");
            int x = JOptionPane.showConfirmDialog(this,"정말 삭제하시겠습니까?","삭제",JOptionPane.YES_NO_OPTION);
           
            if (x == JOptionPane.OK_OPTION){
                deleteMember();
            }else{
                JOptionPane.showMessageDialog(this, "삭제를 취소하였습니다.");
            }
        }
       
        //jTable내용 갱신 메소드 호출
        mList.jTableRefresh();
       
    }//actionPerformed 
   
   
    private void deleteMember() {
        String id = tfId.getText();
        String pwd = pfPwd.getText();
        if(pwd.length()==0){ //길이가 0이면
           
            JOptionPane.showMessageDialog(this, "비밀번호를 꼭 입력하세요!");
            return; //메소드 끝
        }
        //System.out.println(mList);
        MemberDAO dao = new MemberDAO();
        boolean ok = dao.deleteMember(id, pwd);
       
        if(ok){
            JOptionPane.showMessageDialog(this, "삭제완료");
            dispose();         
           
        }else{
            JOptionPane.showMessageDialog(this, "삭제실패");
           
        }          
       
    }//deleteMember
   
    private void UpdateMember() {
       
        //1. 화면의 정보를 얻는다.
        MemberDTO dto = getViewData();     
        //2. 그정보로 DB를 수정
        MemberDAO dao = new MemberDAO();
        boolean ok = dao.updateMember(dto);
       
        if(ok){
            JOptionPane.showMessageDialog(this, "수정되었습니다.");
            this.dispose();
        }else{
            JOptionPane.showMessageDialog(this, "수정실패: 값을 확인하세요");   
        }
    }
 
    private void insertMember(){
       
        //화면에서 사용자가 입력한 내용을 얻는다.
        MemberDTO dto = getViewData();
        MemberDAO dao = new MemberDAO();       
        boolean ok = dao.insertMember(dto);
       
        if(ok){
           
            JOptionPane.showMessageDialog(this, "가입이 완료되었습니다.");
            dispose();
           
        }else{
           
            JOptionPane.showMessageDialog(this, "가입이 정상적으로 처리되지 않았습니다.");
        }
       
       
       
    }//insertMember
   
    public MemberDTO getViewData(){
       
        //화면에서 사용자가 입력한 내용을 얻는다.
        MemberDTO dto = new MemberDTO();
        String id = tfId.getText();
        String pwd = pfPwd.getText();
        String name = tfName.getText();
        String tel1 = tfTel1.getText();
        String tel2 = tfTel2.getText();
        String tel3 = tfTel3.getText();
        String tel = tel1+"-"+tel2+"-"+tel3;
        String addr = tfAddr.getText();
        String birth1 = tfYear.getText();
        String birth2 = tfMonth.getText();
        String birth3 = tfDate.getText();
        //String birth = birth1+"/"+birth2+"/"+birth3;
        String birth = birth1+birth2+birth3;
        String job = (String)cbJob.getSelectedItem();
        String gender = "";
        if(rbMan.isSelected()){
            gender = "M";
        }else if(rbWoman.isSelected()){
            gender = "W";
        }
       
        String email = tfEmail.getText();
        String intro = taIntro.getText();
       
        //dto에 담는다.
        dto.setId(id);
        dto.setPwd(pwd);
        dto.setName(name);
        dto.setTel(tel);
        dto.setAddr(addr);
        dto.setBirth(birth);
        dto.setJob(job);
        dto.setGender(gender);
        dto.setEmail(email);
        dto.setIntro(intro);
       
        return dto;
    }
   
}//end
 
 ==================================================
  [코드] Member_List.java - 메인창 : 회원리스트 출력
  
import java.awt.BorderLayout;
import java.awt.event.*;
import java.util.*;
import javax.swing.*;
import javax.swing.table.DefaultTableModel;
 
 
public class Member_List extends JFrame implements MouseListener,ActionListener{
   
    Vector v;  
    Vector cols;
    DefaultTableModel model;
    JTable jTable;
    JScrollPane pane;
    JPanel pbtn;
    JButton btnInsert;
       
   
    public Member_List(){
        super("회원관리 프로그램  v0.1.1");
        //v=getMemberList();
        //MemberDAO
        MemberDAO dao = new MemberDAO();
        v = dao.getMemberList();
        System.out.println("v="+v);
        cols = getColumn();
       
        //public DefaultTableModel()
        //public DefaultTableModel(int rowCount, int columnCount)
        //public DefaultTableModel(Vector columnNames, int rowCount)
        //public DefaultTableModel(Object[] columnNames, int rowCount)
        //public DefaultTableModel(Vector data,Vector columnNames)
        //public DefaultTableModel(Object[][] data,Object[] columnNames)
       
        model = new DefaultTableModel(v, cols);
       
        //JTable()
        //JTable(int numRows, int numColumns)
        //JTable(Object[][] rowData, Object[] columnNames)
        //JTable(TableModel dm)
        //JTable(TableModel dm, TableColumnModel cm)
        //JTable(TableModel dm, TableColumnModel cm, ListSelectionModel sm)
        //JTable(Vector rowData, Vector columnNames)
       
        //jTable = new JTable(v,cols);
        jTable = new JTable(model);
        pane = new JScrollPane(jTable);
        add(pane);
       
        pbtn = new JPanel();
        btnInsert = new JButton("회원가입");
        pbtn.add(btnInsert);
        add(pbtn,BorderLayout.NORTH);
       
       
        jTable.addMouseListener(this); //리스너 등록
        btnInsert.addActionListener(this); //회원가입버튼 리스너 등록
       
        setSize(600,200);
        setVisible(true);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    }//end 생성자
   
   
    //JTable의 컬럼
    public Vector getColumn(){
        Vector col = new Vector();
        col.add("아이디");
        col.add("비밀번호");
        col.add("이름");
        col.add("전화");
        col.add("주소");
        col.add("생일");
        col.add("직업");
        col.add("성별");
        col.add("이메일");
        col.add("자기소개");
       
        return col;
    }//getColumn
   
   
    //Jtable 내용 갱신 메서드
    public void jTableRefresh(){
       
        MemberDAO dao = new MemberDAO();
        DefaultTableModel model= new DefaultTableModel(dao.getMemberList(), getColumn());
        jTable.setModel(model);    
       
    }
   
    public static void main(String[] args) {
        new Member_List();
    }//main
    @Override
    public void mouseClicked(MouseEvent e) {
        // mouseClicked 만 사용
        int r = jTable.getSelectedRow();
        String id = (String) jTable.getValueAt(r, 0);
        //System.out.println("id="+id);
        MemberProc mem = new MemberProc(id,this); //아이디를 인자로 수정창 생성
               
    }
    @Override
    public void mouseEntered(MouseEvent e) {
        // TODO Auto-generated method stub
       
    }
    @Override
    public void mouseExited(MouseEvent e) {
        // TODO Auto-generated method stub
       
    }
    @Override
    public void mousePressed(MouseEvent e) {
        // TODO Auto-generated method stub
       
    }
    @Override
    public void mouseReleased(MouseEvent e) {
        // TODO Auto-generated method stub
       
    }
    @Override
    public void actionPerformed(ActionEvent e) {
        //버튼을 클릭하면
        if(e.getSource() == btnInsert ){
            new MemberProc(this);
           
            /*테스트*/
            //dao = new MemberDAO();           
            //dao.userSelectAll(model);
            //model.fireTableDataChanged();
            //jTable.updateUI();           
            //jTable.requestFocusInWindow();
           
        }
       
    }
   
}
 --------------------------------------------------------------------
 완료
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 









